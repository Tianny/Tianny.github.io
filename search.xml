<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发与并行</title>
      <link href="/2020/11/14/program/bing-fa-yu-bing-xing/"/>
      <url>/2020/11/14/program/bing-fa-yu-bing-xing/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:25:53 GMT+0800 (CST) --><p><strong>concurrency vs parallelism</strong>。</p><p>并发指的是程序的结构，并行指的是程序运行时的状态。</p><p>所谓并行，就是<strong>同时执行</strong>的意思。判断程序是否处于并行的<strong>状态</strong>，就看同一时刻是否有超过一个“工作单位”在运行就好了。所以，<strong>单线程永远无法达到并行状态</strong>。</p><p>要理解“并发”这个概念，必须得清楚，<strong>并发指的是程序的“结构”</strong>。当我们说这个程序是并发的，实际上，这句话应当表述成“这个程序采用了支持并发的设计”。既然并发指的是人为设计的结构，那么怎样的程序结构才叫做支持并发的设计？</p><p>并发设计的标准：使多个操作可以在重叠的时间段内进行（two tasks can start, run, and complete in overlapping time periods）。</p><p>这句话的重点有两个。我们先看“操作在重叠的时间段内进行”这个概念。它是否就是我们前面说到的并行呢？是，也不是。并行，当然是在重叠的时间段内执行，但是另外一种执行模式，也属于在重叠时间段内进行。</p><p>下面看并发程序处理的时序图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.jpg" alt></p><p>task1, task2 是两段不同的代码，比如两个函数，其中黑色块代表某段代码正在执行。注意，这里从始至终，<strong>在任何一个时间点上都只有一段代码在执行</strong>，但是，由于 task1 和 task2 在重叠的时间段内执行，所以这是一个支持并发的设计。与并行不同，单核单线程能支持并发。</p><p>那么并发与并行两者之间有何关系？</p><blockquote><p>Different concurrent designs enable different ways to parallelize.</p></blockquote><p>这句话引用自: <a href="http://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">Concurrency is not parallelism</a> 。用自己的话总结来说就是：<strong>并发设计让并发执行成为可能，而并行是并发执行的一种模式</strong>。</p><p>到这里很多人会觉得，并行其实是并发的子集，这句话可对可不对，因为必须站在不同的角度来理解。实际上如果仅限于 Task-Level 这一层，在这一层上，并行无疑是并发的一个子集。</p><p>但是并行并非并发的子集，计算机在不同层次上都使用了并行技术，比如在 Bit-Level 和 Instruction-Level （指令集并行）上的并行不属于并发。具体可以参考《七周七并发模型》里面有提到。</p><p>所以，正确的说法是这样：<strong>并行指物理上同时执行，并发指能够让多个任务在逻辑上交织执行的程序设计</strong></p><p>按照现在的理解，并发针对的是 Task-Level 及更高层，并行则不限。这也是它们的区别。</p><p><a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="noopener">还在迷惑并发与并行</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据中心的进化</title>
      <link href="/2020/11/14/network/shu-ju-zhong-xin-de-jin-hua/"/>
      <url>/2020/11/14/network/shu-ju-zhong-xin-de-jin-hua/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>接上一篇文章，我们知道传统的数据中心一般南北流量要远大于东西流量的。但是随着数据中心里面的机器越来越多，尤其是有了云计算、大数据，集群规模非常大，而且都要求在一个二层网络里面。这就需要二层互连从<strong>汇聚层</strong>上升为<strong>核心层</strong>，也即在核心以下，全部是二层互连，全部在一个广播域里面，这就是常说的<strong>大二层</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-7.jpg" alt></p><p>为了解决环路问题，大二层就引入了<strong>TRILL</strong>（<strong>Transparent Interconnection of Lots of Link</strong>），即<strong>多链接透明互联协议</strong>。它的基本思想是，二层环有问题，三层环没有问题，那就把三层的路由能力模拟在二层实现。具体的原理，这里就不再详细阐述了。</p><p>随着云计算和大数据的发展，节点之间的交互越来越多，例如大数据计算经常要在不同的节点将数据拷贝来拷贝去，这样需要经过交换机，使得数据从左到右，从右到左，左西右东，所以称为<strong>东西流量</strong>。</p><p>为了解决东西流量的问题，演进出了<strong>叶脊网络</strong>（<strong>Spine/Leaf</strong>）。</p><p>叶脊网络架构是叶子层（即叶层）和脊椎层（脊层）组成。其中，叶子层包含了用于连接服务器、存储设备的二层交换机（即叶交换机）；脊椎层包含了用于路由转发的三层交换机（即脊交换机），属于网络的骨干。在叶脊网络架构中，每台叶交换机都需要与架构中的脊交换机连接，通过这种设计，网络中的每台服务器与其他服务器进行数据传输时都只需要通过叶交换机和脊交换机即可，大大提高了数据传输的效率，该网络架构在高性能计算集群应用中尤为重要。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-8.png" alt></p><p>叶脊网络架构的优势，如下：</p><ul><li>相对于传统的三层网络架构而言，叶脊网络架构可减少延迟（等待时间）、流量瓶颈以及扩展网络带宽等。</li><li>减少延迟。叶脊使用所有的互联链路，每台叶交换机都连接到了脊交换机上，脊交换机之间和叶交换机之间没有任何互连，相对于传统的三层网络架构而言，减少了设备寻找或等待连接的需求，从而减少了延迟及流量瓶颈。</li><li>可扩展网络带宽。由于叶脊网络架构可构建在第 2 层或第 3 层，因此在带宽不足时可在脊层添加一个额外的脊交换机，并将其下行链路连接到所有的叶交换机上，从而扩展层级间的带宽并有效降低收敛比。</li><li>传统的三层网络架构采用的是STP协议，当一台设备故障时就会重新收敛，从而影响网络性能甚至可能会导致故障发生。但在叶脊网络架构中，当一台设备故障时，不需重新收敛，流量继续在其他正常路径上传输，网络连通性并不会受影响，同时，因为只是减少一条带宽路径，其对网络性能的影响微乎其微。也就是说，叶脊网络架构具备更高的安全性和可用性。</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP面试系列快重传与快恢复</title>
      <link href="/2020/11/14/network/tcp-mian-shi-xi-lie-kuai-chong-chuan-yu-kuai-hui-fu/"/>
      <url>/2020/11/14/network/tcp-mian-shi-xi-lie-kuai-chong-chuan-yu-kuai-hui-fu/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>TCP 面试系列第八弹，TCP 快重传与快恢复。</p><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。</p><p>快重传示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP-%E5%BF%AB%E9%87%8D%E4%BC%A0.jpeg" alt></p><p>如上图所示，接收方收到了 M1 和 M2 后都分别发出了确认。现假定接收方没有收到 M3 但接着收到了 M4。显然，接收方不能确认 M4，因为 M4 是收到的失序报文段（按照顺序的 M3 还没有收到）。</p><p>根据之前介绍的 TCP 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对 M2 的确认。但按照快重传算法的规定，接收方应及时发送对 M2 的重复确认，这样做可以让发送方及早知道报文段 M3 没有到达接收方。因此，接下来，发送方发送 M5 和 M6 后，接收方收到后，也还是要再次发出对 M2 的重复确认。</p><p>快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段 M3，而不必继续等待为 M3 设置的重传计时器到期。</p><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ol><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh 减半。这是为了预防网络发生拥塞。请注意，接下去不执行慢开始算法。</li><li>由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重的拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口 cwnd 现在不设置为 1），而是把 cwnd 值设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ol><p>如下图所示：注意图上关键点，从收到 3 个重复的确认，执行快重传算法。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.jpeg" alt></p><p>上图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”，这是目前使用得很广泛的版本。</p><p>图中还画出了已经废弃不用的虚线部分（TCP Tahoe 版本）。请注意它们的区别就是：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据中心</title>
      <link href="/2020/11/07/network/shu-ju-zhong-xin/"/>
      <url>/2020/11/07/network/shu-ju-zhong-xin/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>数据中心的架构庞大而复杂，本篇文章只是管中窥豹，介绍基本的概念，从而对数据中心有个基本的认知。如有不对之处，请多多指教。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Rack，机架。数据中心里面是服务器。服务器被放在一个个叫作机架（Rack）的架子上面。</p><p>Border Router，边界路由器。数据中心的入口和出口也是路由器，由于在数据中心的边界，就像在一个国家的边境。为了高可用，边界路由器会有多个。</p><p>运营商网络，一般家里只会连接一个运营商的网络，而为了高可用,，为了当一个运营商出问题的时候，还可以通过另外一个运营商来提供服务，所以数据中心的边界路由器会连接多个运营商网络。</p><p>多线 BGP。既然是路由器，就需要跑路由协议，数据中心往往就是路由协议中的自治区域（AS）。数据中心里面的机器要想访问外面的网站，数据中心里面也是有对外提供服务的机器，都可以通过 BGP 协议，获取内外互通的路由信息。</p><p>TOR（Top Of Rack）交换机。这一层的交换机常常称为接入层（Access Layer）。</p><p>汇聚层交换机（Aggregation Layer）。当一个机架放不下的时候，就需要多个机架，还需要有交换机将多个机架连接在一起。这些交换机对性能的要求更高,带宽也更大。</p><p>网卡绑定（bond）。数据中心里面的每一个连接都是需要考虑高可用的。这里首先要考虑的是，如果一台机器只有一个网卡，上面连着一个网线，接入到TOR 交换机上。如果网卡坏了，或者不小心网线掉了，机器就上不去了。所以,需要至少两个网卡、两个网线插到 TOR 交换机上，但是两个网卡要工作得像一张网卡一样。 这就需要服务器和交换机都支持一种协议 LACP（Link Aggregation Control Protocol）。它们互相通信，将多个网卡聚合称为一个网卡，多个网线聚合成一个网线,在网线之间可以进行负载均衡，也可以为了高可用作准备。</p><p>为了方便大家理解，下面一张是 Rack 机架的图，一张是 LACP 协议图。</p><p>机架图 Rack</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-1.jpg" alt></p><p>LACP 图</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-2.jpg" alt></p><p>有了上面的基本概念之后，我们再进一步深入了解，数据中心的架构。</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>高可用问题，是数据中心必须面对的问题。如何解决？</p><p>传统的方法是，部署两个接入交换机、两个汇聚交换机。服务器和两个接入交换机都连接，接入交换机和两个汇聚都连接，当然这样会形成环，所以需要启用 STP 协议来去除环，但是这样有一个缺点，两个汇聚就只能一主一备，不能同时工作。因为 STP 协议里之前介绍过，只有一条路会起作用。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-3.jpg" alt></p><p>交换机有一种技术叫作<strong>堆叠</strong>，所以另一种方法是，将多个交换机形成一个逻辑的交换机，服务器通过多根线分配连到多个接入层交换机上，而接入层交换机多根线分别连接到多个交换机上，并且通过堆叠的私有协议，形成<strong>双活</strong>的连接方式。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-4.jpg" alt></p><p>由于对带宽要求更大，而且挂了影响也更大，所以两个堆叠可能就不够了，可以就会有更多的，比如四个堆叠为一个逻辑的交换机。</p><p>汇聚层将大量的计算节点相互连接在一起，形成一个集群。在这个集群里面，服务器之间通过二层互通，这个区域常称为一个 POD（Point Of Delivery），有时候也称为一个可用区（Available Zone）。</p><p>当节点数目再多的时候，一个可用区放不下，需要将多个可用区连在一起，连接多个可用区的交换机称为核心交换机。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-5.jpg" alt></p><p>核心交换机吞吐量更大，高可用要求更高，肯定需要堆叠，但是往往仅仅堆叠，不足以满足吞吐量，因而还是需要部署多组核心交换机。核心和汇聚交换机之间为了高可用，也是全互连模式的。</p><p>这个时候还存在那个问题，出现环路怎么办？</p><p>一种方式是，不同的可用区在不同的二层网络，需要分配不同的网段。汇聚和核心之间通过三层网络互通的，二层都不在一个广播域里面，不会存在二层环路的问题。三层有环是没有问题的，只要通过路由协议选择最佳的路径就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-6.jpg" alt></p><p>如上图，核心层和汇聚层之间通过内部的路由协议 OSPF，找到最佳的路径进行访问，而且还可以通过 ECMP 等价路由，在多个路径之间进行负载均衡和高可用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面就是传统数据中心一直采用三层网络架构进行网络部署。</p><p>真复杂啊，未完待续。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN</title>
      <link href="/2020/11/07/network/cdn/"/>
      <url>/2020/11/07/network/cdn/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>回顾上一节的 DNS 内容，当一个用户想访问一个网站的时候，指定这个网站的域名，DNS 就会将这个域名解析为地址，然后用户请求这个地址，返回一个网页。就像你要买个东西，首先要查找商店的位置，然后去商店里面找到自己想要的东西，最后拿着东西回家。</p><p>想一想这里面还有没有可以优化的地方？例如你去电商网站下单买个东西，这个东西一定要从电商总部的中心仓库送过来吗？原来基本是这样的，每一单都是单独配送，所以你可能要很久才能收到你的宝贝。但是后来电商网站的物流系统学聪明了，他们在全国各地建立了很多仓库，而不是只有总部的中心仓库才可以发货。</p><h2 id="CDN-架构"><a href="#CDN-架构" class="headerlink" title="CDN 架构"></a>CDN 架构</h2><p>我们的网站访问可以借鉴”就近配送“这个思路。</p><p>全球有这么多的数据中心，无论在哪里上网，临近不远的地方基本上都有数据中心。是不是可以在这些数据中心里部署几台机器，形成一个缓存的集群来缓存部分数据，那么用户访问数据的时候，就可以就近访问了呢？</p><p>当然是可以的。这些分布在各个地方的各个数据中心的节点，就称为<strong>边缘节点</strong>。</p><p>由于边缘节点数目比较多，但是每个集群规模比较小，不可能缓存下来所有东西，因而可能无法命中，这样就会在边缘节点之上。有区域节点，规模就要更大，缓存的数据会更多，命中的概率也就更大。在区域节点之上是中心节点，规模更大，缓存数据更多。如果还不命中，就只好回源网站访问了。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/CDN.jpg" alt></p><p>上图就是 CDN 的分发系统的架构。CDN 系统的缓存，也是一层一层的，能不访问后端真正的源，就不打扰它。</p><h2 id="CDN-工作机制"><a href="#CDN-工作机制" class="headerlink" title="CDN 工作机制"></a>CDN 工作机制</h2><p>还记得之前讲过的基于 DNS 的全局负载均衡吗？这个负载均衡主要用来选择一个就近的同样运营商的服务器进行访问。你会发现，CDN 分发网络也是一个分布在多个区域、多个运营商的分布式系统，也可以用相同的思路选择最合适的边缘节点。</p><p>流程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/CDN-2.jpg" alt></p><p>在没有 CDN的 情况下，用户向浏览器输入 <a href="http://www.web.com" target="_blank" rel="noopener">www.web.com</a> 这个域名，客户端访问本地 DNS 服务器的时候，如果本地 DNS 服务器有缓存，则返回网站的地址；如果没有，递归查询到网站的权威 DNS 服务器，这个权威 DNS 服务器是负责 web.com 的，它会返回网站的 IP 地址。本地 DNS 服务器缓存下 IP 地址，将 IP 地址返回，然后客户端直接访问这个 IP 地址，就访问到了这个网站。</p><p>然而有了 CDN 之后，情况发生了变化。在 web.com 这个权威 DNS 服务器上，会设置一个 CNAME 别名，指向另外一个域名 <a href="http://www.web.cdn.com" target="_blank" rel="noopener">www.web.cdn.com</a> ，返回给本地 DNS 服务器。</p><p>当本地 DNS 服务器拿到这个新的域名时，需要继续解析这个新的域名。这个时候，再访问的就不是 web.com 的权威 DNS 服务器了，而是 web.cdn.com 的权威 DNS 服务器，这是 CDN 自己的权威 DNS 服务器。在这个服务器上，还是会设置一个 CNAME，指向另外一个域名，也即 CDN 网络的全局负载均衡器。</p><p>接下来，本地 DNS 服务器去请求 CDN 的全局负载均衡器解析域名，全局负载均衡器会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：</p><ul><li><p>根据用户 IP 地址，判断哪一台服务器距用户最近；</p></li><li><p>用户所处的运营商；</p></li><li><p>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需的内容；</p></li><li><p>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</p></li></ul><p>基于以上这些条件，进行综合分析之后，全局负载均衡器会返回一台缓存服务器的 IP 地址。</p><p>本地 DNS 服务器缓存这个 IP 地址，然后将 IP 返回给客户端，客户端去访问这个边缘节点，下载资源。缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</p><h2 id="CDN-缓存内容"><a href="#CDN-缓存内容" class="headerlink" title="CDN 缓存内容"></a>CDN 缓存内容</h2><p>CDN 最擅长的是缓存静态数据，但也支持动态数据的缓存。即动态 CDN，主要有两种模式。</p><ul><li><p>一种为生鲜超市模式，即边缘计算的模式。既然数据是动态生成的，所以数据的逻辑计算和存储，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现。</p></li><li><p>另一种是冷链运输模式，即路径优化的模式。数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。</p></li></ul><p>对于常用的 TCP 连接，在公网上传输的时候经常会丢数据，导致 TCP 的窗口始终很小，发送速度上不去。根据前面的 TCP 流量控制和拥塞控制的原理，在 CDN 加速网络中可以调整 TCP 的参数，使得 TCP 可以更加激进地传输数据。</p><p>可以通过多个请求复用一个连接，保证每次动态请求到达时。连接都已经建立了，不必临时三次握手或者建立过多的连接，增加服务器的压力。另外，可以通过对传输数据进行压缩，增加传输效率。</p><p>所有这些手段就像冷链运输，整个物流优化了，全程冷冻高速运输。不管生鲜是从你旁边的超市送到你家的，还是从产地送的，保证到你家是新鲜的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，而数据缓存在离用户最近的位置。</p></li><li><p>CDN 最擅长的是缓存静态数据，除此之外还可以缓存流媒体数据，这时候要注意使用防盗链。它也支持动态数据的缓存，一种是边缘计算的生鲜超市模式，另一种是链路优化的冷链运输模式。</p></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPDNS原理</title>
      <link href="/2020/10/31/network/httpdns-yuan-li/"/>
      <url>/2020/10/31/network/httpdns-yuan-li/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>聊聊 HTTP DNS 的工作方式。</p><h2 id="传统-DNS-存在的问题"><a href="#传统-DNS-存在的问题" class="headerlink" title="传统 DNS 存在的问题"></a>传统 DNS 存在的问题</h2><p>当我们发出请求解析 DNS 的时候，首先，会先连接到运营商本地的 DNS 服务器，由这个服务器帮我们去整棵 DNS 树上进行解析，然后将解析的结果返回给客户端。但是本地的 DNS 服务器，作为一个本地导游，往往有自己的“小心思”。</p><p>一个最令人头痛的问题，相信每个人都遇到，就是域名劫持。</p><h2 id="HTTPDNS-概念"><a href="#HTTPDNS-概念" class="headerlink" title="HTTPDNS 概念"></a>HTTPDNS 概念</h2><p>HTTPNDS 不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。</p><p>这就相当于每家基于 HTTP 协议，自己实现自己的域名解析，自己做一个自己的地址簿，而不使用统一的地址簿。但是默认的域名解析都是走 DNS 的，因而使用 HTTPDNS 需要绕过默认的 DNS 路径，就不能使用默认的客户端。使用 HTTPDNS 的，往往是手机应用，需要在手机端嵌入支持 HTTPDNS 的客户端 SDK。</p><p>通过自己的 HTTPDNS 服务器和自己的 SDK，实现了从依赖本地导游，到自己上网查询做旅游攻略，进行自由行，爱怎么玩怎么玩。这样就能够避免依赖导游，而导游又不专业，你还不能把他怎么样的尴尬。</p><h2 id="HTTPDNS-工作模式"><a href="#HTTPDNS-工作模式" class="headerlink" title="HTTPDNS 工作模式"></a>HTTPDNS 工作模式</h2><p>在客户端的 SDK 里动态请求服务端，获取 HTTPDNS 服务器的 IP 列表，缓存到本地。随着不断地解析域名，SDK 也会在本地缓存 DNS 域名解析的结果。</p><p>当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地 DNS 的缓存不一样的是，这个是手机应用自己做的，而非整个运营商统一做的。如何更新、何时更新，手机应用的客户端可以和服务器协调来做这件事情。</p><p>如果本地没有，就需要请求 HTTPDNS 的服务器，在本地 HTTPDNS 服务器的IP 列表中，选择一个发出 HTTP 的请求，会返回一个要访问的网站的 IP 列表。</p><p>请求的方式是这样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl http://106.2.xxx.xxx/d?dn=c.m.163.com</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"dns"</span>:[&#123;<span class="string">"host"</span>:<span class="string">"c.m.163.com"</span>,<span class="string">"ips"</span>:[<span class="string">"223.252.199.12"</span>],<span class="string">"ttl"</span>:300,<span class="string">"http2"</span>:0&#125;],<span class="string">"client"</span>:&#123;<span class="string">"ip"</span>:<span class="string">"106.2.81.50"</span>,<span class="string">"line"</span>:269692944&#125;&#125;</span><br></pre></td></tr></table></figure><p>手机客户端自然知道手机在哪个运营商、哪个地址。由于是直接的 HTTP 通信，HTTPDNS 服务器能够准确知道这些信息，因而可以做精准的全局负载均衡。</p><h2 id="HTTPDNS-缓存设计"><a href="#HTTPDNS-缓存设计" class="headerlink" title="HTTPDNS 缓存设计"></a>HTTPDNS 缓存设计</h2><p>HTTPDNS 将解析速度和更新速度全部掌控在自己手中。</p><p>一方面，解析的过程，不需要本地 DNS 服务递归的调用一大圈，一个 HTTP 的请求直接搞定，要实时更新的时候，马上就能起作用；</p><p>另一方面为了提高解析速度，本地也有缓存，缓存是在客户端 SDK 维护的，过期时间、更新时间，都可以自己控制。</p><p>HTTPDNS 的缓存设计策略也是咱们做应用架构中常用的缓存设计模式，也即分为客户端、缓存、数据源三层，分别对应 SDK 客户端、本地缓存、HTTPDNS 服务器。</p><p>只要是缓存模式，就存在缓存的过期、更新、不一致的问题，解决思路也是很像的。</p><p>例如 DNS 缓存在内存中，也可以持久化到存储上，从而 APP 重启之后，能够尽快从存储中加载上次累积的经常访问的网站的解析结果，就不需要每次都全部解析一遍，再变成缓存。这有点像Redis是基于内存的缓存，但是同样提供持久化的能力，使得重启或者主备切换的时候，数据不会完全丢失。</p><p>SDK 中的缓存会严格按照缓存过期时间，如果缓存没有命中，或者已经过期，而且客户端不允许使用过期的记录，则会发起一次解析，保障记录是更新的。</p><p>解析可以同步进行，也就是直接调用 HTTPDNS 的接口，返回最新的记录，更新缓存；也可以异步进行，添加一个解析任务到后台，由后台任务调用HTTPDNS 的接口。</p><h2 id="HTTPDNS-调度设计"><a href="#HTTPDNS-调度设计" class="headerlink" title="HTTPDNS 调度设计"></a>HTTPDNS 调度设计</h2><p>在客户端，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HTTPDNS服务端可以根据这些信息，选择最佳的服务节点返回。</p><p>如果有多个节点，还会考虑错误率、请求时间、服务器压力、网络状况等，进行综合选择，而非仅仅考虑地理位置。当有一个节点宕机或者性能下降的时候，可以尽快进行切换。</p><p>要做到这一点，需要客户端使用 HTTPDNS 返回的 IP 访问业务应用。客户端的 SDK 会收集网络请求数据，如错误率、请求时间等网络请求质量数据，并发送到统计后台，进行分析、聚合，以此查看不同的 IP 的服务质量。</p><p>在服务端，应用可以通过调用 HTTPDNS 的管理接口，配置不同服务质量的优先级、权重。HTTPDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址。</p><p>HTTPDNS 通过智能调度之后返回的结果，也会缓存在客户端。为了不让缓存使得调度失真，客户端可以根据不同的移动网络运营商 WIFI 的 SSID 来分维度缓存。不同的运营商或者 WIFI 解析出来的结果会不同。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/HTTPDNS.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。</p></li><li><p>HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。</p></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS原理</title>
      <link href="/2020/10/31/network/dns-yuan-li/"/>
      <url>/2020/10/31/network/dns-yuan-li/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>聊聊 DNS 的工作方式。</p><h2 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h2><p>DNS 服务器，一定要设置成高可用、高并发和分布式的。于是便有了树状结构，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/DNS-1.jpg" alt></p><p>主要有三个概念：</p><ul><li><p>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</p></li><li><p>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</p></li><li><p>权威 DNS 服务器 ：返回相应主机的 IP 地址</p></li></ul><h2 id="DNS-解析流程"><a href="#DNS-解析流程" class="headerlink" title="DNS 解析流程"></a>DNS 解析流程</h2><p>总结为四个字：递归查询。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/DNS-2.jpg" alt></p><h2 id="DNS-负载均衡"><a href="#DNS-负载均衡" class="headerlink" title="DNS 负载均衡"></a>DNS 负载均衡</h2><p>先看一个简单的，内部负载均衡。</p><p>例如，一个应用要访问数据库，在这个应用里面应该配置这个数据库的 IP 地址，还是应该配置这个数据库的域名呢？显然应该配置域名，因为一旦这个数据库，因为某种原因，换到了另外一台机器上，而如果有多个应用都配置了这台数据库的话，一换 IP 地址，就需要将这些应用全部修改一遍。但是如果配置了域名，则只要在 DNS 服务器里，将域名映射为新的 IP 地址，这个工作就完成了，大大简化了运维。</p><p>在这个基础上，我们可以再进一步。例如，某个应用要访问另外一个应用，如果配置另外一个应用的 IP 地址，那么这个访问就是一对一的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。但是，访问它的应用，如何在多个之间进行负载均衡？只要配置成为域名就可以了。在域名解析的时候，我们只要配置策略，这次返回第一个 IP，下次返回第二个 IP，就可以实现负载均衡了。</p><p>除了上面提到的，DNS 还可以做全局负载均衡。</p><p>通常我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就是全局负载均衡的概念。</p><p>下面以 DNS 访问数据中心中对象存储上的静态资源为例，看看整个过程：</p><p>假设全国有多个数据中心，托管在多个运营商，每个数据中心有三个可用区（Available Zone）。对象存储通过跨可用区部署，实现高可用性。在每个数据中心中，都至少部署两个内部负载均衡器，内部负载均衡器后面对接多个对象存储的前置服务器（Proxy-server）。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/DNS-3.jpg" alt></p><ol><li><p>当一个客户端要访问 object.yourcompany.com 的时候，需要将域名转换为IP地址进行访问，所以它要请求本地 DNS 解析器。</p></li><li><p>本地 DNS 解析器先查看看本地的缓存是否有这个记录。如果有则直接使用，因为上面的过程太复杂了，如果每次都要递归解析，就太麻烦了。</p></li><li><p>如果本地无缓存，则需要请求本地的 DNS 服务器。</p></li><li><p>本地的 DNS 服务器一般部署在你的数据中心或者你所在的运营商的网络中，本地 DNS 服务器也需要看本地是否有缓存，如果有则返回，因为它也不想把上面的递归过程再走一遍。</p></li><li><p>至 7. 如果本地没有，本地 DNS才 需要递归地从根 DNS 服务器，查到 .com 的顶级域名服务器，最终查到 yourcompany.com 的权威 DNS 服务器，给本地DNS 服务器，权威 DNS 服务器按说会返回真实要访问的 IP 地址。</p></li></ol><p>对于不需要做全局负载均衡的简单应用来讲，yourcompany.com 的权威 DNS服务器可以直接将 object.yourcompany.com 这个域名解析为一个或者多个 IP 地址，然后客户端可以通过多个 IP 地址，进行简单的轮询，实现简单的负载均衡。</p><p>但是对于复杂的应用，尤其是跨地域跨运营商的大型应用，则需要更加复杂的全局负载均衡机制，因而需要专门的设备或者服务器来做这件事情，这就是全局负载均衡器（GSLB，Global Server Load Balance）。</p><p>在 yourcompany.com 的DNS服务器中，一般是通过配置 CNAME 的方式，给 object.yourcompany.com 起一个别名，例如 object.vip.yourcomany.com，然后告诉本地 DNS 服务器，让它请求 GSLB 解析这个域名，GSLB 就可以在解析这个域名的过程中，通过自己的策略实现负载均衡。</p><p>图中画了两层的 GSLB，是因为分运营商和地域。我们希望不同运营商的客户，可以访问相同运营商机房中的资源，这样不跨运营商访问，有利于提高吞吐量，减少时延。</p><ol><li><p>第一层 GSLB，通过查看请求它的本地 DNS 服务器所在的运营商，就知道用户所在的运营商。假设是移动，通过 CNAME 的方式，通过另一个别名 object.yd.yourcompany.com，告诉本地 DNS 服务器去请求第二层的 GSLB。</p></li><li><p>第二层 GSLB，通过查看请求它的本地 DNS 服务器所在的地址，就知道用户所在的地理位置，然后将距离用户位置比较近的 Region 里面，六个内部负载均衡（SLB，Server Load Balancer）的地址，返回给本地 DNS 服务器。</p></li><li><p>本地 DNS 服务器将结果返回给本地 DNS 解析器。</p></li><li><p>本地 DNS 解析器将结果缓存后，返回给客户端。</p></li><li><p>客户端开始访问属于相同运营商的距离较近的 Region 1 中的对象存储，当然客户端得到了六个 IP 地址，它可以通过负载均衡的方式，随机或者轮询选择一个可用区进行访问。对象存储一般会有三个备份，从而可以实现对存储读写的负载均衡。</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能；</p></li><li><p>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</p></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS加密原理</title>
      <link href="/2020/10/24/network/https-jia-mi-yuan-li/"/>
      <url>/2020/10/24/network/https-jia-mi-yuan-li/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>HTTPS（SSL/TLS）的加密机制是每个开发者都应该了解和掌握的，虽然框架或库中可能已经封装好，无需我们操心，但是理解 HTTPS 的工作机制，在我们遇到问题时，可以显得游刃有余。</p><p>在开始介绍 HTTPS 之前，需要了解一些密码学相关的概念。因为 HTTPS 的加密机制与之息息相关。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>什么是对称加密？</p><p>在对称加密算法中，加密和解密使用的密钥是相同的。也就是说，加密和解密使用的是同一个密钥。因此，对称加密算法要保证安全性的话，密钥要做好保密。只能让使用的人知道，不能对外公开。</p><p>但怎么来约定这个密钥呢？如果这个密钥在互联网上传输，也是很有可能让黑客截获的。黑客一旦截获这个秘钥，它可以佯作不知，静静地等着你们两个交互。这时候你们之间互通的任何消息，它都能截获并且查看，就等你把银行卡账号和密码发出来。</p><p>所以只能通过线下传输。比如，你和外卖网站偷偷约定时间地点，它给你一个纸条，上面写着你们两个的密钥，然后说以后就用这个密钥在互联网上定外卖了。当然你们接头的时候，也会先约定一个口号，什么”天王盖地虎”之类的，口号对上了，才能把纸条给它。但是，“天王盖地虎”同样也是对称加密密钥，同样存在如何把”天王盖地虎”约定成口号的问题。这样就陷入了死循环了。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。</p><p>非对称加密的私钥放在外卖网站这里，不会在互联网上传输，这样就能保证这个秘钥的私密性。但是，对应私钥的公钥，是可以在互联网上随意传播的，只要外卖网站把这个公钥给你，你们就可以愉快地互通了。</p><p>比如说你用公钥加密，说“我要定外卖”，黑客在中间就算截获了这个报文，因为它没有私钥也是解不开的，所以这个报文可以顺利到达外卖网站，外卖网站用私钥把这个报文解出来，然后回复，“那给我银行卡和支付密码吧”。</p><p>先别太乐观，这里还是有问题的。回复的这句话，是外卖网站拿私钥加密的，互联网上人人都可以把它打开，当然包括黑客。因为外卖网站的公钥在互联网上随意传播的，每个人都可以拿到。同样，黑客也可以模拟用户发送“我要定外卖”这个过程的，因为它也有外卖网站的公钥。</p><p>为了解决这个问题，看来一对公钥私钥是不够的，客户端也需要有自己的公钥和私钥，并且客户端要把自己的公钥，给外卖网站。这样，客户端给外卖网站发送的时候，用外卖网站的公钥加密。而外卖网站给客户端发送消息的时候, 使用客户端的公钥。这样就算有黑客企图模拟客户端获取一些信息，或者半路截获回复信息，但是由于它没有私钥，这些信息它还是打不开。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>如何将不对称加密的公钥给对方呢？一种是放在一个公网的地址上，让对方下载；另一种就是在建立连接的时候，传给对方。</p><p>这两种方法有相同的问题，那就是，作为一个普通网民，你怎么鉴别别人给你的公钥是对的。会不会有人冒充外卖网站，发给你一个它的公钥。接下来，你和它所有的互通，看起来都是没有任何问题的。毕竟每个人都可以创建自己的公钥和私钥。</p><p>公说公有理婆说婆有理，这个时候就需要权威部门的介入了，就像每个人都可以打印自己的简历，说自己是谁，但是有公安局盖章的，就只有户口本，这个才能证明你是你。这个由权威部门颁发的称为证书（Certificate）。</p><p>证书里面有什么呢？当然应该有公钥，这是最重要的；还有证书的所有者，就像户口本上有你的姓名和身份证号，说明这个户口本是你的；另外还有证书的发布机构和证书的有效期，这个有点像身份证上的机构是哪个区公安局，有效期到多少年。</p><p>这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？就像有假身份证、假户口本一样。生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为 CA（ Certificate Authority）。</p><p>将这个请求发给权威机构，权威机构会给这个证书卡一个章，我们称为<strong>签名算法</strong>。问题又来了，那怎么签名才能保证是真的权威机构签名的呢？当然只有用只掌握在权威机构手里的东西签名了才行，这就是 CA 的私钥。</p><p>签名算法大概是这样工作的：一般是对信息做一个 Hash 计算,得到一个 Hash 值，这个过程是不可逆的，也就是说无法通过 Hash 值得出原来的信息内容。在把信息发送出去时，把这个 Hash 值加密后，作为一个签名和信息一起发出去。</p><p>CA 用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。</p><p>证书的内容：这里面有个 Issuer，也即证书是谁颁发的；Subject，就是证书颁发给谁；Validity 是证书期限；Public- key 是公钥内容；Signature Algorithm 是签名算法。</p><p>这下好了，你不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构 CA，你只要得到这个发布机构 CA 的公钥，去解密外卖网站证书的签名，如果解密成功了，Hash 也对的上，就说明这个外卖网站的公钥没有啥问题。</p><p>有没有发现，又有新问题了。要想验证证书，需要 CA 的公钥，问题是，你怎么确定 CA 的公钥就是对的呢? 所以，CA 的公钥也需要更牛的 CA 给它签名，然后形成 CA 的证书。要想知道某个 CA 的证书是否可靠, 要看 CA 的上级证书的公钥，能不能解开这个 CA 的签名。就像你不相信区公安局，可以打电话问市公安局，让市公安局确认区公安局的合法性。这样层层上去，直到全球皆知的几个著名大 CA，称为 root CA，做最后的背书。通过这种层层授信背书的方式，从而保证了非对称加密模式的正常运转。</p><p>以上介绍了几个关键知识点，只有理解了上面的内容，才能继续往下哦。</p><h2 id="HTTPS-工作机制"><a href="#HTTPS-工作机制" class="headerlink" title="HTTPS 工作机制"></a>HTTPS 工作机制</h2><p>我们可以知道，非对称加密在性能上不如对称加密，那是否能将两者结合起来呢？例如，公钥私钥主要用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。</p><p>如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/HTTPS.jpg" alt></p><p>当你登录一个外卖网站的时候，由于是 HTTPS，客户端会发送 Client Hello 消息到服务器，以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息。另外，还会有一个随机数，在协商对称密钥的时候使用。</p><p>这就类似在说：“您好，我想定外卖，但你要保密我吃的是什么。这是我的加密套路，再给你个随机数，你留着。”</p><p>然后，外卖网站返回 Server Hello 消息,，告诉客户端，服务器选择使用的协议版本、加密套件、压缩算法等，还有一个随机数，用于后续的密钥协商。</p><p>这就类似在说：“您好，保密没问题，你的加密套路还挺多，咱们就按套路 2 来吧，我这里也有个随机数，你也留着。”</p><p>然后，外卖网站会给你一个服务器端的证书，然后说：“Server Hello Done，我这里就这些信息了。”</p><p>你当然不相信这个证书，于是你从自己信任的 CA 仓库中,拿 CA 的证书里面的公钥去解密外卖网站的证书。如果能够成功，则说明外卖网站是可信的。这个过程中，你可能会不断往上追溯CA、CA的CA、CA的CA的CA，反正直到一个授信的 CA，就可以了。</p><p>证书验证完毕之后，觉得这个外卖网站可信，于是客户端计算产生随机数字Pre-master，发送 Client Key Exchange，用证书中的公钥加密，再发送给服务器，服务器可以通过私钥解密出来。</p><p>到目前为止，无论是客户端还是服务器，都有了三个随机数，分别是：自己的、对端的以及刚生成的 Pre-Master 随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。</p><p>有了对称密钥，客户端就可以说：“Change Cipher Spec，咱们以后都采用协商的通信密钥和加密算法进行加密通信了。”</p><p>然后发送一个 Encrypted Handshake Message，将已经商定好的参数等，采用协商密钥进行加密，发送给服务器用于数据与握手验证。</p><p>同样，服务器也可以发送 Change Cipher Spec，说：“没问题,咱们以后都采用协商的通信密钥和加密算法进行加密通信了”，并且也发送 Encrypted Handshake Message 的消息试试。当双方握手结束之后，就可以通过对称密钥进行加密传输了。</p><p>这个过程除了加密解密之外，其他的过程和 HTTP 是一样的，过程也非常复杂。</p><p>上面的过程只包含了 HTTPS 的单向认证，也即客户端验证服务端的证书，是大部分的场景，也可以在更加严格安全要求的情况下，启用双向认证，双方互相验证证书。</p><p>至此，我们已自下而上地打通了 HTTPS 加密的整个脉络以及核心知识点，不知你是否真正搞懂了 HTTPS 呢？</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket编程模式</title>
      <link href="/2020/10/24/network/socket-bian-cheng-mo-shi/"/>
      <url>/2020/10/24/network/socket-bian-cheng-mo-shi/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>Socket 编程模式的初步了解，皮毛阶段，仅作为记录参考，方便日后在深入研究。</p><h2 id="将项目外包给其他公司（多进程方式）"><a href="#将项目外包给其他公司（多进程方式）" class="headerlink" title="将项目外包给其他公司（多进程方式）"></a>将项目外包给其他公司（多进程方式）</h2><p>这就相当于你是一个代理，在那里监听来的请求。一旦建立了一个连接，就会有一个已连接 Socket，这时候你可以创建一个子进程，然后将基于已连接Socket的交互交给这个新的子进程来做。就像来了一个新的项目，但是项目不一定是你自己做，可以再注册一家子公司，招点人，然后把项目转包给这家子公司做，以后对接就交给这家子公司了，你又可以去接新的项目了。</p><p>这里有一个问题是，如何创建子公司，并如何将项目移交给子公司呢？</p><p>在 Linux 下，创建子进程使用 fork 函数。通过名字可以看出，这是在父进程的基础上完全拷贝一个子进程。在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程。显然，复制的时候在调用 fork，复制完毕之后，父进程和子进程都会记录当前刚刚执行完 fork。这两个进程刚复制完的时候，几乎一模一样，只是根据 fork 的返回值来区分到底是父进程，还是子进程。如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p><p>进程复制过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/socket%E5%A4%9A%E8%BF%9B%E7%A8%8B.jpg" alt></p><p>因为复制了文件描述符列表，而文件描述符都是指向整个内核统一的打开文件列表的，因而父进程刚才因为 accept 创建的已连接 Socket 也是一个文件描述符，同样也会被子进程获得。</p><p>接下来，子进程就可以通过这个已连接 Socket 和客户端进行互通了，当通信完毕之后，就可以退出进程，那父进程如何知道子进程干完了项目，要退出呢？还记得 fork 返回的时候，如果是整数就是父进程吗？这个整数就是子进程的 ID，父进程可以通过这个 ID 查看子进程是否完成项目，是否需要退出。</p><h2 id="将项目转包给独立的项目组（多线程方式）"><a href="#将项目转包给独立的项目组（多线程方式）" class="headerlink" title="将项目转包给独立的项目组（多线程方式）"></a>将项目转包给独立的项目组（多线程方式）</h2><p>上面这种方式你应该也能发现问题，如果每次接一个项目，都申请一个新公司，然后干完了，就注销掉这个公司，实在是太麻烦了。毕竟一个新公司要有新公司的资产，有新的办公家具，每次都买了再卖，不划算。</p><p>于是你应该想到了，我们可以使用<strong>线程</strong>。相比于进程来讲，这样要轻量级的多。如果创建进程相当于成立新公司，购买新办公家具，而创建线程，就相当于在同一个公司成立项目组。一个项目做完了，那这个项目组就可以解散，组成另外的项目组，办公家具可以共用。</p><p>在 Linux 下，通过 pthread_create 创建一个线程，也是调用 do_fork。不同的是，虽然新的线程在 task 列表会新创建一项，但是很多资源，例如文件描述符列表、进程空间，还是共享的，只不过多了一个引用而已。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/socket%E7%BA%BF%E7%A8%8B.jpg" alt></p><p>新的线程也可以通过已连接 Socket 处理请求，从而达到并发处理的目的。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程。一台机器无法创建很多进程或者线程。有个 <strong>C10K</strong>，它的意思是一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，那么操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器，成本也太高了。</p><p>其实 C10K 问题就是，你接项目接的太多了，如果每个项目都成立单独的项目组，就要招聘 10 万人，你肯定养不起，那怎么办呢？</p><h2 id="方式三：一个项目组支撑多个项目（IO多路复用，一个线程维护多个Socket）"><a href="#方式三：一个项目组支撑多个项目（IO多路复用，一个线程维护多个Socket）" class="headerlink" title="方式三：一个项目组支撑多个项目（IO多路复用，一个线程维护多个Socket）"></a>方式三：一个项目组支撑多个项目（IO多路复用，一个线程维护多个Socket）</h2><p>当然，一个项目组可以看多个项目了。这个时候，每个项目组都应该有个项目进度墙，将自己组看的项目列在那里，然后每天通过项目墙看每个项目的进度，一旦某个项目有了进展，就派人去盯一下。</p><p>由于 Socket 是文件描述符，因而某个线程盯的所有的 Socket，都放在一个文件描述符集合 fd_set 中，这就是<strong>项目进度墙</strong>，然后调用 select 函数来监听文件描述符集合是否有变化。一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的位都设为 1，表示 Socket 可读或者可写，从而可以进行读写操作，然后再调用 select，接着盯着下一轮的变化。</p><h2 id="方式四：一个项目组支撑多个项目（IO多路复用，从“派人盯着”到“有事通知”）"><a href="#方式四：一个项目组支撑多个项目（IO多路复用，从“派人盯着”到“有事通知”）" class="headerlink" title="方式四：一个项目组支撑多个项目（IO多路复用，从“派人盯着”到“有事通知”）"></a>方式四：一个项目组支撑多个项目（IO多路复用，从“派人盯着”到“有事通知”）</h2><p>上面 select 函数还是有问题的，因为每次 Socket 所在的文件描述符集合中有Socket 发生变化的时候，都需要通过轮询的方式，也就是需要将全部项目都过一遍的方式来查看进度，这大大影响了一个项目组能够支撑的最大的项目数量。</p><p>如果改成事件通知的方式，情况就会好很多，项目组不需要通过轮询挨个盯着这些项目，而是当项目进度发生变化的时候，主动通知项目组，然后项目组再根据项目进展情况做相应的操作。</p><p>能完成这件事情的函数叫 epoll，它在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数的方式，当某个文件描述符发送变化的时候，就会主动通知。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/socket_epoll.jpg" alt></p><p>如图所示，假设进程打开了 Socket m, n, x 等多个文件描述符，现在需要通过epoll 来监听是否这些 Socket 都有事件发生。其中 epoll_create 创建一个epoll 对象，也是一个文件，也对应一个文件描述符，同样也对应着打开文件列表中的一项。在这项里面有一个红黑树，在红黑树里，要保存这个 epoll 要监听的所有 Socket。</p><p>当 epoll_ctl 添加一个 Socket的时候，其实是加入这个红黑树，同时红黑树里面的节点指向一个结构，将这个结构挂在被监听的 Socket 的事件列表中。当一个 Socket 来了一个事件的时候，可以从这个列表中得到 epoll 对象，并调用 call back 通知它。</p><p>这种通知方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于TCP协议的Socket程序函数调用过程</title>
      <link href="/2020/10/24/network/ji-yu-tcp-xie-yi-de-socket-cheng-xu-han-shu-diao-yong-guo-cheng/"/>
      <url>/2020/10/24/network/ji-yu-tcp-xie-yi-de-socket-cheng-xu-han-shu-diao-yong-guo-cheng/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>前面讲完了 TCP 和 UDP 协议，还没有上手过，这一节咱们讲讲基于 TCP 和 UDP 协议的 Socket 编程。</p><p>在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p><p>TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。为什么需要端口呢？要知道，你写的是一个应用程序，当一个网络包来的时候，内核要通过 TCP 头里面的这个端口，来找到你这个应用程序，把包给你。为什么要 IP 地址呢？有时候，一台机器会有多个网卡，也就会有多个 IP 地址，你可以选择监听所有的网卡，也可以选择监听一个网卡，这样，只有发给这个网卡的包，才会给你。</p><p>当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。</p><p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p><p>接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。</p><p>在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。</p><p>这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作<strong>监听Socket</strong>，一个叫作<strong>已连接Socket</strong>。</p><p>连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><p>下面一张图就是基于 TCP 协议的 Socket 程序函数调用过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP_socket.jpg" alt></p><p>说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p><p>在内核中，Socket 是一个文件，那对应就有文件描述符。每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标。</p><p>这个数组中的内容是一个指针，指向内核中所有打开的文件的列表。既然是一个文件，就会有一个 inode，只不过 Socket 对应的 inode不像真正的文件系统一样，保存在硬盘上的，而是在内存中的。在这个 inode 中，指向了 Socket 在内核中的 Socket 结构。</p><p>在这个结构里面，主要的是两个队列，一个是<strong>发送队列</strong>，一个是<strong>接收队列</strong>。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构。看到这个，是不是能和前面讲过的收发包的场景联系起来了？</p><p>整个数据结构如图下：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP_socket_struct.jpg" alt></p><blockquote><p>注：如果对进程与文件描述符这段描述不理解的同学，请参考下面一张图，便一目了然：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP面试系列慢开始与拥塞避免</title>
      <link href="/2020/10/24/network/tcp-mian-shi-xi-lie-man-kai-shi-yu-yong-sai-bi-mian/"/>
      <url>/2020/10/24/network/tcp-mian-shi-xi-lie-man-kai-shi-yu-yong-sai-bi-mian/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>TCP 面试系列第七弹，TCP 慢开始与拥塞避免。</p><p>在讨论几种拥塞控制方法前，为了方便大家理解，我们假定：</p><ul><li>数据是单方向传送，而另一个方向只传送确认</li><li>接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定</li></ul><p>拥塞窗口 cwnd (congestion window) 由发送方维持的一个状态变量。发送方让自己的发送窗口等于拥塞窗口。</p><p>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p><p>发送方控制拥塞窗口的原则：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p>下面从慢开始算法讨论，cwnd 是如何变化的。</p><p>慢开始算法的核心思想：在事先不清楚网络的负荷情况下，由小到大逐渐增大拥塞窗口数值。</p><p>在刚开始发送报文段时，先把拥塞窗口 cwnd 设置为最大报文段 MSS 的数值。</p><p>之后在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个 MSS 的数值。</p><p>用这样的方法逐步增大发送方的拥塞窗口 cwnd，从而使分组注入到网络的速率更加合理。</p><p>如下图所示，每经过一个传输轮次（transmission round），拥塞窗口 cwnd 就加倍。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP-%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E4%B8%80.jpeg" alt></p><p>经过上面的分析后，现在我们思考下，为什么叫慢开始，这个慢是指什么慢？</p><p>慢开始的“慢”并不是指 cwnd 的增长速率慢，而是指在 TCP 开始发送报文段时先设置 cwnd = 1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大 cwnd。这当然比按照大的 cwnd 一下子把许多报文段突然注入到网络中要“慢得多”。</p><p>慢开始有没有什么缺陷？或者没有考虑完善的情况？</p><p>我们已经知道，拥塞窗口 cwnd 每经过一个传输轮次，拥塞窗口 cwnd 就加倍。如果拥塞窗口增长速率过大，也会带了网络拥塞。为了解决这个问题，还需要设置一个慢开始门限 ssthresh。</p><p>慢开始门限 ssthresh 规则如下：</p><ul><li>当cwnd &lt; ssthresh时，使用上述的慢开始算法。</li><li>当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li><li>那么什么是拥塞避免算法？拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加1，而不是加倍。这样，拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</li></ul><p>具体例子，如下图所示：慢开始和拥塞避免算法的实现举例</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP-%E6%85%A2%E5%BC%80%E5%A7%8B%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E4%BA%8C.jpeg" alt></p><p>记住，无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。</p><p>根据上面的解释，分析一下图示曲线的走势情况：</p><ol><li>TCP 连接进行初始化时，把拥塞窗口 cwnd 置为 1。</li><li>当执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1。以后发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1，然后开始下一轮的传输（请注意，图示的横坐标是传输轮次）。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。</li><li>假定拥塞窗口的数值增长到 24 时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的 ssthresh 值变为 12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。当 cwnd = ssthresh = 12 时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个 MSS 的大小。</li></ol><p>对于上面的描述，我们可以概括为<strong>乘法减小</strong>和<strong>加法增大</strong>。</p><p>“乘法减小”：指不论在慢开始阶段还是拥塞避免阶段，只要出现超时（即很可能出现了网络拥塞），就把慢开始门限值 ssthresh 减半，即设置为当前的拥塞窗口的一半（与此同时，执行慢开始算法）</p><p>”加法增大”：是指执行拥塞避免算法后，使拥塞窗口缓慢增大。</p><p>上面两种算法合起来就是我们常称的 AIMD 算法。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP面试系列拥塞控制</title>
      <link href="/2020/10/24/network/tcp-mian-shi-xi-lie-yong-sai-kong-zhi/"/>
      <url>/2020/10/24/network/tcp-mian-shi-xi-lie-yong-sai-kong-zhi/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>TCP 面试系列第六弹，TCP 拥塞控制的一般性原理。</p><p>拥塞的定义。</p><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。</p><p>拥塞常常趋于恶化。</p><p>举个例子，如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。</p><p>为了针对上述拥塞带来的网络恶化情况，引入拥塞控制方法。</p><p>如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpeg" alt></p><ul><li>横坐标是提供的负载（offered load），代表单位时间内输入给网络的分组数目</li><li>纵坐标是吞吐量（throughput），代表单位时间内从网络输出的分组数目</li></ul><p>根据上图简要分析。</p><p>理想网络情况下：</p><ol><li>在吞吐量饱和之前，网络吞吐量应等于提供的负载，故吞吐量曲线是 45° 的斜线。</li><li>当提供的负载超过某一限度时，由于网络资源受限，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明提供的负载中有一部分损失掉了（例如，输入到网络的某些分组被某个结点丢弃了）。虽然如此，在这种理想的拥塞控制作用下，网络的吞吐量仍然维持在其所能达到的最大值</li></ol><p>实际网络情况下：</p><ol><li>随着提供的负载的增大，网络吞吐量的增长速率逐渐减小。也就是说，在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了。当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了<strong>轻度拥塞</strong>的状态</li><li>当提供的负载达到某一数值时，网络的吞吐量反而随提供的负载的增大而下降，这时网络就进入了<strong>拥塞状态</strong></li><li>当提供的负载继续增大到某一数值时，网络的吞吐量就下降到零，网络已无法工作，进入到死锁状态。</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP面试系列滑动窗口</title>
      <link href="/2020/10/24/network/tcp-mian-shi-xi-lie-hua-dong-chuang-kou/"/>
      <url>/2020/10/24/network/tcp-mian-shi-xi-lie-hua-dong-chuang-kou/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>TCP 面试系列第五弹，TCP 可靠传输实现之滑动窗口。</p><p>现在我们假定 A 收到了 B 发来的确认报文段，其中窗口是 20（字节），而确认号是 31（这表明 B 期望收到的下一个序号是 31，且到序号 30 为止的数据已经收到了）。根据这两个数据，A 便构造出自己的发送窗口，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpeg" alt>]</p><p>为了方便大家的理解，对照着上图，对一些概念进行阐述。（注意图中的后沿与前沿）</p><p>发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。</p><p>从图上很清晰地看出，发送窗口的位置由窗口前沿和后沿的位置共同确定。</p><p>发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。</p><p>而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间</p><p>关于发送窗口后沿的可能变化：</p><ol><li>不动（没有收到新的确认）</li><li>前移（收到了新的确认）</li></ol><p>关于发送窗口前沿的可能变化：</p><ol><li>向前移动。正常发送新的数据</li><li>不动。原因可能是没有收到新的确认，对方的通知窗口大小也没变；收到了新的确认，但对方通知的窗口缩小了，刚刚好不动</li></ol><p>了解了滑动窗口的基本知识后，下面我们考虑更加滑动窗口一些常见的复杂情况。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A32.jpeg" alt></p><p>上图简要前置假设说明：</p><ul><li>A 发送了序号为 31～41 的数据。</li><li>发送窗口内靠后面有 11 个字节（灰色小方框表示）表示已发送但未收到确认。</li><li>发送窗口内靠前面的 9 个字节（42～50）是允许发送但尚未发送的。</li></ul><p>现在分析接收窗口 B：</p><ul><li>B 的接收窗口大小是 20。</li><li>接收窗口内的序号（31～50）是允许接收的。</li><li>在接收窗口外面，到 30 号为止的数据是已经发送过确认，并且已经交付主机了。因此在 B 可以不再保留这些数据。</li><li>注意，重点来了，现在假设数据没有按序到达，即序号为 31 的数据没有收到（滞留在网络中的某处），也就是说 B 收到了序号为 32 和 33 的数据，却没有收到 31 的数据。这种情况下，B 发送的确认报文段中的确认号 ACK 仍然是 31（即期望收到的序号），而不是 32 或者 33。因为 B 只能对<strong>按序收到</strong>的数据中的最高序号给出确认。</li></ul><p>滑动窗口还有很多复杂的情况，帅天就不一一列举了。但是对于发送窗口、接收窗口和发送前沿和后沿是需要重点掌握的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP面试系列连续ARQ协议</title>
      <link href="/2020/10/24/network/tcp-mian-shi-xi-lie-lian-xu-arq-xie-yi/"/>
      <url>/2020/10/24/network/tcp-mian-shi-xi-lie-lian-xu-arq-xie-yi/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>TCP 面试系列第四弹，可靠性传输之连续 ARQ 协议。</p><p>先来看一张图示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP-%E8%BF%9E%E7%BB%ADARQ.jpeg" alt></p><p>上图（a），表示发送方维持的发送窗口。它的意义是：位于发送窗口内的 5 个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</p><p>图（b），有一个时间坐标（但以后往往省略这样的时间坐标）。按照习惯，“向前“是指向着时间增大的方向，而”向后“则是向着时间减少的方向。分组发送是按照分组序号从小到大发送。</p><p>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p><p>图（b）表示发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组的位置。如果原来已经发送了前 5 个分组，那么现在就可以发送窗口内的第 6 个分组了。</p><p>接收方一般都是采用<strong>累积确认</strong>的方式。也就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对<strong>按序到达</strong>的最后一个分组发送确认。这就表示：到这个分组为止的所有分组都已正确收到了。</p><p>累积确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。</p><p>例如，如果发送方发送了前 5 个分组，而第 3 个分组丢失了。此时接收方只能对前两个分组发出确认，因为接收方只能对按需到达的最后一个分组发送确认。发送方无法知道后面三个分组的下落，只好把后面的三个分组都再重传一次。这就叫做<strong>Go-back-N</strong>（回退N），表示需要再退回来重传已发送过的 N 个分组。</p><p>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP面试系列停止等待协议</title>
      <link href="/2020/10/24/network/tcp-mian-shi-xi-lie-ting-zhi-deng-dai-xie-yi/"/>
      <url>/2020/10/24/network/tcp-mian-shi-xi-lie-ting-zhi-deng-dai-xie-yi/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>TCP 面试系列第三弹，可靠性传输之停止等待协议。</p><p>我们知道，理想的传输条件有以下两个特点：</p><ol><li>传输信道不产生差错。</li><li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li></ol><p>在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。然而实际的网络都不具备以上两个理想条件。但我们可以使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。这样一来，本来是不可靠的传输信道就能够实现可靠传输了。</p><p>下面从最简单的停止等待协议讲起。</p><h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h2><p>因为全双工通信的双方既是发送方也是接收方，下面为了讨论问题的方便，我们仅考虑 A 发送数据而 B 接收数据并发送确认。因此 A 叫做发送方，而 B 叫做接收方。这里是讨论可靠传输的原理，因此把传送的数据单元都称为分组，而并不考虑数据是在哪一个层次上传送的。</p><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-%E6%97%A0%E5%B7%AE%E9%94%99-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpeg" alt></p><p>如上图（a）所示，表示无差错情况下：</p><ol><li>A 发送分组 M1，发完就暂停发送，等待 B 的确认。</li><li>B 收到了M1就向 A 发送确认。</li><li>A 在收到了对 M1的确认后，就再发送下一个分组 M2。</li><li>同样，在收到 B 对 M2 的确认后，再发送 M3。</li></ol><p>如上图 （b）所示，是传输过程中出现了差错的情况下的超时重传机制。</p><p>出现差错分为两种：</p><ol><li>M1在传输的过程中丢失了</li><li>B 接收 M1 时检测出了差错，直接丢弃 M1</li></ol><p>上面两种情况下，B 都不会发送任何消息给 A。</p><p>为了解决上述场景遇到的问题，可靠传输协议是这样设计的：A 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做超时重传。</p><p>要实现超时重传，就要在每发送完一个分组设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</p><p>下面再考虑两种更负载的情况，确认丢失和确认迟到。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1-%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.jpeg" alt></p><p>确认丢失。</p><p>如上图中的（a）所示，假设 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内没有收到确认。原因有很多，可能是 A 自己发送的分组出错、丢失，或者是 B 发送的确认丢失了。 因此 A 在超时计时器到期后就要重传 M1。现在应注意 B 的动作。假定 B 又收到了重传的分组 M1。这时应采取两个行动：</p><ol><li>丢弃这个重复的分组 M1，不向上层交付</li><li>向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1就表示 A 没有收到对 M1 的确认</li></ol><p>确认迟到。</p><p>如上图（b）所示，假设传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。A 会收到重复的确认。 对重复的确认的处理很简单：收下后就丢弃。 B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP面试系列四次挥手</title>
      <link href="/2020/10/24/network/tcp-mian-shi-xi-lie-si-ci-hui-shou/"/>
      <url>/2020/10/24/network/tcp-mian-shi-xi-lie-si-ci-hui-shou/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>TCP 面试系列第二弹，四次挥手。</p><p>如下图所示（左边是 Client， 右边是 Server）：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt></p><ol><li>最初 A 和 B 都处于 ESTABLISHED 状态。</li><li>A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭TCP 连接。</li><li>A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = p，它等于前面已传送过的数据的最后一个字节的序号加 1。这时 A 进入 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认。</li><li>B 收到连接释放报文段后即发出确认，确认号是 ack = p + 1，而这个报文段自己的序号是 seq=v，等于 B 前面已传送过的数据的最后一个字节的序号加 1。</li><li>此时 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，从 A 到 B 这个方向的连接释放了，此时处于半关闭 (half-close) 状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一些时间。</li><li>A 收到来自 B 的确认后，就进入 FIN-WAIT-2（终止等待 2）状态，等待 B 发出的连接释放报文段</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。现假定 B 的序号为 q（在半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack =p + 1。这时 B 就进入 LAST-ACK（最后确认）状态，等待 A 的确认</li><li>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置1，确认号 ack = q + 1，而自己的序号是 seq = p + 1。然后进入到TIME-WAIT（时间等待）状态。</li><li>现在 TCP 连接还没有释放掉。必须经过时间等待计时器 (TIME-WAIT timer) 设置的时间 2MSL 后，A才 进入到 CLOSED 状态。</li></ol><p>上面就是 TCP 四次挥手的整个过程。</p><p>为了加深大家的理解，帅天这里再提出个问题：为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间 ？</p><p>一句话总结就是，为了保证 A 发送的最后一个 ACK 报文段能够到达 B，让 B 成功处于 CLOSED状态。</p><p>假设 A 发送给 B 的最后一段 ACK 确认报文可能丢失，导致 B 没有收到 A 发送的最后一段 ACK 报文，于是 B 会超时重传 FIN + ACK 报文段，而 A 就能在2MSL 时间内收到这个重传的 FIN + ACK 报文段，再次重传最后一段 ACK 报文。最后，A 和 B 都正常进入到 CLOSED 状态。</p><p>如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，如果发送的 ACK 报文段丢失了，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入 CLOSED 状态。</p><p>下面一章帅天将为大家带来 TCP 面试系列第三弹之停止等待协议，敬请关注。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP面试系列三次握手</title>
      <link href="/2020/10/24/network/tcp-mian-shi-xi-lie-san-ci-wo-shou/"/>
      <url>/2020/10/24/network/tcp-mian-shi-xi-lie-san-ci-wo-shou/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>因为这是 TCP 面试系列的第一篇文章，为了让大家奠定好基础，帅天先简单聊聊 TCP 本身的结构。</p><h2 id="TCP-包头格式"><a href="#TCP-包头格式" class="headerlink" title="TCP 包头格式"></a>TCP 包头格式</h2><p>我们先来看 TCP 头的格式。从下面这个图可以看出，它比 UDP 复杂得多。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP.jpg" alt></p><p>可以看到，除了源端口和目的端口，还多了包的序号、确认序号以及状态位和窗口大小等字段。先不用过于深究，这些字段的作用在 TCP 面试系列的文章中都会解释到。</p><p>要想掌握 TCP 协议，帅天给大家总结了一份口诀：</p><ul><li><p>顺序问题 ，稳重不乱；</p></li><li><p>丢包问题，承诺靠谱；</p></li><li><p>连接维护，有始有终；</p></li><li><p>流量控制，把握分寸；</p></li><li><p>拥塞控制，知进知退。</p></li></ul><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>接下来，上今天主菜，TCP 三次握手。</p><p>先看一张，Server 端和 Client 端双方的状态变化时序图（左边是 Client A，右边是 Server B）：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt></p><ol><li>假定主机 A 运行的是 TCP 客户程序，而 B 运行 TCP 服务器程序。</li><li>最初两端的 TCP 进程都处于 CLOSED（关闭）状态。</li><li>A 向 B 发出连接请求报文段，这时报文段首部中的同步位 SYN = 1，同时选择一个初始序号 seq = x。这时，A 进入 SYN-SENT（同步已发送）状态。</li><li>B 收到连接请求报文段后，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。</li><li>A 收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。</li><li>TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</li><li>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。</li></ol><p>这就是 TCP 三次握手的过程，只要弄清楚 SYN 和 ACK 状态位的变化以及发送序号和接收序号的关系，便能掌握了。很简单对不对？</p><h2 id="为什么需要三次握手，而不是两次握手"><a href="#为什么需要三次握手，而不是两次握手" class="headerlink" title="为什么需要三次握手，而不是两次握手"></a>为什么需要三次握手，而不是两次握手</h2><p>为了检验大家掌握了没有，请回答下面的问题：</p><p>为什么需要三次握手，而不是两次握手 ？</p><p>一句话总结就是，为了解决网络中存在延迟的重复分组导致服务端资源浪费问题。</p><p>我们假设 Client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 Server。本来这是一个早已失效的报文段。但 Server 收到此失效的连接请求报文段后，就误认为是 Client 再次发出的一个新的连接请求。于是就向 Client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 Server 发出确认，新的连接就建立了。由于现在 Client 并没有发出建立连接的请求，因此不会理睬 Server 的确认，也不会向 Server 发送数据。但 Server 却以为新的运输连接已经建立，并一直等待 Client 发来数据。这样，Server 的很多资源就白白浪费掉了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>下面一章帅天将为大家带来 TCP 面试系列第二弹之四次挥手，敬请关注。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP协议</title>
      <link href="/2020/10/24/network/udp-xie-yi/"/>
      <url>/2020/10/24/network/udp-xie-yi/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>为什么叫最简单的 UDP 协议，因为相比 TCP 协议，UDP 协议的工作原理简直无脑了太多。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>UDP 全称 User Datagram Protocol，即用户数据报协议。</p><h2 id="UDP-与-TCP-对比"><a href="#UDP-与-TCP-对比" class="headerlink" title="UDP 与 TCP 对比"></a>UDP 与 TCP 对比</h2><p>UDP 和 TCP 经常被拿来比较两者之前的区别。</p><p>TCP 是面向连接的，UDP是面向无连接的，大部分在面试的时候都会这么答。</p><p>那么请问，什么是建立连接？所谓建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</p><p>例如，TCP 是提供可靠交付。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。但是 UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。</p><p>再如，TCP 是面向字节流的。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而 UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收。</p><p>TCP 是可以有拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP 就不会，应用让我发，我就发，其他我烦不了。</p><p>为什么 UDP 这么无脑呢？来看看 UDP 包头是啥样的。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/UDP.jpg" alt></p><p>当我们看到 UDP 包头的时候，发现的确有端口号，有源端口号和目标端口号。同时 UDP 除了端口号，再没有其他的了。就是这么简单。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>所以 UDP 有以下几大使用场景：</p><p>第一，需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。</p><p>第二，不需要一对一沟通，建立连接，而是可以广播的应用，比如 DHCP 协议就是基于 UDP 协议的。</p><p>第三，需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。比如现在很火的网红直播带货。</p><p>UDP 的介绍就到这里，下面一章会重点介绍 TCP 协议。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由协议</title>
      <link href="/2020/10/24/network/lu-you-xie-yi/"/>
      <url>/2020/10/24/network/lu-you-xie-yi/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>这篇文章简单的聊聊路由协议，注意这里是简单，路由协议太复杂，了解一下即可。</p><p>我们在大学里面学习计算机网络与数据结构的时候,知道求最短路径常用的有两种方法，一种是 Bellman-Ford 算法，一种是 Dijkstra 算法。在计算机网络中基本也是用这两种方法计算的。</p><h2 id="距离矢量路由"><a href="#距离矢量路由" class="headerlink" title="距离矢量路由"></a>距离矢量路由</h2><p>距离矢量路由算法，基于 Bellman-Ford 算法。</p><p>有以下几个特征：</p><p>好消息传的快，坏消息传的慢。如果有个路由器加入了这个网络，它的邻居就能很快发现它,然后将消息广播出去。要不了多久,整个网络就都知道了。但是一旦一个路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候,感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了。比如某个人走丢了，问了一圈儿亲戚朋友才确定没看到你，才确定人丢了，这时候才报警，太慢了。</p><p>每次发送的时候,要发送整个全局路由表。网络大了，谁也受不了。它适用于小型网络（小于 15 跳）。</p><h2 id="链路状态路由"><a href="#链路状态路由" class="headerlink" title="链路状态路由"></a>链路状态路由</h2><p>链路状态路由（link state routing），基于 Dijkstra 算法，典型代表 OSPF 协议。</p><p>这种算法的基本思路是，当一个路由器启动的时候，首先是发现邻居，向邻居say hello，邻居都回复。并计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。</p><p>然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而,每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径。</p><p>不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，省了路由器带宽和 CPU 利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。</p><h2 id="距离矢量路由-1"><a href="#距离矢量路由-1" class="headerlink" title="距离矢量路由"></a>距离矢量路由</h2><p>基于距离矢量路由算法的 BGP。</p><p>BGP 协议使用的算法是路径矢量路由协议（path-vector protocol）。它是距离矢量路由协议的升级版。一般用于运营商之间的大型网络。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网关</title>
      <link href="/2020/10/24/network/wang-guan/"/>
      <url>/2020/10/24/network/wang-guan/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>古有关圣爷过五关斩六将，今有小小网络包过网关闯世界。今天帅天给大家剖析一下，从局域网发出的网络包是如何跋山涉水到达外面的世界的。</p><h2 id="如何到达网关"><a href="#如何到达网关" class="headerlink" title="如何到达网关"></a>如何到达网关</h2><p>在任何一台机器上，当要访问另一个 IP 地址的时候，都会先判断，这个目标 IP地址，和当前机器的 IP 地址，是否在同一个网段。怎么判断同一个网段呢？需要 CIDR 和子网掩码。（关于 CIDR 和 子网掩码的知识请看帅天之前写的文章）</p><p>如果是同一个网段，那就不需要通过网关，直接在局域网内部通信，将源地址和目标地址放入 IP 头中，然后通过 ARP 获得 MAC 地址，将源 MAC 和目的 MAC 放入 MAC 头中，发出去就可以了。</p><p>如果不是同一网段，比如访问淘宝，这就需要发往默认网关 Gateway。Gateway 的地址一定是和源 IP 地址是一个网段的。一般都是第一个，例如192.168.1.0/24 这个网段，Gateway 往往会是 192.168.1.1/24。</p><p>如何发往默认网关呢？因为网关和源 IP 肯定是同一个网段的，将源地址和目标 IP 地址放入 IP 头中，通过 ARP 获得网关的 MAC 地址，将源 MAC 和网关的 MAC 放入 MAC头 中，发送出去。这和局域网内部通信方式一样。网关所在的端口，例如 192.168.1.1/24 将网络包收进来，然后接下来怎么做，就完全看网关的了。</p><h2 id="网关如何转发"><a href="#网关如何转发" class="headerlink" title="网关如何转发"></a>网关如何转发</h2><p>网关转发 IP 包的过程中，可能会对网络包中的 IP 头 和 MAC 头进行修改。具体是如何操作的呢？请看下面两个例子。</p><p>第一个例子，IP 头始终保持不变。</p><p>在整个过程中，IP 头里面的地址都是不变的。IP 地址在三个局域网都可见，在三个局域网之间的网段都不会冲突。在三个网段之间传输包，IP 头不改变。</p><p>如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/gateway-1.jpg" alt></p><p>服务器 A 要访问服务器 B。首先，服务器 A 会思考，192.168.4.101和我不是一个网段的，因而需要先发给网关。那网关是谁呢？已经静态配置好了，网关是 192.168.1.1。网关的 MAC 地址是多少呢？发送 ARP 获取网关的 MAC 地址，然后发送包。包的内容是这样的：</p><ul><li>源 MAC：服务器 A 的 MAC</li></ul><ul><li><p>目标 MAC：192.168.1.1 这个网口的 MAC</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.4.101</p></li></ul><p>包到达 192.168.1.1这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>在路由器 A 中配置了静态路由之后，要想访问 192.168.4.0/24，要从192.168.56.1 这个口出去，下一跳为 192.168.56.2。</p><p>于是，路由器 A 思考的时候，匹配上了这条路由，要从 192.168.56.1 这个口发出去，发给 192.168.56.2，那 192.168.56.2 的 MAC 地址是多少呢？路由器 A 发送 ARP 获取 192.168.56.2 的 MAC 地址，然后发送包。包的内容是这样的：</p><ul><li><p>源 MAC：192.168.56.1的 MAC 地址</p></li><li><p>目标 MAC：192.168.56.2的 MAC 地址</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.4.101</p></li></ul><p>包到达 192.168.56.2 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>在路由器 B 中配置了静态路由，要想访问 192.168.4.0/24，要从 192.168.4.1 这个口出去，没有下一跳了。因为我右手这个网卡，就是这个网段的，我是最后一跳了。</p><p>于是，路由器 B 思考的时候，匹配上了这条路由，要从 192.168.4.1 这个口发出去，发给 192.168.4.101。那 192.168.4.101 的 MAC 地址是多少呢？路由器 B 发送 ARP 获取 192.168.4.101 的 MAC 地址，然后发送包。包的内容是这样的：</p><ul><li><p>源 MAC：192.168.4.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.4.101 的 MAC 地址</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.4.101</p></li></ul><p>包到达服务器 B，MAC 地址匹配，将包收进来。</p><p>通过这个过程可以看出，每到一个新的局域网，MAC 都是要变的，但是 IP 地址都不变。在 IP 头里面，不会保存任何网关的 IP 地址。</p><p>第二个例子，IP 头会变。</p><p>看下图，服务器 A 想访问服务器 B，但是细心的同学可能已经发现和上面的例子不同之处在于，服务器 A 的地址和 服务器 B 的 地址是相同的（不同局域网内）。</p><p>怎么解决这个问题呢？既然局域网之间没有商量过，各管各的 IP 分配，那到国际上，就需要使用另外的地址。打个比方，就像出国，仅仅使用国内的身份证是不行的，必须得使用护照。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/gateway-2.jpg" alt></p><p>首先，目标服务器 B 在国际上要有一个国际的身份，我们给它一个192.168.56.2。在网关 B 上，我们记下来，国际身份 192.168.56.2 对应国内身份 192.168.1.101。凡是要访问 192.168.56.2，都转成 192.168.1.101。</p><p>于是，源服务器 A 要访问目标服务器 B，要指定的目标地址为 192.168.56.2。这是它的国际身份。服务器 A 想，192.168.56.2 和我不是一个网段的，因而需要发给网关，网关是谁？已经静态配置好了，网关是 192.168.1.1，网关的MAC 地址是多少？发送 ARP 获取网关的 MAC 地址，然后发送包。包的内容是这样的：</p><ul><li><p>源 MAC：服务器 A 的 MAC</p></li><li><p>目标 MAC：192.168.1.1 这个网口的 MAC</p></li><li><p>源 IP：192.168.1.101</p></li><li><p>目标 IP：192.168.56.2</p></li></ul><p>包到达 192.168.1.1 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>在路由器A中配置了静态路由：要想访问 192.168.56.2/24，要从192.168.56.1 这个口出去，没有下一跳了，因为我右手这个网卡，就是这个网段的，我是最后一跳了。</p><p>于是，路由器 A 思考的时候，匹配上了这条路由，要从 192.168.56.1 这个口发出去，发给 192.168.56.2。那 192.168.56.2 的 MAC 地址是多少呢？路由器 A 发送 ARP 获取 192.168.56.2 的 MAC 地址。</p><p>当网络包发送到中间的局域网的时候，服务器 A 也需要有个国际身份，因而在国际上，源 IP 地址也不能用 192.168.1.101，需要改成 192.168.56.1。发送包的内容是这样的：</p><ul><li><p>源 MAC：192.168.56.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.56.2 的 MAC 地址</p></li><li><p>源 IP：192.168.56.1</p></li><li><p>目标 IP：192.168.56.2</p></li></ul><p>包到达 192.168.56.2 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。</p><p>路由器 B 是一个 NAT 网关，它上面配置了，要访问国际身份 192.168.56.2 对应国内身份 192.168.1.101，于是改为访问 192.168.1.101。</p><p>在路由器 B 中配置了静态路由：要想访问 192.168.1.0/24，要从 192.168.1.1 这个口出去，没有下一跳了，因为我右手这个网卡，就是这个网段的，我是最后一跳了。</p><p>于是，路由器 B 思考的时候，匹配上了这条路由，要从 192.168.1.1 这个口发出去，发给 192.168.1.101。</p><p>那 192.168.1.101 的 MAC 地址是多少呢？路由器 B 发送 ARP 获取192.168.1.101 的 MAC 地址，然后发送包。内容是这样的：</p><ul><li><p>源 MAC：192.168.1.1 的 MAC 地址</p></li><li><p>目标 MAC：192.168.1.101 的 MAC 地址</p></li><li><p>源 IP：192.168.56.1</p></li><li><p>目标 IP：192.168.1.101</p></li></ul><p>包到达服务器 B，MAC 地址匹配，将包收进来。</p><p>从服务器 B 接收的包可以看出，源 IP 为服务器 A 的国际身份，因而发送返回包的时候，也发给这个国际身份，由路由器 A 做 NAT，转换为国内身份。</p><p>从这个过程可以看出， IP 地址也会变。这个就是<strong>Network Address Translation</strong>，简称<strong>NAT</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节描述了网络包经由网关转发的过程，重点阐述了 NAT 场景下 IP 包头部的变化，对网络包经由网关的动作做了详细的拆解，给大家一个深刻感性的认知，方便记忆与理解。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ping与Traceroute</title>
      <link href="/2020/10/24/network/ping-yu-traceroute/"/>
      <url>/2020/10/24/network/ping-yu-traceroute/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>周末了，又到了跟大家聊聊网络知识的时候了。这次帅天跟大家聊聊网络出错排查过程中常使用的命令和工具。</p><p>想象一下以下场景，上网上的好好的，突然告诉你链接断开，大家第一反应是啥？</p><p>帅天首先要夸奖那些能够使用 Ping 或者 Traceroute 的小伙伴，毕竟能把自己的专业知识运用到实际生活中，但是如果只知道如何使用，而不知道这两个工具的工作原理，那么帅天只能给 9 分了（此处@热火名宿韦德）。</p><p>下面帅天就来给大家聊聊 Ping 与 Traceroute 的实现原理，ICMP 协议。</p><h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><p><strong>ICMP</strong> 全称 <strong>Internet Control Message Protocol</strong>，就是<strong>互联网控制报文协议</strong>。ICMP 报文是封装在 IP 包里面的，因为传输指令的时候，肯定需要源地址和目标地址。</p><p>ICMP 报文有很多的类型，主要分为两类，查询报文类型和差错报文类型。</p><p>查询报文类型简单来说就是查询方主动发送侦查协议，等待对方的应答。具体例子，见下面 ping 的使用</p><p>差错报文类型会使用 ICMP 的规则，故意制造一些能够产生错误的场景，从而达到网络诊断的目的。具体例子，见下面 traceroute 的使用。</p><h2 id="Ping-的使用"><a href="#Ping-的使用" class="headerlink" title="Ping 的使用"></a>Ping 的使用</h2><p>ping 的发送和接收过程，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/ping.jpg" alt></p><p>假定主机 A 的 IP 地址是 192.168.1.1，主机 B 的 IP 地址是 192.168.1.2，它们都在同一个子网。那当你在主机A上运行 “ping 192.168.1.2” 后，会发生什么呢?</p><p>ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是<strong>类型字段</strong>，对于请求数据包而言该字段为 8；另外一个是<strong>顺序号</strong>，主要用于区分连续ping的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。</p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为目的地址，本机 IP 地址作为源地址，加上一些其他控制信息，构建一个 IP 数据包。</p><p>接下来，需要加入 MAC 头。如果在本节 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p>主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 B 会构建一个 ICMP 应答包，应答数据包的类型字段为 0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机 A。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p>当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。这个过程后面几节会详细描述，这里暂时不多说。</p><p>如果在自己的可控范围之内，当遇到网络不通的问题的时候，除了直接 ping 目标的 IP 地址之外，还应该有一个清晰的网络拓扑图。并且从理论上来讲，应该要清楚地知道一个网络包从源地址到目标地址都需要经过哪些设备，然后逐个 ping 中间的这些设备或者机器。如果可能的话，在这些关键点，通过tcpdump -i eth0 icmp，查看包有没有到达某个点，回复的包到达了哪个点，可以更加容易推断出错的位置。</p><p>经常会遇到一个问题，如果不在我们的控制范围内，很多中间设备都是禁止 ping 的，但是 ping 不通不代表网络不通。这个时候就要使用 telnet，通过其他协议来测试网络是否通，这个就不在本篇的讲述范围了。</p><p>说了这么多，我们可以看出 ping 这个程序是使用了 ICMP 里面的 ECHO REQUEST 和 ECHO REPLY 类型的。</p><h2 id="Traceroute-使用"><a href="#Traceroute-使用" class="headerlink" title="Traceroute 使用"></a>Traceroute 使用</h2><p>前面我们提到，差错报文类型会使用 ICMP 规则故意制造一些能够产生错误的场景。</p><p>常见的错误场景有以下几个：</p><ol><li>终点不可达：网络不可达、主机不可达、协议不可达、端口不可达、需要进行分片但设置了不分片位</li><li>源站抑制</li><li>时间超时</li><li>路由重定向</li></ol><p>Traceroute 故意制造上面常见错误中的一些场景，以达到诊断网络的目的。</p><p>Traceroute 故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的IP地址，它会发送一个 UDP 的数据包。将 TTL 设置成1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了，于是，返回一个ICMP包，也就是网络差错包，类型是时间超时。接下来将将 TTL 设置为 2，第一关过了第二关又“牺牲了”，依次类推，直到到达目的主机。这样，Traceroute 就拿到了所有的路由器 IP。当然，有的路由器压根不会回这个 ICMP。这也是 Traceroute一个公网的地址，看不到中间路由的原因。</p><p>那又是怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000 ）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Ping 与 Traceroute 是大家平时最常用的命令，这篇文章较为详细的解释了它们的工作原理，并引出了 ICMP 协议。有些公司在面试的时候可能会问的比较深，希望这篇文章能帮到到家。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换机与VLAN</title>
      <link href="/2020/10/24/network/jiao-huan-ji-yu-vlan/"/>
      <url>/2020/10/24/network/jiao-huan-ji-yu-vlan/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>最近有几个学生粉丝后台私信我，让我说说交换机与 VLAN。我在阅读这几个粉丝私信中发现一个有趣的现象，那就是吐槽大学计算机网络课程的晦涩枯燥，而不是去深层次解释协议出现的原因或者用来去解决什么问题。</p><p>帅天今天就和大家聊聊交换机与 VLAN 到底是为何而来，是为了解决什么问题而出现的。在说这个之前，大家首先可以想想前一章提到的 Hub 集线器，仔细的思考一下 Hub 有什么巨大的缺点？</p><h2 id="Hub-的问题"><a href="#Hub-的问题" class="headerlink" title="Hub 的问题"></a>Hub 的问题</h2><p>使用 Hub 这种组网的方法，一旦机器数目增多，问题就出现了。因为 Hub 是广播的，不管某个接口是否需要，所有的 Bit 都会被发送出去，然后让主机来判断是不是需要。</p><p>这种方式路上的车少就没问题，车一多，产生冲突的概率就提高了。而且把不需要的包转发过去，纯属浪费。看来 Hub 这种不管三七二十一都转发的设备是不行了，需要点儿智能的。因为每个口都只连接一台电脑,，这台电脑又不怎么换 IP 和 MAC 地址，只要记住这台电脑的 MAC 地址，如果目标 MAC 地址不是这台电脑的，这个口就不用转发了。</p><h2 id="交换机工作原理"><a href="#交换机工作原理" class="headerlink" title="交换机工作原理"></a>交换机工作原理</h2><p>二层交换机的出现就是为了解决这个问题。我们结合下图看一下二层交换机的工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%8E%9F%E7%90%86.jpg" alt></p><p>如上图所示，两台交换机连接着三个局域网，每个局域网上都有多台机器。如果机器 1 只知道机器 4 的 IP 地址，当它想要访问机器 4，把包发出去的时候，它必须要知道机器 4 的 MAC 地址。</p><ol><li>机器 1 发起广播，机器 2 收到这个广播，但是这不是找它的，所以没它什么事。交换机 A 一开始是不知道任何拓扑信息的，在它收到这个广播后，采取的策略是，除了广播包来的方向外，它还要转发给其他所有的网口。于是机器 3 也收到广播信息了，但是这和它也没什么关系。</li><li>交换机 B 也是能够收到广播信息的，但是这时候它也是不知道任何拓扑信息的，因而也是进行广播的策略，将包转发到局域网三。这个时候，机器 4 和机器 5 都收到了广播信息。机器 4 主动响应说，这是找我的，这是我的 MAC 地址。于是一个 ARP 请求就成功完成了。</li></ol><p>在上面的过程中，交换机 A 和交换机 B 都是能够学习到这样的信息：机器 1 是在左边这个网口的。当了解到这些拓扑信息之后，交换机会维持一个转发表，用来记录。</p><p>当机器 2 要访问机器 1 的时候，机器 2 并不知道机器 1 的 MAC 地址，所以机器 2 会发起一个 ARP 请求。这个广播消息会到达机器 1，也同时会到达交换机 A。根据之前记录的转发表信息，这个时候交换机 A 已经知道机器 1 是不可能在右边的网口的，所以这个广播信息就不会广播到局域网二和局域网三。</p><p>当机器 3 要访问机器 1 的时候，也需要发起一个广播的 ARP 请求。这个时候交换机 A 和交换机 B 都能够收到这个广播请求。交换机 A 当然知道机器 1 是在左边这个网口的，所以会把广播消息转发到局域网一。同时，交换机 B 收到这个广播消息之后，由于它知道机器 1 是不在右边这个网口的，所以不会将消息广播到局域网三。</p><p>当交换机作为一个关卡一样，过了一段时间之后。就有了整个网络的一个结构了。这个时候,基本上不用广播了。全部可以准确转发。当然，每个机器的 IP 地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为转发表，是有一个过期时间的。</p><h2 id="交换机环路问题"><a href="#交换机环路问题" class="headerlink" title="交换机环路问题"></a>交换机环路问题</h2><p>随着办公室越来越大，交换机数目肯定越来越多。当整个拓扑结构复杂了，这么多网线，绕过来绕过去，不可避免地会出现一些意料不到的情况。其中常见的问题就是<strong>环路问题</strong>。</p><p>看下面一张图，当两个交换机将两个局域网同时连接起来的时候。你可能会觉得，这样反而有了高可用性。但是却不幸地出现了环路。出现了环路会有什么结果呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%8E%AF%E8%B7%AF.jpg" alt></p><p>我们再想象一下机器 1 访问机器 2 的过程。一开始，机器 1 并不知道机器 2 的 MAC 地址，所以它需要发起一个 ARP 的广播。广播到达机器 2，机器 2 会把 MAC 地址返回来，看起来没有这两个交换机什么事情。</p><p>但是问题来了，这两个交换机还是都能够收到广播包的。交换机 A 一开始是不知道机器 2 在哪个局域网的，所以它会把广播消息放到局域网二，在局域网二广播的时候，交换机 B 右边这个网口也是能够收到广播消息的。交换机 B 会将这个广播息信息发送到局域网一。局域网一的这个广播消息，又会到达交换机 A 左边的这个接口。交换机 A 这个时候还是不知道机器 2 在哪个局域网，于是将广播包又转发到局域网二。左转左转左转，好像是个圈哦。</p><p>每台机器都会发广播包，交换机转发也会复制广播包，当广播包越来越多的时候，按照上一节讲过一个共享道路的算法，也就是路会越来越堵，最后谁也别想走。所以，必须有一个方法解决环路的问题，怎么破除环路呢？</p><p>在计算机网络中，有一种协议叫 STP ，它就是为解决交换机环路问题而设计的。</p><p>我们知道，在数据结构中，有一个方法叫作<strong>最小生成树</strong>。有环的我们常称为<strong>图</strong>。将图中的环破了，就生成了<strong>树</strong>。在计算机网络中，生成树的算法叫作<strong>STP</strong>，全称<strong>Spanning Tree Protocol</strong>。可以简单理解为，通过比较权重大小从多个交换机中选举出五岳盟主的方式。为了给大家一个感性的认知，可以看下图，通过 STP 算法，网络拓扑最终形成了类似的树结构。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/STP.jpg" alt></p><p>STP 选举过程比较复杂，不是专门从事网络工程师的童鞋理解只需了解即可。</p><h2 id="交换机的安全问题和广播问题"><a href="#交换机的安全问题和广播问题" class="headerlink" title="交换机的安全问题和广播问题"></a>交换机的安全问题和广播问题</h2><p>一般几千人的公司，部门很多，人也很多，机器多了，交换机也多了，就算交换机比 Hub 智能一些，但是还是难免有广播的问题。同时，公司有一些部门是需要保密的部门，比如财务部。由于在同一个广播域里面，很多包都会在一个局域网里面飘啊飘，碰到了一个会抓包的程序员，就能抓到这些包，如果没有加密，就能看到这些敏感信息了。</p><p>为了解决这问题，我们可以使用虚拟隔离技术，也就是常说的 VALN，或者叫虚拟局域网。使用 VLAN，一个交换机上会连属于多个局域网的机器，那交换机怎么区分哪个机器属于哪个局域网呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/VLAN.jpg" alt></p><p>如上图所示，我们只需要在原来的二层的头上加一个 TAG，里面有一个十二位的 VLAN ID。</p><p>如果我们买的交换机是支持 VLAN 的，当这个交换机把二层的头取下来的时候，就能够识别这个 VLAN ID。这样只有相同 VLAN 的包，才会互相转发，不同 VLAN 的包，是看不到的。这样广播问题和安全问题就都能够解决了。</p><p>有人会问交换机之间怎么连接呢？将两个交换机连接起来的口应该设置成什么VLAN 呢？对于支持 VLAN 的交换机，有一种口叫作 <strong>Trunk</strong>。它可以转发属于任何 VLAN 的口。交换机之间可以通过这种口相互连接。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/Trunk.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章先从 Hub 转发任何数据包带来的效率极低情况出发，引出了交换机。交换机有一张转发表用来提高寻址的效率。接着指出交换机存在的环路问题，并提出了 STP 生成树协议的解决方案。最后为了解决交换机的安全问题，介绍了 VLAN 虚拟局域网技术。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC协议</title>
      <link href="/2020/10/24/network/mac-xie-yi/"/>
      <url>/2020/10/24/network/mac-xie-yi/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>上一章我们聊到了网络地址、子网掩码、和广播地址如何计算的问题，这一章节我们来进行一次深潜，聊聊 MAC 层的那些事。</p><h2 id="Hub-集线器"><a href="#Hub-集线器" class="headerlink" title="Hub 集线器"></a>Hub 集线器</h2><p>相信不少读者在大学时代都联机打过游戏，最简单的方法是直接将一根网线连接两台电脑，便形成了一个小型局域网。光两个人玩 CS 不过瘾，宿舍里的其他小伙伴都想加入，此时该怎么办？别急，有办法，大家众筹买个 Hub 集线器就可以了，这样组网也就成功了。</p><p>有人可能会问 Hub 是什么？Hub 叫集线器，是我们上学时那个年代的东西。 集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。但是光这样还不够，这仅仅是第一层物理层联通的方案。</p><p>Hub 采取的是广播的模式，如果每一台电脑发出的包，宿舍的每个电脑都能收到，那就麻烦了。所以这就需要解决几个问题：</p><ol><li>这个包是发给谁的？谁应该接收？</li><li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</li><li>如果发送的时候出现了错误，怎么办？</li></ol><h2 id="MAC-层"><a href="#MAC-层" class="headerlink" title="MAC 层"></a>MAC 层</h2><p>上面的问题就是数据链路层，即 MAC 层要解决的问题。MAC 的全称是 Medium Access Control，即媒体访问控制。控制的就是在往媒体上发数据的时候，谁先发、谁后发的问题。也就是上面的第二个问题。这个问题中的规则学名就叫做多路访问。多路访问的控制规则有很多，比如：</p><ul><li><p>方式一：分多个车道。每个车一个车道，你走你的，我走我的。这在计算机网络里叫作<strong>信道划分；</strong></p></li><li><p>方式二：今天单号出行，明天双号出行，轮着来。这在计算机网络里叫作<strong>轮流协议；</strong></p></li><li><p>方式三：不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作<strong>随机接入协议。</strong>著名的以太网，用的就是这个方式。</p></li></ul><h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>接下来要解决第一个问题，这里要用到一个物理地址，叫链路层地址。因为第二层主要解决媒体接入控制的问题，所以它常被称为 MAC 地址。</p><p>这里又引入另一个问题，一个广播的网络里面接入了 N 台机器，怎么知道每个 MAC 地址是谁呢？这就是 ARP 协议。也就是已知 IP 地址，求 MAC 地址的协议。</p><p>下面看两张图，详细解释了 ARP 协议的工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/ARP-1.jpg" alt></p><p>在一个局域网里面，当知道了IP地址，不知道MAC怎么办呢？靠“吼”。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/ARP-2.jpg" alt></p><p>广而告之，发送一个广播包，谁是这个 IP 谁来回答。具体询问和回答的报文就像下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/ARP-3.jpg" alt></p><p>为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。</p><h3 id="CRC-冗余校验码"><a href="#CRC-冗余校验码" class="headerlink" title="CRC 冗余校验码"></a>CRC 冗余校验码</h3><p>对于第三个问题，让我们回归到二层的数据包格式。对于以太网，看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E4%BB%A5%E5%A4%AA%E7%BD%91.jpg" alt></p><p>除了最开始的目标的 MAC 地址和源的 MAC 地址。还有最后一个 CRC 字段，也就是循环冗余检测。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误。第三个问题也就迎刃而解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章我们从学生时代的宿舍联机游戏引入了 MAC 层，介绍了什么是 MAC 层，并顺带提出了 MAC 层所结局的三个核心问题，并依次对三个抛出的问题进行了解答。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子网计算</title>
      <link href="/2020/10/24/network/zi-wang-ji-suan/"/>
      <url>/2020/10/24/network/zi-wang-ji-suan/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>在讲这篇知识点之前，大家先回顾下 IP 地址分类的知识。随着技术的发展，组网的方式也越来越丰富，因此传统 A、B、C 类的 IP 分类方法已经过时了。为了满足人们的需求，引入了 CIDR 记法。</p><p>什么是 CIDR 记法呢？CIDR 将 32 位的 IP 地址一分为二，前面是网络号，后面是主机号。</p><p>我们以 192.168.1.53/27 为例，斜杠后面有个数字 27。这种地址表示形式，就是 CIDR。后面 27 的意思是，32 位中，前 27 位是网络号，后 5 位是主机号。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码：将网络号全部置 1.</p><p>我们知道 192.168.x.x，按照传统的 IP 分类的话属于 C 类网络。C 类网络默认掩码只有 24 位。但是 /27 显然多出了 3 位，多出的 3 位从哪里来？就需要从主机位借位。</p><p>转换为二进制，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png" alt></p><h2 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h2><p>网络地址：IP 地址 &amp; 子网掩码</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80.png" alt></p><h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p>广播地址：将网络地址右边的表示主机位的部分全部置 1</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80.png" alt></p><p>So，就是这么简单，新技能 Get。</p><p>下一节我们将沿着从物理层到数据链路层这条线，体验新的网络之旅。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子网划分</title>
      <link href="/2020/10/24/network/zi-wang-hua-fen/"/>
      <url>/2020/10/24/network/zi-wang-hua-fen/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>前面一章我们提到随着互联网的飞速发展，网络终端数呈爆炸式增长。最初的 IP 地址分类方式已经不再适用。为了解决日益增长的 IP 地址数需求，子网划分呼之欲出。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最初的两级 IP 地址划分存在许多问题。最典型问题是，两级 IP 地址不够灵活。设想，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到因特网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位的网络，而不必事先到因特网管理机构去申请新的网络号。原来的两级 IP 地址是无法做到这一点的。</p><p>为解决上述问题，从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级 IP 地址变成为三级 IP 地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法就叫作划分子网。</p><h2 id="划分原理"><a href="#划分原理" class="headerlink" title="划分原理"></a>划分原理</h2><p>万变不离其宗：划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。</p><p>三个特点：</p><ol><li>对外仍然表现为一个网络。一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网(subnet)。划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成。</li><li>两级 IP 地址在本单位内部就变为三级 IP 地址：网络号、子网号和主机号。 划分子网的方法是从网络的主机号借用若干位作为子网号 subnet-id，当然主机号也就相应减少了同样的位数。</li><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。</li></ol><p>这里用一张图给读者以直观的展示，摘自《计算机网络》。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP分类</title>
      <link href="/2020/10/24/network/ip-fen-lei/"/>
      <url>/2020/10/24/network/ip-fen-lei/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>聊到 IP 地址分类，相信大部分读者会脱口而出，IP 地址分为 A、B、C、D 类。没错，但是这个答案并不完美。</p><p>要想知道全部的答案，得从 IP 地址的编码方法说起。</p><h2 id="编码方法"><a href="#编码方法" class="headerlink" title="编码方法"></a>编码方法</h2><p>IP 地址的编码方法共经过三个历史阶段:</p><ol><li>分类的 IP</li><li>子网的划分</li><li>超网</li></ol><h2 id="分类的-IP"><a href="#分类的-IP" class="headerlink" title="分类的 IP"></a>分类的 IP</h2><p>先说第一种分类的 IP。即将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成。</p><p>其中第一个字段是网络号（net-id），它标志主机或路由器所连接的网络。一个网络号在整个因特网内必须是唯一的。</p><p>第二个字段是主机号（host-id），它标志该主机（或路由器）。一个主机号在它前面的网络号所指明的网络范围内必须是唯一的。</p><p>根据 IP 地址的范围，由此便划分出 A、B、C、D 这四类地址。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt></p><p>注意，这里要指出，由于近年来已经广泛使用无分类 IP 地址进行路由选择，A类、B类和C类地址的区分已成为历史[RFC 1812]。</p><p>所以这里不用过于记忆，只需了解 IP 分类的最初标准。（手动狗头保命）</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络分层</title>
      <link href="/2020/10/24/network/wang-luo-fen-ceng/"/>
      <url>/2020/10/24/network/wang-luo-fen-ceng/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。人类没法儿沟通，达不成“协议”，通天塔的计划就失败了。但是千年以后，人类凭借智慧创造出了网络协议，连接着全世界所有的人，打造这互联网世界的通天塔，将世界连在了一起。</p><p>如果让我们简单说说计算机网络，相信很多准备过面试的人都会非常了解，但是一旦想要深究『网络到底是如何分层的？』，作者相信大多数人都没有办法回答这个问题，这篇文章就会讨论网络是如何分层的。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>闻道有先后，术业有专攻。每个人都有自己擅长的和不擅长的，便衍生出不同的岗位，分工明确，各尽其责。类比到计算机世界也是如此。</p><p>计算机程序是复杂的，复杂的程序都需要分层，这是程序设计的基本要求。比如电商程序会分数据库层、缓存层、Controller 层和接入层，每一层专注做本层的事情。</p><p>分层解耦、分而治之是贯穿程序设计的一条基本准则，计算机网络协议更为复杂，网络协议设计之初便按分层思想而设计。网络分层之后，网络每一层协议负责的工作都是不一样的，也就对应了有不同设备来处理。</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>不以规矩不成方圆，为了制定统一标准， 国际标准化组织（ISO）于 1984 年提出了一种标准参考模型 OSI。它被公认为是计算机通信和 Internet 网络通信 的一种基本结构模型。</p><p>然而 OSI 七层模型是一个概念模型，并没有说明如何具体实现，是理论标准。在实践过程中，实际上广泛采用 TCP/IP 四层协议结构。</p><p>读者此时可能会产生疑问，一边是 OSI 体系结构，一边是 TCP/IP 体系结构，两者到底是什么关系？</p><p>其实没啥必然关系。 OSI 协议可以理解为官方权威人士提出的一套权威标准，但是实现起来超级困难，属于典型的光说不练假把式。 TCP/IP 协议类似民间高手设计的一套易于实现的通信协议，且难度要比实现 OSI 小很多，所以各大厂商纷纷采用。时至今日，TCP/IP 协议完全统治了江山，整个因特网就是建立在 TCP/IP 协议栈基础之上的。</p><p>而 OSI 协议栈里的一堆协议已经没人再提了，不过你不能说它一无是处，毕竟七个分层模型还是很有科学性的（一本正经的说）。</p><p>下面看一张 OSI 体系结构与 TCP/IP 体系结构的对比图，方便大家理解。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png" alt></p><h2 id="分层处理"><a href="#分层处理" class="headerlink" title="分层处理"></a>分层处理</h2><p>根据之前描述的 TCP/IP 协议栈的分层结构，每层协议栈各司其职，从网络包中取出自己需要的头部处理完后交给自己的上一层或者下一层。这里用一张图描述，参考自《趣谈网络协议》。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节内容从网络分层设计的初衷出发，进而引出了两大广为知名的网络体系结构，OSI 七层模型和 TCP/IP 四层协议结构。接着简单阐述了两个模型之间的区别与联系。最后，用一张图清晰的给读者展示出网络包流经每层时是如何被处理的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-反射</title>
      <link href="/2020/04/23/java/ji-chu/fan-she/"/>
      <url>/2020/04/23/java/ji-chu/fan-she/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-泛型通配符</title>
      <link href="/2020/04/21/java/ji-chu/fan-xing-tong-pei-fu/"/>
      <url>/2020/04/21/java/ji-chu/fan-xing-tong-pei-fu/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>在前面说过，泛型是不变的，为了实现泛型的协变与逆变，我们可以使用泛型通配符。</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;Object&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">        System.out.prinln(c.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法声明没有任何问题，但是调用该方法实际传入的参数值，可能会出错。</p><p>考虑如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">test(strList); <span class="comment">// 编译出错，因为泛型是不变的， List&lt;String&gt; 并不是 List&lt;Object&gt; 的子类。</span></span><br></pre></td></tr></table></figure><p>为了表示各种泛型 List 的父类，可以使用类型通配符。<code>List&lt;?&gt;</code> 表示元素类型未知的 List。这个 <code>？</code> 号被称为通配符，它可以匹配任何类型。</p><p>将上面的代码，改为如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">        System.out.prinln(c.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在传入任何类型的 List，程序可以正常打印集合 c 中的元素。</p><p>这种方法同时带来了另一个问题，即集合中元素的类型会被当成 Object 类型对待。</p><h2 id="泛型通配符的上界"><a href="#泛型通配符的上界" class="headerlink" title="泛型通配符的上界"></a>泛型通配符的上界</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        flist.add(<span class="keyword">new</span> Apple());  <span class="comment">// 编译错误</span></span><br><span class="line">        flist.add(<span class="keyword">new</span> Fruit());  <span class="comment">// 编译错误</span></span><br><span class="line">        flist.add(<span class="keyword">new</span> Object());  <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 flist 的类型是 <code>&lt;? extends Fruit&gt;</code>，extends 指出了泛型的上界为 Fruit。下边界是任意 Fruit 的子类，理论上来说可以是无限多。使用通配符可以将 <code>ArrayList&lt;Apple&gt;</code> 向上转型了，也就实现了协变。</p><p>这样的转换也有一定的副作用。那就是容器的部分功能可能失效。我们不能向一个协变泛型的结构中加入任何元素（除了 null）。观察上面代码，再也不能往容器里任何东西。</p><p>因为泛型的类型擦除原因，类型检查移到了编译期，但协变过程又丢掉了具体的类型（可以是 Fruit 类的任何子类，无法确定到底是哪个子类），导致编译器无法确定真实的类型信息，所以拒绝了插入操作。</p><p>另一方面，我们知道，不论它是什么类型，它总是 Fruit 的子类型，当我们在读取数据时，能确保得到的数据是一个 Fruit 类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fruit get = flist.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>如果一个容器是只读的，才能协变。不然很容易就能把一些特殊的容器协变到更一般的容器，再往里面添加进不应该储存的类型。</p></li><li><p>协变结构可读，不可写。</p></li></ul><h2 id="泛型通配符的下界"><a href="#泛型通配符的下界" class="headerlink" title="泛型通配符的下界"></a>泛型通配符的下界</h2><p>使用通配符 <code>? super T</code>，其中 T 是一个基类型，或者说父类，我们可以向逆变结构中添加任何 T 及 T 的子类。</p><p>逆变结构可写，不可读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Fruit());  <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List&lt;? super Apple&gt;</code> 指定了泛型的下界是 Apple。上边界是模糊的，任意 Apple 的父类都可以，存在无限的可能性，无法确定具体的类型（可以是 Apple 的任何父类，无法确定到底是哪个父类）。所以只能添加 Apple 及其子类。</p><p>只能取出 Object 实例：因为我们不知道超类究竟是什么，编译器唯一能保证的只是它是个 Object，因为 Object 是任何 Java 类型的超类。</p><h2 id="存取原则"><a href="#存取原则" class="headerlink" title="存取原则"></a>存取原则</h2><ul><li>如果你想从一个数据类型里获取数据，使用<code>&lt;? extends T&gt;</code> 通配符。</li><li>如果你想把对象写入一个数据结构里，使用<code>&lt;? super T&gt;</code> 通配符。</li><li>如果你既想存，又想取，那就别用通配符。</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-协变与逆变</title>
      <link href="/2020/04/20/java/ji-chu/xie-bian-yu-ni-bian/"/>
      <url>/2020/04/20/java/ji-chu/xie-bian-yu-ni-bian/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>在介绍泛型的通配符之前，首先需要了解下协变与逆变的相关知识。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果 𝐴、𝐵 表示类型，𝑓(⋅) 表示类型转换，≤ 表示继承关系（比如 𝐴≤𝐵 表示 𝐴 是由 𝐵 派生出来的子类）</p><ul><li>𝑓(⋅) 是逆变（contravariant）的，当 𝐴≤𝐵 时有 𝑓(𝐵)≤𝑓(𝐴) 成立；</li><li>𝑓(⋅) 是协变（covariant）的，当 𝐴≤𝐵 时有 𝑓(𝐴)≤𝑓(𝐵) 成立；</li><li>𝑓(⋅) 是不变（invariant）的，当 𝐴≤𝐵 时上述两个式子均不成立，即 𝑓(𝐴) 与 𝑓(𝐵) 相互之间没有继承关系。</li></ul><h2 id="数组是协变的"><a href="#数组是协变的" class="headerlink" title="数组是协变的"></a>数组是协变的</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number[] numbers = <span class="keyword">new</span> Number[<span class="number">3</span>];</span><br><span class="line">numbers[<span class="number">0</span>] = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="keyword">new</span> Double(<span class="number">3.14</span>);</span><br><span class="line">numbers[<span class="number">2</span>] = <span class="keyword">new</span> Long(<span class="number">99L</span>);</span><br></pre></td></tr></table></figure><p>包装类 Integer、Double、Long 是 Number 的子类，numbers 数组中的元素的类型可以是任何 Number 的子类。我们称 Java 数组是协变的 (Covariant)。</p><p>不仅如此，下面的代码也是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] IntArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">Number[] NumberArray = IntArray;</span><br><span class="line">Number n = NumberArray[<span class="number">0</span>]; <span class="comment">//从一个协变结构中读取元素</span></span><br></pre></td></tr></table></figure><p>根据协变的定义，因为数组是协变的，所以 Integer[] 是 Number[] 的子类。可以将子类型的数组赋予基类型的数组引用。即父类的引用可以指向子类对象。</p><p>但是这会导致一个有趣的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] IntArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">Number[] NumberArray = IntArray;</span><br><span class="line">NumberArray[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">NumberArray[<span class="number">0</span>] = <span class="number">3.14</span>; <span class="comment">//尝试污染一个Integer数组 runtime error</span></span><br></pre></td></tr></table></figure><p>在编译时，上面的代码不会报错，但是运行时最后一行代码会抛出 ArrayStoreException。很明显，即使通过一个 Number[] 引用，也不能将一个浮点数放入一个事实上的 Integer[] 数组。因为在运行时知道这个数组的真实类型为存放 Integer 类型的数组。</p><h2 id="泛型是不变的"><a href="#泛型是不变的" class="headerlink" title="泛型是不变的"></a>泛型是不变的</h2><p>要理解泛型是不变的，需要在此之前说明泛型的擦除机制。</p><p>因为 JDK1.5 中才引入泛型机制，为了兼容旧的字节码，Java 规范在编译时对泛型进行了类型擦除。也就是说我们使用的所有泛型仅仅存在于编译期间，当通过编译器检查后，泛型信息都会被删除。在运行时，JVM 处理的都是没有携带泛型信息的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的执行结果为 true。</p><p>尽管 ArrayList&lt;String&gt; 和 ArrayList&lt;Integer&gt; 看上去是不同的类型，但在运行时实际上是相同的类型。这两种类型都被擦除成它们的原生类型，即 ArrayList。</p><p>再看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCovariantGenerics</span> </span>&#123;</span><br><span class="line">    List&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;(); <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit[] fruit = <span class="keyword">new</span> Apple[<span class="number">10</span>]; <span class="comment">// 编译正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与数组不同，泛型没有内建的协变类型。虽然 Apple 是 Fruit 的子类，但 <code>ArrayList&lt;Apple&gt;</code> 并不是 <code>List&lt;Fruit&gt;</code> 的子类，NonCovariantGenerics 直接在编译时报错了。</p><p>泛型虽然是不变的，但有时需要实现协变和逆变，这时就要用到泛型通配符了。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-泛型</title>
      <link href="/2020/04/17/java/ji-chu/fan-xing/"/>
      <url>/2020/04/17/java/ji-chu/fan-xing/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在没有泛型前，一旦把一个对象丢进集合中，集合就会忘记对象的类型，把所有的对象都当成 Object 类型处理。当程序从集合中取出对象后，就需要进行强制类型转换，这种转换很容易引起 ClassCastException 异常。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>程序在创建集合时指定集合元素的类型。增加了泛型支持后的集合，可以记住集合中元素的类型，并可以在编译时检查集合中元素的类型，如果试图向集合中添加不满足类型要求的对象，编译器就会报错。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>两个示例，简单介绍泛型的基本使用。</p><h3 id="集合使用泛型"><a href="#集合使用泛型" class="headerlink" title="集合使用泛型"></a>集合使用泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiamondTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; books = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        books.add(<span class="string">"learn"</span>);</span><br><span class="line">        books.add(<span class="string">"java"</span>);</span><br><span class="line">        books.forEach(book -&gt; System.out.println(book.length()));</span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; schoolsInfo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; schools = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        schools.add(<span class="string">"i"</span>);</span><br><span class="line">        schools.add(<span class="string">"love"</span>);</span><br><span class="line">        schoolsInfo.put(<span class="string">"java"</span>, schools);</span><br><span class="line">        schoolsInfo.forEach((key, value) -&gt; System.out.println(key + <span class="string">"---&gt;"</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类、接口使用泛型"><a href="#类、接口使用泛型" class="headerlink" title="类、接口使用泛型"></a>类、接口使用泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T info;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getinfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple&lt;String&gt; a1 = <span class="keyword">new</span> Apple&lt;&gt;(<span class="string">"Apple"</span>);</span><br><span class="line">        System.out.println(a1.getinfo());</span><br><span class="line">        Apple&lt;Double&gt; a2 = <span class="keyword">new</span> Apple&lt;&gt;(<span class="number">5.67</span>);</span><br><span class="line">        System.out.println(a2.getinfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-集合</title>
      <link href="/2020/04/02/java/ji-chu/ji-he/"/>
      <url>/2020/04/02/java/ji-chu/ji-he/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h2><p>List 集合中元素有序、可重复，集合中每个元素都有其对应的索引顺序。</p><blockquote><p>List 判断两个对象相等，只要通过 equals 方法比较返回 true 即可。</p></blockquote><p>看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List books = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"a"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"b"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"c"</span>));</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        books.remove(<span class="keyword">new</span> A());</span><br><span class="line">        System.out.println(books);</span><br><span class="line">        books.remove(<span class="keyword">new</span> A());</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当试图删除一个 A 对象时，List 会调用 A 对象的 equals 方法依次与集合元素进行比较。如果 equals 方法以某个集合元素作为参数时返回 true，List 将会删除该元素。这里 A 重写了 equals 方法，总是返回 true，所以每次都会从 List 集合中删除一个元素。</p><h3 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h3><p>ArrayList 类是基于数组实现的 List 类，完全支持前面介绍的 List 接口的全部功能。</p><p>ArrayList 封装了一个动态的、允许再分配的 Object[] 数组。</p><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><ul><li><p>元素没有顺序，集合元素的值可以是 null</p></li><li><p>HashSet 不是同步的，假设有多个线程同时修改了 HashSet 集合时，必须通过代码来保证其同步</p></li></ul><blockquote><p>HashSet 判断元素相等的标准是两个对象通过 equals() 比较相等，同时两个对象的 hashCode()返回值也相等。</p></blockquote><blockquote><p>hashCode 和 equals 符合这样一个约定:equals 返回 true， hashCode 必须相等。很多 Java 类库中的代码都是按照这种约定使用这两个方法的，比如 HashSet。</p></blockquote><p>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来获得该对象的 hashCode 值，然后根据该 hashCode 值决定该对象在 HashSet 中的存储位置。</p><p>HashSet 中每个能存储元素的槽位称为桶(bucket)。如果多个元素的 hashCode 值相同，但它们通过 equals 方法比较返回 false，就需要在一个桶里放多个元素，这会导致性能下降。所以，建议在需要把某个类的对象保存到 HashSet 集合时，重写该类的 equals 和 hashCode 方法，尽量保证两个对象通过 equals 方法比较返回 true 时，他们的 hashCode 方法返回值也相等。</p><p>当把可变对象添加到 HashSet 中后，需要特别小心，尽量不要去修改可变对象中参与计算 hashCode() 、equals() 方法的实例变量，否则会导致 HashSet 无法正确访问这些集合元素。</p><p>看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">R</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"R[count:"</span> + count + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == R.class) &#123;</span><br><span class="line">            R r = (R)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count == r.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet hs = <span class="keyword">new</span> HashSet();</span><br><span class="line">        hs.add(<span class="keyword">new</span> R(<span class="number">5</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> R(-<span class="number">3</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> R(<span class="number">9</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> R(-<span class="number">2</span>));</span><br><span class="line">        System.out.println(hs);</span><br><span class="line">        Iterator it = hs.iterator();</span><br><span class="line">        R first = (R)it.next();</span><br><span class="line">        first.count = -<span class="number">3</span>;</span><br><span class="line">        System.out.println(hs);</span><br><span class="line">        hs.remove(<span class="keyword">new</span> R(-<span class="number">3</span>));</span><br><span class="line">        System.out.println(hs);</span><br><span class="line">        System.out.println(<span class="string">"hs 是否包含 count 为 -3 的 R 对象"</span> + hs.contains(<span class="keyword">new</span> R(-<span class="number">3</span>)));</span><br><span class="line">        System.out.println(<span class="string">"hs 是否包含 count 为 -2 的 R 对象"</span> + hs.contains(<span class="keyword">new</span> R(-<span class="number">2</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[R[count:-2], R[count:-3], R[count:5], R[count:9]]</span></span><br><span class="line"><span class="comment">[R[count:-3], R[count:-3], R[count:5], R[count:9]]</span></span><br><span class="line"><span class="comment">[R[count:-3], R[count:5], R[count:9]]</span></span><br><span class="line"><span class="comment">hs 是否包含 count 为 -3 的 R 对象false</span></span><br><span class="line"><span class="comment">hs 是否包含 count 为 -2 的 R 对象false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="LinkedHashSet-类"><a href="#LinkedHashSet-类" class="headerlink" title="LinkedHashSet 类"></a>LinkedHashSet 类</h3><p>LinkedHashSet 是 HashSet 的子类，同样根据 hashCode 值来决定元素的存储位置。但是使用链表维护元素的次序，使得当遍历 LinkedHashSet 集合里的元素时，LinkedHashSet 会按元素的添加顺序访问集合里的元素。</p><p>LinkedHashSet 需要维护元素的插入顺序，因此性能略低于 HashSet，但在迭代访问 Set 里的全部元素时会有很好的性能，因为它以链表维护内部的顺序。</p><h3 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a>TreeSet 类</h3><p>TreeSet 是 SortedSet 接口的实现类，顾名思义这是一种排序的 Set 集合。</p><p>TreeSet 底层使用 TreeMap 实现，采用红黑树的数据结构来存储集合元素。TreeSet 支持两种排序方法：自然排序和定制排序。默认情况下，使用自然排序。</p><h4 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h4><p>Java 提供了 Comparable 接口，接口定义了一个 compareTo(Object obj) 方法。实现该接口的类必须实现该抽象方法。</p><p>compareTo(Object obj) 比较规则如下：</p><ul><li>obj1.compareTo(obj2) 返回值为 0，表明相等</li><li>obj1.compareTo(obj2) 返回值大于 0，表明 obj1 &gt; obj2</li><li>obj1.compareTo(obj2) 返回值小于 0，表明 obj1 &lt; obj2</li></ul><p>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素大小关系，再将集合元素按升序排序，这就是自然排序。所以自然排序中的元素对象都必须实现了 Comparable 接口。</p><blockquote><p>如果两个对象通过 compareTo(Object obj) 比较相等， 即返回值为0，TreeSet 认为它们相等，那么新对象将无法添加到 TreeSet 集合中。</p></blockquote><blockquote><p>如果希望 TreeSet 能正常工作，TreeSet 只能添加同一种类型的对象。</p></blockquote><h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><p>如果需要实现定制排序，需要在创建 TreeSet 集合对象时，提供一个 Comparator 对象与该 TreeSet 集合关联。Comparator 是一个函数式接口，可以使用 Lambda 表达式代替。</p><p>通过定制排序方式时，依然不可以向 TreeSet 中添加不同类型的对象，否则引发 ClassCastException 异常。此时集合判断两个元素相等的标准是：通过 Comparator 比较两个元素返回了 0， 这样 TreeSet 也不会把第二个元素添加到集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSettest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet((o1, o2) -&gt; &#123;</span><br><span class="line">            M m1 = (M) o1;</span><br><span class="line">            M m2 = (M) o2;</span><br><span class="line">            <span class="keyword">return</span> m1.age &gt; m2.age ? -<span class="number">1</span> : m1.age &lt; m2.age ? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(-<span class="number">3</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用目标类型为 Comparator 的 Lambda 表达式，它负责 ts 集合的排序。所有 M 类无需实现 Comparable 接口，而是由 TreeSet 关联的 Lambda 表达式负责元素的排序。</p><p>在实现 compareTo 方法时，强烈推荐与 equals 结果一致，否则可能会出现一些奇怪的错误。因为有些类是根据 equals 来判断重复性，有些是利用自然排序 x.compareTo(y) == 0 来判断。compareTo 是判断元素在排序中的位置是否相等，equals 是判断元素是否相等，既然一个决定排序位置，一个决定相等，所以我们非常有必要确保当排序位置相同时，其equals也应该相等。</p><h3 id="EnumSet-类"><a href="#EnumSet-类" class="headerlink" title="EnumSet 类"></a>EnumSet 类</h3><p>EnumSet 是专为枚举类设计的集合类，EnumSet 中的所有元素都必须是指定枚举类型的枚举类，该枚举类型在创建 EnumSet 时显式或隐式的的指定。</p><p>EnumSet 的集合元素是有序的，以枚举值在 Enum 类内的定义顺序来决定集合元素的顺序。EnumSet 集合不允许插入 null 元素。</p><p>EnumSet 内部以位向量的形式存储，这种存储形式紧凑高效，占用内存很小，运行效率很高。尤其是在进行批量操作时，比如调用 containsAll 和 retainAll 方法时。</p><h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a>Map 集合</h2><p>定义：Map 用于保存具有映射关系的数据，key 和 value 之间存在单向的一对一关系，key 不允许重复。</p><blockquote><p>Set 与 Map 之间关系非常密切，如果把 key-value 对中的 value 当成 key 的附庸，key 在哪里，value 就在哪里。这样就可以像对待 Set 一样对待 Map 了。</p><p>实际上，Map 提供了一个 Entry 内部类来封装 key-value 对，而计算 Entry 存储时则只考虑 Entry 封装的 key。从源码来看，Java 是先实现了 Map，然后通过包装一个所有 value 都为 null 的 Map 就实现了 Set 集合。</p></blockquote><h3 id="HashMap-实现类"><a href="#HashMap-实现类" class="headerlink" title="HashMap 实现类"></a>HashMap 实现类</h3><p>HashMap 中用作 key 的对象必须实现 hashCode() 方法和 equals() 方法。</p><blockquote><p>HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法比较返回 true，两个 key 的 hashCode 值也相等。</p></blockquote><blockquote><p>HashMap 判断两个 value 相等的标准是：两个对象通过 equals() 方法返回 true 即可。</p></blockquote><p>与 HashSet 类似，当使用自定义类作为 HashMap 的 key 时，如果重写该类的 equals() 方法 和 hashCode() 方法，则应该保证两个方法的判断标准一致，即当两个 key 通过 equals() 方法比较返回 true 时，两个 key 的 hashCode() 方法返回值也应该相同。</p><p>与 HashSet 类似，尽量不要使用可变对象作为 HashMap 的 key，如果使用了，则尽量不要在程序中修改作为 key 的可变对象。</p><h3 id="LinkedHashMap-实现类"><a href="#LinkedHashMap-实现类" class="headerlink" title="LinkedHashMap 实现类"></a>LinkedHashMap 实现类</h3><p>LinkedHashMap 也使用双向链表来维护 key-value 对的次序（其实只需要考虑 key 的次序），该链表负责维护 Map 的迭代顺序，迭代顺序与 key-value 对的插入顺序保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap scores = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">        scores.put(<span class="string">"Chinses"</span>, <span class="number">80</span>);</span><br><span class="line">        scores.put(<span class="string">"English"</span>, <span class="number">82</span>);</span><br><span class="line">        scores.put(<span class="string">"Math"</span>, <span class="number">76</span>);</span><br><span class="line">        scores.forEach((key ,value) -&gt; System.out.println(key + <span class="string">"---&gt;"</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeMap-实现类"><a href="#TreeMap-实现类" class="headerlink" title="TreeMap 实现类"></a>TreeMap 实现类</h3><p>TreeMap 是一个红黑树数据结构，每个 key-value 对即作为红黑树的一个节点。TreeMap 存储 key-value 对节点时，需要根据 key 对节点进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。</p><p>两种排序方式：</p><ul><li>自然排序：TreeMap 的所有 key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的对象，否则会抛出 ClassCastException 异常</li><li>定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。采用定制排序时不要求 Map 的 key 实现 Comparable 接口</li></ul><blockquote><p>TreeMap 判断两个 key 相等的标准是：两个 key 通过 compareTo 方法返回 0。</p></blockquote><p>类似于 TreeSet，如果使用自定义类作为 TreeMap 的 key，为了让 TreeMap 良好的工作，则重写该类的 equals() 方法和 compareTo() 方法时应该保持一致的结果：两个 key 通过 equals 方法比较返回 true 时，它们通过 compareTo 方法比较应该返回 0。</p><p>在实现 compareTo 方法时，强烈推荐与 equals 结果一致，否则可能会出现一些奇怪的错误。因为有些类是根据 equals 来判断重复性，有些是利用自然排序 x.compareTo(y) == 0 来判断。compareTo 是判断元素在排序中的位置是否相等，equals 是判断元素是否相等，既然一个决定排序位置，一个决定相等，所以我们非常有必要确保当排序位置相同时，其equals也应该相等。</p><p>官方文档的说明：</p><blockquote><p>Virtually all Java core classes that implement Comparable have natural orderings that are consistent with equals.</p></blockquote><h3 id="EnumMap-实现类"><a href="#EnumMap-实现类" class="headerlink" title="EnumMap 实现类"></a>EnumMap 实现类</h3><p>EnumMap 的 key 必须是单个枚举类的枚举值。</p><p>EnumMap 具有以下特征：</p><ul><li><p>EnumMap 在内部以数组形式保存</p></li><li><p>EnumMap 根据 key 的自然顺序（即枚举值在枚举类中的定义顺序）来维护 key-value 对的顺序</p></li><li><p>EnumMap 不能使用 null 作为 key 值</p></li></ul><p>创建 EnumMap 时必须指定一个枚举类，从而将该 EnumMap 和指定枚举类相关联。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-异常</title>
      <link href="/2020/04/02/java/ji-chu/yi-chang/"/>
      <url>/2020/04/02/java/ji-chu/yi-chang/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="异常层次"><a href="#异常层次" class="headerlink" title="异常层次"></a>异常层次</h2><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/Exception.png" alt></p><ul><li>Error：Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。</li><li>Exception<ul><li>RuntimeException：由程序错误导致的异常</li><li>其他异常：程序本身没有问题，但由类似 IO 错误导致的异常</li></ul></li></ul><h2 id="Checked-异常-amp-Runtime-异常"><a href="#Checked-异常-amp-Runtime-异常" class="headerlink" title="Checked 异常 &amp; Runtime 异常"></a>Checked 异常 &amp; Runtime 异常</h2><p>Checked 异常：不是 RuntimeException 类及其子类的异常实例</p><p>Runtime 异常：所有 RuntimeException 类及其子类的异常实例</p><blockquote><p>Java 认为 Checked 异常都是可以被处理修复的异常，所以程序必须显示处理 Checked 异常，如果程序没有处理 Checked 异常，编译时会出错。Checked 异常体现了 Java 的设计理念，没有完善错误处理的代码根本不会被执行。</p></blockquote><p>对 Checked 异常处理方式：</p><ul><li><p>当前方法明确知道如何处理该异常，应该使用 try-catch 处理该异常</p></li><li><p>当前方法不知道如何处理该异常，应在定义该方法时声明抛出该异常</p></li></ul><p>对 Runtime 异常的处理方式：</p><ul><li>Runtime 异常无需显式声明抛出，如果程序需要捕获 Runtime 异常，也可以使用 try-catch 块</li></ul><h2 id="throws-声明抛出异常"><a href="#throws-声明抛出异常" class="headerlink" title="throws 声明抛出异常"></a>throws 声明抛出异常</h2><p>如果当前方法不知道如何处理这种类型的异常，该异常应该由上一级调用者处理，如果上一级调用者也不知道如何处理，再抛出直至交由 JVM 处理。</p><p>throws 声明抛出只能在方法声明中使用，可以声明抛出多个异常类。一旦使用 throws 语句声明抛出该异常，程序就无需使用 try-catch 来捕获异常了。</p><p>示例：下面程序声明不处理 IOException 异常，而是将该异常交由 JVM 处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某段代码中调用了一个带 throws 声明的方法，该方法声明抛出了 Checked 异常，则表明该方法希望它的调用者来处理该异常。那么调用者在调用该方法时，要么将其放入 try 块中并显示捕获该异常，要么放在另一个带 throws 声明抛出的方法中。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* 因为 FileInputStream 的构造器声明抛出 IOException 异常</span></span><br><span class="line"><span class="comment">           所以调用 test() 方法 的代码要么处于 try-catch 块中</span></span><br><span class="line"><span class="comment">           要么处于另一个带 throws 声明抛出的方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/* 因为 test() 方法声明抛出 IOException 异常</span></span><br><span class="line"><span class="comment">           所以调用该方法的代码要么处于 try-catch 块中</span></span><br><span class="line"><span class="comment">           要么处于另一个带 throws 声明抛出的方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主动抛出异常-throw"><a href="#主动抛出异常-throw" class="headerlink" title="主动抛出异常 throw"></a>主动抛出异常 throw</h2><p>如果 throw 语句抛出的异常是 Checked 异常，则该 throw 语句要么处于 try 块里，显式捕获该异常，要么放在一个带 throws 声明抛出的方法中；如果 throw 语句抛出的是 Runtime 异常，则无需放在 try 块里，也无需放在带 throws 声明抛出的方法中，既可以显式的用 try-catch 来捕获并处理异常，也可以完全不理会该异常，把该异常交给该方法调用者处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">throwChecked</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 自行抛出 Exception 异常</span></span><br><span class="line">            <span class="comment">// 该代码必须处于 try 块里，或处于带 throws 声明的方法中</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"a的值大于0，不符合要求"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">throwRuntime</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 自行抛出 RuntimeException 异常</span></span><br><span class="line">            <span class="comment">// 既可以捕获该异常，也可以完全不理会该异常，把异常交给方法调用者处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"a的值大于0，不符合要求"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用声明抛出 Checked 异常的方法，要么显式在 try-catch 中捕获该异常，要么在 main 方法中再次声明抛出</span></span><br><span class="line">            throwChecked(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.print(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用声明抛出 Runtime 异常的方法既可以显式捕获该异常，也可以不理会该异常</span></span><br><span class="line">        throwRuntime(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuctionException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuctionException</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 带一个字符串参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuctionException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h2><p>将原始信息隐藏起来，仅向上提供必要的异常提示信息的处理方式，可以保证底层异常不会扩散到表现层，避免向上暴露太多的细节，符合面向对象的封装原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">calSal</span><span class="params">()</span> <span class="keyword">throws</span> SalException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实现结算工资的业务逻辑</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        <span class="comment">// 将原始异常记录下来，留给管理员</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 下面异常中的 message 就是给用户的提示</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SalException(<span class="string">"访问数据库异常“);</span></span><br><span class="line"><span class="string">    &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="string">        // 将原始异常记录下来，留给管理员</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">        // 下面异常中的 message 就是给用户的提示</span></span><br><span class="line"><span class="string">        throw new SalException("</span>系统出现未知异常“);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-匿名内部类</title>
      <link href="/2020/04/02/java/ji-chu/ni-ming-nei-bu-lei/"/>
      <url>/2020/04/02/java/ji-chu/ni-ming-nei-bu-lei/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>匿名内部类适合创建只需要一次使用的类，创建匿名内部类时会立即创建一个该类的实例，这个类定义立即消失，匿名类不能重复使用。</p><p>匿名类是用来创建接口或者抽象类的实例的。</p><p>匿名内部类不能定义构造器。因为匿名内部类没有类名，所有无法定义构造器。但匿名内部类可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。</p><p>定义匿名内部类格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 实现接口 | 抽象父类构造器(实参列表)</span><br><span class="line">&#123;</span><br><span class="line">    匿名内部类的类体部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的创建匿名内部类的方式是需要创建某个接口类型的对象，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ProductA p)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Buy a"</span> + p.getName() + <span class="string">"Cost "</span> + p.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnonymousTest ta = <span class="keyword">new</span> AnonymousTest();</span><br><span class="line">        <span class="comment">// 调用 test() 方法时，需要传入一个 Product 参数</span></span><br><span class="line">        <span class="comment">// 此处传入其匿名实现类的实例</span></span><br><span class="line">        ta.test(<span class="keyword">new</span> ProductA() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">567.8</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"APG Card"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过继承抽象父类来创建匿名内部类时，匿名内部类将拥有和父类相同形参列表的构造器。看下面一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Device</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Device</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Device d)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Buy a"</span> + d.getName()+ <span class="string">"Cost"</span> + d.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnonymousInner ai = <span class="keyword">new</span> AnonymousInner();</span><br><span class="line">        <span class="comment">// 调用有参数的构造器创建 Device 匿名实现类的对象</span></span><br><span class="line">        ai.test(<span class="keyword">new</span> Device(<span class="string">"电子显示器"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">67.8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用无参数的构造器创建 Device 匿名实现类的对象</span></span><br><span class="line">        Device d = <span class="keyword">new</span> Device() &#123;</span><br><span class="line">            <span class="comment">// 初始化块</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类的初始化块"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 实现抽象方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">56.2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重写父类的实例方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"keyboard"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ai.test(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-内部类</title>
      <link href="/2020/04/02/java/ji-chu/nei-bu-lei/"/>
      <url>/2020/04/02/java/ji-chu/nei-bu-lei/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cow</span><span class="params">(<span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个非静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CowLeg</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> length;</span><br><span class="line">        <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CowLeg</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CowLeg</span><span class="params">(<span class="keyword">double</span> length, String color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">double</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"当前牛腿的颜色是 "</span> + <span class="keyword">this</span>.color + <span class="string">", 长 "</span> + <span class="keyword">this</span>.length);</span><br><span class="line">            <span class="comment">// 直接访问外部类的 private 修饰的成员变量</span></span><br><span class="line">            System.out.println(<span class="string">"该牛腿所属的奶牛重: "</span> + weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CowLeg cl = <span class="keyword">new</span> CowLeg(<span class="number">1.12</span>, <span class="string">"黑白相间"</span>);</span><br><span class="line">        cl.info();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cow cow = <span class="keyword">new</span> Cow(<span class="number">378.9</span>);</span><br><span class="line">        cow.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非静态内部类里可以直接访问外部类的 private 成员，这是因为在非静态内部类对象里，保存了一个它所寄生的外部类对象的引用。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200402104437.png" alt></p><p>如果外部类成员变量、内部类成员变量与内部类里方法的局部变量名同名</p><ul><li><p>直接访问局部变量</p></li><li><p>this，访问内部类实例的变量</p></li><li><p>外部类类名.this.varName 访问外部类实例变量</p></li></ul><p>外部类不能直接访问非静态内部类的成员，无论非静态内部类的成员是什么修饰符修饰的。只能显示创建非静态内部类对象来访问其实例成员。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>如果用 static 修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此也叫做类内部类。即静态内部类是外部类的一个静态成员。</p><p>静态内部类可以包含静态成员，也可以包含非静态成员。</p><p>静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。</p><p>外部类依然不能直接访问静态内部类的成员，但可以使用静态内部类的类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类对象作为调用者来访问静态内部类的实例成员。</p><hr><blockquote><p>在外部类以外的地方访问内部类（包括静态和非静态两种），则内部类不能使用 private 修饰，private 修饰的内部类只能在外部类内部使用。对于使用其他访问修饰符的内部类，按照访问修饰符范围访问。</p></blockquote><h2 id="在外部类之外使用非静态内部类"><a href="#在外部类之外使用非静态内部类" class="headerlink" title="在外部类之外使用非静态内部类"></a>在外部类之外使用非静态内部类</h2><p>由于非静态内部类的对象必须寄生在外部类的对象里，因此在创建非静态内部类对象之前，必须先创建其外部类对象。</p><p>示例代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用默认访问控制符，同一个包中的其他类可以访问该内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">In</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">In</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateInnerInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Out.In in = <span class="keyword">new</span> Out().new In(<span class="string">"Test Msg"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        上面代码可以改为如下三行代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        使用 OutterClass.InnerClass 的形式定义内部类变量</span></span><br><span class="line"><span class="comment">        Out.In in;</span></span><br><span class="line"><span class="comment">        创建外部类实例，非静态内部类实例将寄生在该实例中</span></span><br><span class="line"><span class="comment">        Out out = new Out();</span></span><br><span class="line"><span class="comment">        通过外部类实例和new来调用内部类构造器创建非静态内部类实例</span></span><br><span class="line"><span class="comment">        in = out.new In("Test Msg");</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面定义了一个子类继承了 Out 类的非静态内部类 In 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">Out</span>.<span class="title">In</span></span>&#123;</span><br><span class="line">    <span class="comment">// 显示定义 SubClass 的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">(Out out)</span></span>&#123;</span><br><span class="line">        out.<span class="keyword">super</span>(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可能看起来很怪，其实很正常：非静态内部类 In 类的构造器必须使用外部类对象来调用，代码中 super 代表调用 In 类的构造器，而 out 则代表外部类对象。</p><p>如果需要创建 SubClass 对象时，必须创建一个 Out 对象。因为 SubClass 是非静态内部类 In 的子类，非静态内部类 In 对象里必须有一个对 Out 对象的引用，其子类 SubClass 对象里也应该持有对 Out 对象的引用。当创建 SubClass 对象时传给该构造器的 Out 对象，就是 SubClass 对象里 Out 对应引用所指向的对象。</p><p>结合上面两段代码，非静态内部类 In 对象和 SubClass 对象都必须持有指向 Outer 对象的引用，区别是创建两种对象时传入 Out 对象的方式不同：当创建非静态内部类 In 类的对象时，必须通过 Outer 对象来调用 new 关键字；当创建 SubClass 类的对象时，必须使用 Outer 对象作为调用者来调用 In 类的构造器</p><h2 id="在外部类之外使用静态内部类"><a href="#在外部类之外使用静态内部类" class="headerlink" title="在外部类之外使用静态内部类"></a>在外部类之外使用静态内部类</h2><p>因为静态内部类是外部类类相关的，因此创建静态内部类对象时无需创建外部类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateStaticInnerInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticOut.StaticIn in = <span class="keyword">new</span> StaticOut.StaticIn();</span><br><span class="line">        <span class="comment">/* 上面的代码可改为如下两行代码</span></span><br><span class="line"><span class="comment">        使用 OuterClass.InnerClass 的形式定义内部类变量</span></span><br><span class="line"><span class="comment">        StaticOut.StaticIn in;</span></span><br><span class="line"><span class="comment">        通过 new 调用内部类构造器创建静态内部类实例</span></span><br><span class="line"><span class="comment">        in = new StaticOut.StaticIn();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为调用静态内部类的构造器时不需要使用外部类对象，所以创建静态内部类的子类也比较简单。下面代码为静态静态内部类 StaticIn 定义了一个空的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSubClass</span> <span class="keyword">extends</span> <span class="title">StaticOut</span>.<span class="title">StaticIn</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-抽象类</title>
      <link href="/2020/04/02/java/ji-chu/chou-xiang-lei/"/>
      <url>/2020/04/02/java/ji-chu/chou-xiang-lei/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>抽象类是模板模式的设计模式体现。抽象类是从多个具体类中抽象出来的父类，具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类为其子类的模板，避免子类设计的随意性</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>抽象类使用 abstract 修饰。</p></li><li><p>抽象类可以和普通类一样可以包含成员变量、方法、构造器、初始化块、内部类。但抽象类不能被实例化，抽象类的构造器主要用来被子类调用。</p></li><li><p>抽象类可以不包含抽象方法，但是含有抽象方法的类必须被定义为抽象类。</p></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-接口</title>
      <link href="/2020/04/02/java/ji-chu/jie-kou/"/>
      <url>/2020/04/02/java/ji-chu/jie-kou/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li><p>接口体现的是规范和实现分离的设计哲学，让软件系统的各组件之间面向接口耦合，是一种松耦合的设计。</p></li><li><p>接口定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，意味着接口通常是定义一组公共方法。</p></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><p>接口的修饰符，只能是 public 或者 default。</p></li><li><p>由于接口定义的是一种规范，所以接口里不能包含构造器和初始化块定义，只能包含静态常量、方法（只能是抽象方法，类方法和默认方法）以及内部类、内部接口、内部枚举。</p></li><li><p>接口里的常量只能是静态常量，默认使用 public static final 修饰。</p></li><li><p>接口里的内部类、内部接口、内部枚举，默认使用 public static 修饰。</p></li><li><p>接口里的抽象方法不能有方法体，但类方法和默认方法必须有方法体。</p></li></ul><h2 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h2><p>接口中定义抽象方法可以省略 abstract 关键字和修饰符，默认修饰符为 public。</p><p>Java 8 新增允许在接口中定义默认方法，使用 default 修饰。默认情况下，系统使用 public 修饰默认方法。</p><p>Java 8 新增允许在接口中定义私有方法。</p><p>Java 8 新增允许在接口中定义静态方法。静态方法可以被实现的接口的类继承。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一个类可以实现一个或多个接口。</p><p>一个类实现一个或多个接口，这个类必须重写所实现的接口中的所有抽象方法。否则，该类必须被定义成抽象类，保留从父接口继承到的抽象方法。</p><p>接口不能用来创建实例，但是可以用于声明引用类型的变量，该变量必须指向实现该接口的类的实例对象。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-Object 类</title>
      <link href="/2020/04/02/java/ji-chu/object-lei/"/>
      <url>/2020/04/02/java/ji-chu/object-lei/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>Object 类是所有类的父类。</p><p>下面介绍几个 Object 类中常用的方法。</p><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>toString 用于输出对象的自我描述信息。</p><p>Object 类提供的 toString 返回该对象实现类的 “类名 + @ + hashCode”。</p><p>通常需要重写该方法。</p><h2><a href="#" class="headerlink" title="=="></a>==</h2><p>对于基本数据类型的变量，只要两个变量的值相等（不需要数据类型完全相同），就返回 true。</p><p>对于两个引用类型的变量，只有它们指向同一个对象时，== 判断才会返回 true。</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>对于引用变量，只有指向同一个对象时才返回 true。</p><p>当仅需要判断值相等时，一般需要重写 equals 方法。</p><p>重写 equals 方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj !=<span class="keyword">null</span> &amp;&amp; obj.getClass() == Person.class) &#123;</span><br><span class="line">        Person personObj = (Person)obj;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getIdStr().equals(personObj.getIdStr())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果equals 为 true，那么也需要重写 hashcode 方法，以保证 hashCode() 返回值相等，这是一种<strong>约定俗称</strong>的规范。即 equals 为 true 是 hashCode 相等的充分非必要条件。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML 图示</title>
      <link href="/2020/03/26/java/ji-chu/uml-tu-shi/"/>
      <url>/2020/03/26/java/ji-chu/uml-tu-shi/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>UML 是分析程序和理解程序间的调用关系时，不可多得的利器。</p><p>这里简单介绍几种程序开发中经常使用的 UML 视图，并辅以真实的 Java 案例。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>UML 中的类图表示用于表示类、接口、实例之间的静态关系。</p><h3 id="类的层次关系"><a href="#类的层次关系" class="headerlink" title="类的层次关系"></a>类的层次关系</h3><p>展示类的层次关系，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200326094046.png" alt></p><h3 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h3><p>展示接口与实现类的关系，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200326094335.png" alt></p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>只要在一个类中持有另一个类的实例，无论是单个还是多个，这种持有关系就称之为聚合。</p><p>展示聚合关系，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200326094652.png" alt></p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>类的属性和方法的可见性（访问控制），如下图</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200326094839.png" alt></p><h3 id="类的关联"><a href="#类的关联" class="headerlink" title="类的关联"></a>类的关联</h3><p>类之间的关联关系，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200326095003.png" alt></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>类图表示的静态关系不随时间流逝而变化，而时序图恰好相反，随着时间流逝而发生变化的关系。</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/uml.png" alt></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-多态</title>
      <link href="/2020/03/17/java/ji-chu/duo-tai/"/>
      <url>/2020/03/17/java/ji-chu/duo-tai/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>Java 引用变量有两个类型。如果编译时类型和运行时类型不一致，就可能出现多态。</p><ul><li><p>编译时类型：由声明该变量时使用的类型决定</p></li><li><p>运行时类型：由实际运行时赋给该变量的对象决定</p></li></ul><h3 id="向上类型转换"><a href="#向上类型转换" class="headerlink" title="向上类型转换"></a>向上类型转换</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> book = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的test方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String book = <span class="string">"轻量级 Java EE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类的test方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类的sub方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseClass ploymophicBc = <span class="keyword">new</span> SubClass();</span><br><span class="line">        System.out.println(ploymophicBc.book);</span><br><span class="line">        ploymophicBc.base();</span><br><span class="line">        ploymophicBc.test();</span><br><span class="line">        <span class="comment">// 因为 ploymophicBc 的编译时类型是 BaseClass</span></span><br><span class="line">        <span class="comment">// BaseClass 类没有提供 sub 方法，所以下面代码编译时会出错</span></span><br><span class="line">        <span class="comment">// ploymophicBc.sub();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，引用变量 ploymophicBc 比较特殊，它的编译时类型是 BaseClass，而运行时类型是 SubClass。</p><p>ploymophicBc.sub() 这行代码会在编译时报错，因为 ploymophicBc 编译时类型为 BaseClass，而 BaseClass 中没有定义 sub 方法，因此编译时无法通过。</p><p>但是注意，ploymophicBc.book 的值为 6， 而不是 ”轻量级 Java EE“。因为<strong>对象的实例变量不具备多态性</strong>，系统总是试图访问它编译时类型所定义的成员变量，而非运行时。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>子类其实是一种特殊的父类，因此 java 允许把父类的引用指向子类对象，这被称为向上转型（upcasting），向上转型由系统自动完成。</p><p>可以调用哪些方法，取决于引用类型（编译时）。</p><p>具体调用哪个方法，取决于引用指向的实例对象（运行时）。</p><h3 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h3><p>问题：引用变量在代码编译过程中，只能调用它编译时类型具备的方法，而不能调用它运行时类型具备的方法</p><p>解决：强制转换成运行时类型</p><p>方法：引用类型之间的转换只能在有继承关系的两个类型之间进行，否则编译出错。如果想把一个父类引用变量的编译时类型转换成子类类型，则这个引用变量的运行时类型得是子类类型，否则引发 ClassCastException 异常</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子类对象</span></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上类型转换(类型自动提升),不存在风险</span></span><br><span class="line"><span class="comment">// 此时 animal 为 Dog 类型</span></span><br><span class="line">Animal animal = dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 风险演示：编译阶段不会报错，但是运行时会报错</span></span><br><span class="line"><span class="comment">// 根据上面的语句，此时 animal 指向 Dog 类型对象，没有办法转化成 Cat 对象。</span></span><br><span class="line">Cat cat = (Cat)animal; <span class="comment">// 1.强转成功，编译时按 Cat 类型  2. 但运行时 Dog 类型，类型不匹配，直接报错</span></span><br></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>为了解决强制类型转换，可能引发的 ClassCastException 异常，引入 instanceof 运算符。</p><p>instanceof 运算符的含义：用于判断左边的对象（运行时类型）是否是右边的类或者其子类、实现类的实例。如果是返回 true，否则返回 false。</p><p>在之前的代码中，强制类型转换前使用 instanceof 判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (anmial <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">    Cat cat = (Cat)animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-方法传参</title>
      <link href="/2020/03/17/java/ji-chu/fang-fa-chuan-can/"/>
      <url>/2020/03/17/java/ji-chu/fang-fa-chuan-can/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><blockquote><p>无论是基本类型的值传递，还是引用类型的参数传递，在 Java 中方法总是采用<strong>按值调用</strong>。对于引用类型，传递的是其对应的内存空间地址。</p></blockquote><h3 id="基本类型的值传递"><a href="#基本类型的值传递" class="headerlink" title="基本类型的值传递"></a>基本类型的值传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveTransferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">        System.out.println(<span class="string">"swap 方法里 a 的值为: "</span> + a + <span class="string">" b的值为: "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">9</span>;</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"交换结束后 a 的值为 "</span> + a + <span class="string">" b的值为 "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">swap 方法里 a 的值为: 9 b的值为: 6</span></span><br><span class="line"><span class="comment">交换结束后 a 的值为 6 b的值为 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>分析图：</p><p>main 方法中定义了a、b 变量存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317093701.png" alt></p><p>main 方法中的变量作为参数值传入 swap() 方法存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317093735.png" alt></p><p>swap 方法中 a、b 交换后的存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/1.png" alt></p><p>java 程序总是从 main() 方法开始执行，main() 方法定义了 a、b 两个局部变量，两个变量在 main 栈区中。在 main() 方法中调用 swap() 方法时，main() 方法此时还未结束，因此系统为 main 方法和 swap 方法分配了两块栈区，用于保存 main 方法和 swap 方法的局部变量。main 方法中的 a、b 变量作为参数传入 swap 方法，实际上是在 swap 方法栈区中重新产生了两个变量 a、b，并将 main 方法栈区中 a、b 变量的值分别赋给 swap 方法栈区中的 a、b 参数（这就是初始化）。此时系统内存中有两个 a 变量、两个 b 变量，只是存在于不同的方法栈区中而已。</p><h3 id="引用类型的参数传递"><a href="#引用类型的参数传递" class="headerlink" title="引用类型的参数传递"></a>引用类型的参数传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceTransferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(DataWrap dw)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = dw.a;</span><br><span class="line">        dw.a = dw.b;</span><br><span class="line">        dw.b = tmp;</span><br><span class="line">        System.out.println(<span class="string">"swap 方法里， a 成员变量的的值为: "</span> + dw.a + <span class="string">" b 成员变量的值为: "</span> + dw.b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataWrap dw = <span class="keyword">new</span> DataWrap();</span><br><span class="line">        dw.a = <span class="number">6</span>;</span><br><span class="line">        dw.b = <span class="number">9</span>;</span><br><span class="line">        swap(dw);</span><br><span class="line">        System.out.println(<span class="string">"交换结束后， a 成员变量的的值为: "</span> + dw.a + <span class="string">" b 成员变量的值为: "</span> + dw.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">swap 方法里， a 成员变量的的值为: 9 b 成员变量的值为: 6</span></span><br><span class="line"><span class="comment">交换结束后， a 成员变量的的值为: 9 b 成员变量的值为: 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>你可能会疑问，dw 对象的成员变量 a、b的值也被替换了，这跟前面基本类型的传递完全不一样。这非常容易让人觉得，调用传入 swap 方法的就是 dw 对象本身，而不是它的复制品。其实传递的依然是 dw 的值。</p><p>分析图：</p><p>main 方法中创建 DataWrap 对象后的存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317094351.png" alt></p><p>main 方法中 dw 传入 swap() 方法后的存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317094417.png" alt></p><p>系统一样赋值了 dw 的副本，只是关键在于 dw 只是一个引用变量，它存储的值只是一段内存地址，将该内存地址传递给 swap 栈区，此时 swap 栈区的 dw 和 main 栈区的 dw 的值也就是内存地址相同，该段内存地址指向堆内存中的 DataWrap 对象。对 swap 栈区的 dw 操作，也就是对 DataWrap 对象操作。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-数组</title>
      <link href="/2020/03/15/java/ji-chu/shu-zu/"/>
      <url>/2020/03/15/java/ji-chu/shu-zu/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><p>数组是用来存储固定大小的同类型元素。一旦数组初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度不可以改变。即使某个数组的元素被清空，但是它所占的空间依然保留。</p><p>数组本身也是一种引用类型，既可以存储基本数据类型，也可以存储引用类型，只要存储的数组元素具有相同的类型即可。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><p>执行动态初始化时，系统会根据声明的数组类型自动为数组元素分配初始值。如果是引用类型，则数组元素的初始值为 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] scores = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p>显式指定每个元素的初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] scores = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>foreach 遍历数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] scores = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> score : scores) &#123;</span><br><span class="line">    System.out.println(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h2><p>将数组看成两个部分，一个部分是数组引用，也就是在代码中定义的数组引用变量；另一部分是实际的数组对象，这部分是在堆内存中运行的，通常无法直接访问它，只能通过引用变量来访问。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组本质上还是一维数组，只是其数组元素也是引用，数组元素里保存的引用指向一维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [][] str1 = &#123;<span class="keyword">new</span> String[<span class="number">3</span>], <span class="keyword">new</span> String[]&#123;<span class="string">"hello"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>代码示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200315143323.png" alt></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-控制结构</title>
      <link href="/2020/03/15/java/ji-chu/kong-zhi-jie-gou/"/>
      <url>/2020/03/15/java/ji-chu/kong-zhi-jie-gou/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">   statement;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        statement1;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        statement2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> valuen:</span><br><span class="line">        statementn;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        默认执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 switch 后表达式的值和 case 语句后的值相同时，从该位置向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。</p><ul><li><p>case 后面的值可以是常量数值，也可以是一个常量表达式，但不能是变量或带有变量的表达式</p></li><li><p>可以把功能相同的 case 语句合并起来</p></li><li><p>default 块可以出现在任意位置，也可以省略</p></li></ul><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环变量初始化; 循环条件; 循环变量变化) &#123;</span><br><span class="line">    statement；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-数据类型</title>
      <link href="/2020/03/15/java/ji-chu/shu-ju-lei-xing/"/>
      <url>/2020/03/15/java/ji-chu/shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>基本数据类型变量存储的是数据本身</li><li>引用类型变量存储的是数据的空间地址</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，系统将会进行自动类型转换（隐式转换），否则需要强制转换。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换可能存在溢出导致数据精度丢失的情况。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Java 没有内置的字符串类型，而是提供了一个标准类库 String。</p><p>特征：不可变字符串</p><p>优点：编译器可以让字符串共享（只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的）</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS 读写流程</title>
      <link href="/2019/09/09/bigdata/hdfs/hdfs-du-xie-liu-cheng/"/>
      <url>/2019/09/09/bigdata/hdfs/hdfs-du-xie-liu-cheng/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="HDFS-文件读取流程"><a href="#HDFS-文件读取流程" class="headerlink" title="HDFS 文件读取流程"></a>HDFS 文件读取流程</h2><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200314185440.png" alt></p><p>Client 端调用 DistributedFileSystem 对象的 open() 方法。</p><p>由 DistributedFileSystem 通过 RPC 向 NameNode 请求返回文件的 Block 块所在的 DataNode 的地址。（我们知道 HDFS 默认策略对某个 Block 会保存三份副本到不同的 DataNode，那么 NameNode 应该返回哪个 DataNode？答案是根据 DataNode 到 Client 端的距离。假设请求的 Block 块刚好就落在 Client 端所在机器上，即 Client 端本身也是 DataNode，那么毫无疑问 DataNode 将会返回 Client 端所在机器地址。这也验证了 Hadoop 的一个设计特性，移动计算而不是移动数据，极大了减小了带宽。）</p><p>Client 端调用 FSDataInputStream 对象的 read() 方法，通过 FSDataInputStream 向 DataNode 获取 Block 数据。之后数据流源源不断地从 DataNode 返回至 Client。当最后一个 Block 返回至 Client 端后， DFSInputStream 会关闭与 DataNode 连接。上述过程对 Client 端都是透明的，从 Client 来看，它只是在不停的读取数据流。</p><p>如果 DFSInputStream 在读取的过程中发生了错误，将会尝试与存有该 Block 副本且距离最近的 DataNode 通信。同时，它会记录下出问题的 DataNode，在之后的数据请求过程中不再与之通信。并报告给 NameNode。DFSInputStream 具备检查数据校验和的功能。</p><h2 id="HDFS-文件写入流程"><a href="#HDFS-文件写入流程" class="headerlink" title="HDFS 文件写入流程"></a>HDFS 文件写入流程</h2><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200314185557.png" alt></p><p>Client 写入文件时，调用 DistributedFileSystem 对象的 create() 方法。</p><p>DistributedFileSystem 通过 RPC 请求 NameNode 向其 NameSpace 写入文件元数据信息。NameNode 会做多种检查，如判断文件是否存在，是否有相应的写权限等等。如果检查通过，NameNode 会将文件元数据写入 NameSpace。DistributedFileSystem 将会返回 FSDataOutputStream 用于 Client 端直接向 DataNode 写入数据。</p><p>DFSOutputStream 将 Client 要写入的数据分割成 Packets。Packets 会被保存到 Data Queue 队列中，并由 DataStreamer 消费处理。DataStreamer 请求 NameNode 分配 DataNode 列表，将 Packets 写入到 DataNode 中。假设放置副本的默认策略是 3，那么 NameNode 将返回 3 个 DataNode，并串联起来组成一条 Pipeline。 DataStreamer 将 Packets 写入到第一个 DataNode1，DataNode1 存储完后直接转发至 DataNode2，DataNode2 存储完后再直接转发至 DataNode3。（注意，这里直接是 DataNode1 直接将 Packet 转发至 DataNode2。）</p><p>DFSOutputStream 为了防止出问题时数据的丢失，维持了一个等待 DataNode 成功写入的 ACK Queue。只有当 Packet 被成功写入 Pipeline 中的每个 DataNode 时，此 Packet 才会从 ACK Queue 中移除。</p><p>在 Pipeline 写入的过程中，如果某个 DataNode 出现问题，Pipeline 首先将会被关闭，随后在 ACK Queue 中的 Packets 会被添加到 Data Queue 的最前面，用来防止位于问题节点下游的 DataNode 写入时的数据丢失。出问题的 DataNode 会被从 Pipeline 中移除。NameNode 会重新分配一个健康的 DataNode 构成新的 Pipeline。</p><p>当 Client 端写完数据，调用 DFSOutputStream 对象的 close() 方法。该操作将会将所有剩余的 Packets 刷写到 DataNode Pipeline 并等待返回确认，之后向 NameNode 发送文件写入完成信号。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CM &amp; CDH 基本介绍</title>
      <link href="/2019/08/17/bigdata/cdh/cm-cdh-ji-ben-jie-shao/"/>
      <url>/2019/08/17/bigdata/cdh/cm-cdh-ji-ben-jie-shao/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Feb 23 2021 17:24:43 GMT+0800 (CST) --><h2 id="什么是-CDH"><a href="#什么是-CDH" class="headerlink" title="什么是 CDH"></a>什么是 CDH</h2><p>Hadoop 是开源项目，所以很多公司在这个基础上进行商业化，不收费的 Hadoop 主要有三个：</p><ul><li><p>Apache，最原始的版本，所有发行版均基于这个版本进行</p></li><li><p>Cloudear，全称 Cloudera’s Distribution Including Apache Hadoop，简称 CDH</p></li><li><p>Hortonworks，全称 Hortonworks Data Platform，简称 HDP</p></li></ul><h2 id="什么是-Cloudera-Manager"><a href="#什么是-Cloudera-Manager" class="headerlink" title="什么是 Cloudera Manager"></a>什么是 Cloudera Manager</h2><p>Cloudear Manager，简称 CM，用于管理 CDH 集群，其主要功能是对 CDH 集群进行监控，大大改善原生 Apache Hadoop 的安装、配置复杂度和需要使用第三方开源监控工具所带来的诸多问题，可进行节点安装、配置、诊断、集成并提供 web 界面。</p><h2 id="CM-架构"><a href="#CM-架构" class="headerlink" title="CM 架构"></a>CM 架构</h2><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200314185027.png" alt></p><p>基本组成：</p><ul><li><p>Server</p></li><li><p>Agent：安装在每个集群节点上，Server 下发的操作都由 Agent 来实现</p></li><li><p>Management Service：监控报警等功能</p></li><li><p>Database：存储各种服务配置信息和报警信息</p></li><li><p>Cloudera Repoistory：用来分发 Parcels 包的远程仓库</p></li><li><p>Clients</p></li></ul><p>Server 和 Agent 通信方式：默认情况下，Agent 每隔 15s 向 Server 发送心跳。但是当状态发生变化时，为了减少用户等待时间，会加快心跳频率。</p><h2 id="CM-术语"><a href="#CM-术语" class="headerlink" title="CM 术语"></a>CM 术语</h2><ul><li><p>host 主机</p></li><li><p>rack 机架</p></li><li><p>cluster 集群</p></li><li><p>service 服务，例如 HDFS、YARN 都是一个个服务</p></li><li><p>role 角色，例如 HDFS 的 NameNode 和 DataNode 都可以称为 HDFS 的 角色</p></li><li><p>role group 角色组，将角色划分为一组方便管理</p></li><li><p>host template 主机模板</p></li><li><p>parcel 包</p></li><li><p>static service pool 静态服务池</p></li><li><p>dynamic resource pool 动态资源池</p></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDH </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

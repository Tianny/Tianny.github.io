<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Scala入门-break &amp; continue</title>
      <link href="/2020/03/18/scala/ji-chu/break-continue/"/>
      <url>/2020/03/18/scala/ji-chu/break-continue/</url>
      
        <content type="html"><![CDATA[<p>Scala 推荐使用函数式的风格解决 break 和 continue 的功能，而不是像 Java 一样提供关键字功能。</p><h2 id="Break-实现"><a href="#Break-实现" class="headerlink" title="Break 实现"></a>Break 实现</h2><p>将整个循环的逻辑放在 breakable 方法中，在需要真正跳出循环的时候使用 break 方法，这样达到了跳出整个循环的目的。</p><pre class=" language-scala"><code class="language-scala"><span class="token keyword">import</span> scala<span class="token punctuation">.</span>util<span class="token punctuation">.</span>control<span class="token punctuation">.</span>Breaks<span class="token punctuation">.</span>_<span class="token keyword">object</span> BreakDemo <span class="token punctuation">{</span>  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    breakable <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          break<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>          println<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面输出结果为 1。</p><h2 id="Continue-实现"><a href="#Continue-实现" class="headerlink" title="Continue 实现"></a>Continue 实现</h2><p>将 breakable 放在循环内，这样可以实现结束本次循环的目的而不是结束整个循环。</p><pre class=" language-scala"><code class="language-scala"><span class="token keyword">import</span> scala<span class="token punctuation">.</span>util<span class="token punctuation">.</span>control<span class="token punctuation">.</span>Breaks<span class="token punctuation">.</span>_<span class="token keyword">object</span> ContinueDemo <span class="token punctuation">{</span>  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      breakable <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          break        <span class="token punctuation">}</span>        println<span class="token punctuation">(</span>i<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面输出结果为 1 2 4。</p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala入门-数据类型</title>
      <link href="/2020/03/17/scala/ji-chu/shu-ju-lei-xing/"/>
      <url>/2020/03/17/scala/ji-chu/shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>Scala 中数据类型都是对象，没有 Java 中的原生类型。</p><p>Scala 中数据类型主要分为两类，AnyVal 值类型和 AnyRef 引用类型。</p><h2 id="AnyVal"><a href="#AnyVal" class="headerlink" title="AnyVal"></a>AnyVal</h2><p>包括常见的 Byte、Short、Int、Long、Double、Float、Char、Boolen、String、Unit。</p><p>Unit，等同于 Java 中的 void 类型。</p><h2 id="AnyRef"><a href="#AnyRef" class="headerlink" title="AnyRef"></a>AnyRef</h2><p>所有引用类型的基类。</p><h2 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h2><ol><li>Any：所有类的超类</li><li>Null：所有 AnyRef 类型的子类</li><li>Nothing：所有类的子类</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317145428.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala入门-变量</title>
      <link href="/2020/03/17/scala/ji-chu/bian-liang/"/>
      <url>/2020/03/17/scala/ji-chu/bian-liang/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>val | var 变量名 [: 变量类型] = 变量值</code></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Scala 声明时变量名在前，变量类型在后。与 Java 相反。</p><p>声明变量时，变量类型可省略（编译器可自动推导）。</p><h2 id="关键字-val"><a href="#关键字-val" class="headerlink" title="关键字 val"></a>关键字 val</h2><p>val 不可修改。</p><p>本质：反编译后，变量会加上 final 修饰。</p><h2 id="关键字-var"><a href="#关键字-var" class="headerlink" title="关键字 var"></a>关键字 var</h2><p>可修改。</p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala入门-控制结构</title>
      <link href="/2020/03/17/scala/ji-chu/kong-zhi-jie-gou/"/>
      <url>/2020/03/17/scala/ji-chu/kong-zhi-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>Scala 控制结构与 Java 类似，除了 For 循环结构比较特殊。</p><p>下面详细介绍 For 循环的常见使用方法。</p><h3 id="前后闭合"><a href="#前后闭合" class="headerlink" title="前后闭合"></a>前后闭合</h3><pre class=" language-scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  println<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="前闭后开"><a href="#前闭后开" class="headerlink" title="前闭后开"></a>前闭后开</h3><pre class=" language-scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> until <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  println<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="循环守卫"><a href="#循环守卫" class="headerlink" title="循环守卫"></a>循环守卫</h3><p>如果表达式为真，进入循环体，否则跳过，类似于 <strong>continue</strong>。</p><pre class=" language-scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span> <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  println<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>等价于</p><pre class=" language-scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    println<span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="引入变量"><a href="#引入变量" class="headerlink" title="引入变量"></a>引入变量</h3><pre class=" language-scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">;</span> j <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  println<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>等价于</p><pre class=" language-scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">val</span> j <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">-</span> i  println<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><pre class=" language-scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">;</span> j <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  println<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>等价于</p><pre class=" language-scala"><code class="language-scala"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    println<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="循环返回值"><a href="#循环返回值" class="headerlink" title="循环返回值"></a>循环返回值</h3><p>将遍历过程中处理的结果返回到一个新的 Vector 集合中。使用 yield 关键字。yield 后面也可跟代码块。</p><pre class=" language-scala"><code class="language-scala"><span class="token keyword">val</span> res <span class="token operator">=</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> to <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">yield</span> i</code></pre>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala入门-IDEA 配置</title>
      <link href="/2020/03/17/scala/ji-chu/scala-idea-maven/"/>
      <url>/2020/03/17/scala/ji-chu/scala-idea-maven/</url>
      
        <content type="html"><![CDATA[<h2 id="Scala-IDEA-Maven-配置"><a href="#Scala-IDEA-Maven-配置" class="headerlink" title="Scala IDEA Maven 配置"></a>Scala IDEA Maven 配置</h2><ul><li>创建 Maven 项目</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317140311.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317140251.png" alt></p><ul><li>创建 scala 目录，右键并标记为 sources root</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317140349.png" alt></p><ul><li>右键项目名，添加 Add Framework，选择 Scala</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317140431.png" alt></p><ul><li>创建 Scala 文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317140506.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-多态</title>
      <link href="/2020/03/17/java/ji-chu/duo-tai/"/>
      <url>/2020/03/17/java/ji-chu/duo-tai/</url>
      
        <content type="html"><![CDATA[<p>Java 引用变量有两个类型。如果编译时类型和运行时类型不一致，就可能出现多态。</p><ul><li><p>编译时类型：由声明该变量时使用的类型决定</p></li><li><p>运行时类型：由实际运行时赋给该变量的对象决定</p></li></ul><h3 id="向上类型转换"><a href="#向上类型转换" class="headerlink" title="向上类型转换"></a>向上类型转换</h3><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaseClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> book <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类的普通方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类的test方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">BaseClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String book <span class="token operator">=</span> <span class="token string">"轻量级 Java EE"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类的test方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类的sub方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BaseClass ploymophicBc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ploymophicBc<span class="token punctuation">.</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>        ploymophicBc<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ploymophicBc<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 因为 ploymophicBc 的编译时类型是 BaseClass</span>        <span class="token comment" spellcheck="true">// BaseClass 类没有提供 sub 方法，所以下面代码编译时会出错</span>        <span class="token comment" spellcheck="true">// ploymophicBc.sub();</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面的例子中，引用变量 ploymophicBc 比较特殊，它的编译时类型是 BaseClass，而运行时类型是 SubClass。</p><p>ploymophicBc.sub() 这行代码会在编译时报错，因为 ploymophicBc 编译时类型为 BaseClass，而 BaseClass 中没有定义 sub 方法，因此编译时无法通过。</p><p>但是注意，ploymophicBc.book 的值为 6， 而不是 ”轻量级 Java EE“。因为<strong>对象的实例变量不具备多态性</strong>，系统总是试图访问它编译时类型所定义的成员变量，而非运行时。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>子类其实是一种特殊的父类，因此 java 允许把父类的引用指向子类对象，这被称为向上转型（upcasting），向上转型由系统自动完成。</p><p>可以调用哪些方法，取决于引用类型（编译时）。</p><p>具体调用哪个方法，取决于引用指向的实例对象（运行时）。</p><h3 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h3><p>问题：引用变量在代码编译过程中，只能调用它编译时类型具备的方法，而不能调用它运行时类型具备的方法</p><p>解决：强制转换成运行时类型</p><p>方法：引用类型之间的转换只能在有继承关系的两个类型之间进行，否则编译出错。如果想把一个父类引用变量的编译时类型转换成子类类型，则这个引用变量的运行时类型得是子类类型，否则引发 ClassCastException 异常</p><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建子类对象</span>Dog dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 向上类型转换(类型自动提升),不存在风险</span><span class="token comment" spellcheck="true">// 此时 animal 为 Dog 类型</span>Animal animal <span class="token operator">=</span> dog<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 风险演示：编译阶段不会报错，但是运行时会报错</span><span class="token comment" spellcheck="true">// 根据上面的语句，此时 animal 指向 Dog 类型对象，没有办法转化成 Cat 对象。</span>Cat cat <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>animal<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1.强转成功，编译时按 Cat 类型  2. 但运行时 Dog 类型，类型不匹配，直接报错</span></code></pre><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>为了解决强制类型转换，可能引发的 ClassCastException 异常，引入 instanceof 运算符。</p><p>instanceof 运算符的含义：用于判断左边的对象（运行时类型）是否是右边的类或者其子类、实现类的实例。如果是返回 true，否则返回 false。</p><p>在之前的代码中，强制类型转换前使用 instanceof 判断：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>anmial <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Cat cat <span class="token operator">=</span> <span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>animal<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-方法传参</title>
      <link href="/2020/03/17/java/ji-chu/fang-fa-chuan-can/"/>
      <url>/2020/03/17/java/ji-chu/fang-fa-chuan-can/</url>
      
        <content type="html"><![CDATA[<blockquote><p>无论是基本类型的值传递，还是引用类型的参数传递，在 Java 中方法总是采用<strong>按值调用</strong>。对于引用类型，传递的是其对应的内存空间地址。</p></blockquote><h3 id="基本类型的值传递"><a href="#基本类型的值传递" class="headerlink" title="基本类型的值传递"></a>基本类型的值传递</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrimitiveTransferTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>        b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"swap 方法里 a 的值为: "</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">" b的值为: "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"交换结束后 a 的值为 "</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">" b的值为 "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**运行结果：swap 方法里 a 的值为: 9 b的值为: 6交换结束后 a 的值为 6 b的值为 9*/</span></code></pre><p>分析图：</p><p>main 方法中定义了a、b 变量存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317093701.png" alt></p><p>main 方法中的变量作为参数值传入 swap() 方法存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317093735.png" alt></p><p>swap 方法中 a、b 交换后的存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/1.png" alt></p><p>java 程序总是从 main() 方法开始执行，main() 方法定义了 a、b 两个局部变量，两个变量在 main 栈区中。在 main() 方法中调用 swap() 方法时，main() 方法此时还未结束，因此系统为 main 方法和 swap 方法分配了两块栈区，用于保存 main 方法和 swap 方法的局部变量。main 方法中的 a、b 变量作为参数传入 swap 方法，实际上是在 swap 方法栈区中重新产生了两个变量 a、b，并将 main 方法栈区中 a、b 变量的值分别赋给 swap 方法栈区中的 a、b 参数（这就是初始化）。此时系统内存中有两个 a 变量、两个 b 变量，只是存在于不同的方法栈区中而已。</p><h3 id="引用类型的参数传递"><a href="#引用类型的参数传递" class="headerlink" title="引用类型的参数传递"></a>引用类型的参数传递</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceTransferTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>DataWrap dw<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> dw<span class="token punctuation">.</span>a<span class="token punctuation">;</span>        dw<span class="token punctuation">.</span>a <span class="token operator">=</span> dw<span class="token punctuation">.</span>b<span class="token punctuation">;</span>        dw<span class="token punctuation">.</span>b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"swap 方法里， a 成员变量的的值为: "</span> <span class="token operator">+</span> dw<span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token string">" b 成员变量的值为: "</span> <span class="token operator">+</span> dw<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DataWrap dw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataWrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dw<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>        dw<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>dw<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"交换结束后， a 成员变量的的值为: "</span> <span class="token operator">+</span> dw<span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token string">" b 成员变量的值为: "</span> <span class="token operator">+</span> dw<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**swap 方法里， a 成员变量的的值为: 9 b 成员变量的值为: 6交换结束后， a 成员变量的的值为: 9 b 成员变量的值为: 6*/</span></code></pre><p>你可能会疑问，dw 对象的成员变量 a、b的值也被替换了，这跟前面基本类型的传递完全不一样。这非常容易让人觉得，调用传入 swap 方法的就是 dw 对象本身，而不是它的复制品。其实传递的依然是 dw 的值。</p><p>分析图：</p><p>main 方法中创建 DataWrap 对象后的存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317094351.png" alt></p><p>main 方法中 dw 传入 swap() 方法后的存储示意图，如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200317094417.png" alt></p><p>系统一样赋值了 dw 的副本，只是关键在于 dw 只是一个引用变量，它存储的值只是一段内存地址，将该内存地址传递给 swap 栈区，此时 swap 栈区的 dw 和 main 栈区的 dw 的值也就是内存地址相同，该段内存地址指向堆内存中的  DataWrap 对象。对 swap 栈区的 dw 操作，也就是对 DataWrap 对象操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-数组</title>
      <link href="/2020/03/15/java/ji-chu/shu-zu/"/>
      <url>/2020/03/15/java/ji-chu/shu-zu/</url>
      
        <content type="html"><![CDATA[<p>数组是用来存储固定大小的同类型元素。一旦数组初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度不可以改变。即使某个数组的元素被清空，但是它所占的空间依然保留。</p><p>数组本身也是一种引用类型，既可以存储基本数据类型，也可以存储引用类型，只要存储的数组元素具有相同的类型即可。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><p>执行动态初始化时，系统会根据声明的数组类型自动为数组元素分配初始值。如果是引用类型，则数组元素的初始值为 null。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> scores <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p>显式指定每个元素的初始值</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> scores <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>foreach 遍历数组</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> scores <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> score <span class="token operator">:</span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h2><p>将数组看成两个部分，一个部分是数组引用，也就是在代码中定义的数组引用变量；另一部分是实际的数组对象，这部分是在堆内存中运行的，通常无法直接访问它，只能通过引用变量来访问。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组本质上还是一维数组，只是其数组元素也是引用，数组元素里保存的引用指向一维数组。</p><pre class=" language-java"><code class="language-java">String <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>代码示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200315143323.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-控制结构</title>
      <link href="/2020/03/15/java/ji-chu/kong-zhi-jie-gou/"/>
      <url>/2020/03/15/java/ji-chu/kong-zhi-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>   statement<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   statement<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> value1<span class="token operator">:</span>        statement1<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> value2<span class="token operator">:</span>        statement2<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> valuen<span class="token operator">:</span>        statementn<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        默认执行的代码<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当 switch 后表达式的值和 case 语句后的值相同时，从该位置向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。</p><ul><li><p>case 后面的值可以是常量数值，也可以是一个常量表达式，但不能是变量或带有变量的表达式</p></li><li><p>可以把功能相同的 case 语句合并起来</p></li><li><p>default 块可以出现在任意位置，也可以省略</p></li></ul><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    statement<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">do</span> <span class="token punctuation">{</span>    statement<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>循环变量初始化<span class="token punctuation">;</span> 循环条件<span class="token punctuation">;</span> 循环变量变化<span class="token punctuation">)</span> <span class="token punctuation">{</span>    statement；<span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门-数据类型</title>
      <link href="/2020/03/15/java/ji-chu/shu-ju-lei-xing/"/>
      <url>/2020/03/15/java/ji-chu/shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>基本数据类型变量存储的是数据本身</li><li>引用类型变量存储的是数据的空间地址</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，系统将会进行自动类型转换（隐式转换），否则需要强制转换。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换可能存在溢出导致数据精度丢失的情况。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Java 没有内置的字符串类型，而是提供了一个标准类库 String。</p><p>特征：不可变字符串</p><p>优点：编译器可以让字符串共享（只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS 读写流程</title>
      <link href="/2019/09/09/da-shu-ju/hdfs/hdfs-du-xie-liu-cheng/"/>
      <url>/2019/09/09/da-shu-ju/hdfs/hdfs-du-xie-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="HDFS-文件读取流程"><a href="#HDFS-文件读取流程" class="headerlink" title="HDFS 文件读取流程"></a>HDFS 文件读取流程</h2><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200314185440.png" alt></p><p>Client 端调用 DistributedFileSystem 对象的 open() 方法。</p><p>由 DistributedFileSystem 通过 RPC 向 NameNode 请求返回文件的 Block 块所在的 DataNode 的地址。（我们知道 HDFS 默认策略对某个 Block 会保存三份副本到不同的 DataNode，那么 NameNode 应该返回哪个 DataNode？答案是根据 DataNode 到 Client 端的距离。假设请求的 Block 块刚好就落在 Client 端所在机器上，即 Client 端本身也是 DataNode，那么毫无疑问 DataNode 将会返回 Client 端所在机器地址。这也验证了 Hadoop 的一个设计特性，移动计算而不是移动数据，极大了减小了带宽。）</p><p>Client 端调用 FSDataInputStream 对象的 read() 方法，通过 FSDataInputStream 向 DataNode 获取 Block 数据。之后数据流源源不断地从 DataNode 返回至 Client。当最后一个 Block 返回至 Client 端后， DFSInputStream 会关闭与 DataNode 连接。上述过程对 Client 端都是透明的，从 Client 来看，它只是在不停的读取数据流。</p><p>如果 DFSInputStream 在读取的过程中发生了错误，将会尝试与存有该 Block 副本且距离最近的 DataNode 通信。同时，它会记录下出问题的 DataNode，在之后的数据请求过程中不再与之通信。并报告给 NameNode。DFSInputStream 具备检查数据校验和的功能。</p><h2 id="HDFS-文件写入流程"><a href="#HDFS-文件写入流程" class="headerlink" title="HDFS 文件写入流程"></a>HDFS 文件写入流程</h2><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200314185557.png" alt></p><p>Client 写入文件时，调用 DistributedFileSystem 对象的 create() 方法。</p><p>DistributedFileSystem 通过 RPC 请求 NameNode 向其 NameSpace 写入文件元数据信息。NameNode 会做多种检查，如判断文件是否存在，是否有相应的写权限等等。如果检查通过，NameNode 会将文件元数据写入 NameSpace。DistributedFileSystem 将会返回 FSDataOutputStream 用于 Client 端直接向 DataNode 写入数据。</p><p>DFSOutputStream 将 Client 要写入的数据分割成 Packets。Packets 会被保存到 Data Queue 队列中，并由 DataStreamer 消费处理。DataStreamer 请求 NameNode 分配 DataNode 列表，将 Packets 写入到 DataNode 中。假设放置副本的默认策略是 3，那么 NameNode 将返回 3 个 DataNode，并串联起来组成一条 Pipeline。 DataStreamer 将 Packets 写入到第一个 DataNode1，DataNode1 存储完后直接转发至 DataNode2，DataNode2 存储完后再直接转发至 DataNode3。（注意，这里直接是 DataNode1 直接将 Packet 转发至 DataNode2。）</p><p>DFSOutputStream 为了防止出问题时数据的丢失，维持了一个等待 DataNode 成功写入的 ACK Queue。只有当 Packet 被成功写入 Pipeline 中的每个 DataNode 时，此 Packet 才会从 ACK Queue 中移除。</p><p>在 Pipeline 写入的过程中，如果某个 DataNode 出现问题，Pipeline 首先将会被关闭，随后在 ACK Queue 中的 Packets 会被添加到 Data Queue 的最前面，用来防止位于问题节点下游的 DataNode 写入时的数据丢失。出问题的 DataNode 会被从 Pipeline 中移除。NameNode 会重新分配一个健康的 DataNode 构成新的 Pipeline。</p><p>当 Client 端写完数据，调用 DFSOutputStream 对象的 close() 方法。该操作将会将所有剩余的 Packets 刷写到 DataNode Pipeline 并等待返回确认，之后向 NameNode 发送文件写入完成信号。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CM &amp; CDH 基本介绍</title>
      <link href="/2019/08/17/da-shu-ju/cdh/cm-cdh-ji-ben-jie-shao/"/>
      <url>/2019/08/17/da-shu-ju/cdh/cm-cdh-ji-ben-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-CDH"><a href="#什么是-CDH" class="headerlink" title="什么是 CDH"></a>什么是 CDH</h2><p>Hadoop 是开源项目，所以很多公司在这个基础上进行商业化，不收费的 Hadoop 主要有三个：</p><ul><li><p>Apache，最原始的版本，所有发行版均基于这个版本进行</p></li><li><p>Cloudear，全称 Cloudera’s Distribution Including Apache Hadoop，简称 CDH</p></li><li><p>Hortonworks，全称 Hortonworks Data Platform，简称 HDP</p></li></ul><h2 id="什么是-Cloudera-Manager"><a href="#什么是-Cloudera-Manager" class="headerlink" title="什么是 Cloudera Manager"></a>什么是 Cloudera Manager</h2><p>Cloudear Manager，简称 CM，用于管理 CDH 集群，其主要功能是对 CDH 集群进行监控，大大改善原生 Apache Hadoop 的安装、配置复杂度和需要使用第三方开源监控工具所带来的诸多问题，可进行节点安装、配置、诊断、集成并提供 web 界面。</p><h2 id="CM-架构"><a href="#CM-架构" class="headerlink" title="CM 架构"></a>CM 架构</h2><p><img src="https://cdn.jsdelivr.net/gh/Tianny/Pic/img/20200314185027.png" alt></p><p>基本组成：</p><ul><li><p>Server</p></li><li><p>Agent：安装在每个集群节点上，Server 下发的操作都由 Agent 来实现</p></li><li><p>Management Service：监控报警等功能</p></li><li><p>Database：存储各种服务配置信息和报警信息</p></li><li><p>Cloudera Repoistory：用来分发 Parcels 包的远程仓库</p></li><li><p>Clients</p></li></ul><p>Server 和 Agent 通信方式：默认情况下，Agent 每隔 15s 向 Server 发送心跳。但是当状态发生变化时，为了减少用户等待时间，会加快心跳频率。</p><h2 id="CM-术语"><a href="#CM-术语" class="headerlink" title="CM 术语"></a>CM 术语</h2><ul><li><p>host 主机</p></li><li><p>rack 机架</p></li><li><p>cluster 集群</p></li><li><p>service 服务，例如 HDFS、YARN 都是一个个服务</p></li><li><p>role 角色，例如 HDFS 的 NameNode 和 DataNode 都可以称为 HDFS 的 角色</p></li><li><p>role group 角色组，将角色划分为一组方便管理</p></li><li><p>host template 主机模板</p></li><li><p>parcel 包</p></li><li><p>static service pool 静态服务池</p></li><li><p>dynamic resource pool 动态资源池</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDH </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

{"meta":{"title":"Tianny's Blog","subtitle":"Tianny","description":"What is a real programmer?","author":"Tianny","url":"https://tianny.cc","root":"/"},"pages":[{"title":"about","date":"2018-10-05T08:33:28.000Z","updated":"2019-06-02T11:37:29.738Z","comments":true,"path":"about/index.html","permalink":"https://tianny.cc/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-13T15:43:47.000Z","updated":"2019-06-02T11:37:29.739Z","comments":true,"path":"friends/index.html","permalink":"https://tianny.cc/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-01T16:47:23.000Z","updated":"2019-06-02T11:37:29.738Z","comments":true,"path":"categories/index.html","permalink":"https://tianny.cc/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-12T15:24:17.000Z","updated":"2019-06-02T11:37:29.739Z","comments":true,"path":"tags/index.html","permalink":"https://tianny.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTPDNS原理","slug":"Network/HTTPDNS原理","date":"2020-10-31T06:48:25.000Z","updated":"2020-10-31T06:48:51.679Z","comments":true,"path":"2020/10/31/network/httpdns-yuan-li/","link":"","permalink":"https://tianny.cc/2020/10/31/network/httpdns-yuan-li/","excerpt":"","text":"聊聊 HTTP DNS 的工作方式。传统 DNS 存在的问题当我们发出请求解析 DNS 的时候，首先，会先连接到运营商本地的 DNS 服务器，由这个服务器帮我们去整棵 DNS 树上进行解析，然后将解析的结果返回给客户端。但是本地的 DNS 服务器，作为一个本地导游，往往有自己的“小心思”。一个最令人头痛的问题，相信每个人都遇到，就是域名劫持。HTTPDNS 概念HTTPNDS 不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。这就相当于每家基于 HTTP 协议，自己实现自己的域名解析，自己做一个自己的地址簿，而不使用统一的地址簿。但是默认的域名解析都是走 DNS 的，因而使用 HTTPDNS 需要绕过默认的 DNS 路径，就不能使用默认的客户端。使用 HTTPDNS 的，往往是手机应用，需要在手机端嵌入支持 HTTPDNS 的客户端 SDK。通过自己的 HTTPDNS 服务器和自己的 SDK，实现了从依赖本地导游，到自己上网查询做旅游攻略，进行自由行，爱怎么玩怎么玩。这样就能够避免依赖导游，而导游又不专业，你还不能把他怎么样的尴尬。HTTPDNS 工作模式在客户端的 SDK 里动态请求服务端，获取 HTTPDNS 服务器的 IP 列表，缓存到本地。随着不断地解析域名，SDK 也会在本地缓存 DNS 域名解析的结果。当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地 DNS 的缓存不一样的是，这个是手机应用自己做的，而非整个运营商统一做的。如何更新、何时更新，手机应用的客户端可以和服务器协调来做这件事情。如果本地没有，就需要请求 HTTPDNS 的服务器，在本地 HTTPDNS 服务器的IP 列表中，选择一个发出 HTTP 的请求，会返回一个要访问的网站的 IP 列表。请求的方式是这样的。123curl http://106.2.xxx.xxx/d?dn=c.m.163.com&#123;\"dns\":[&#123;\"host\":\"c.m.163.com\",\"ips\":[\"223.252.199.12\"],\"ttl\":300,\"http2\":0&#125;],\"client\":&#123;\"ip\":\"106.2.81.50\",\"line\":269692944&#125;&#125;手机客户端自然知道手机在哪个运营商、哪个地址。由于是直接的 HTTP 通信，HTTPDNS 服务器能够准确知道这些信息，因而可以做精准的全局负载均衡。HTTPDNS 缓存设计HTTPDNS 将解析速度和更新速度全部掌控在自己手中。一方面，解析的过程，不需要本地 DNS 服务递归的调用一大圈，一个 HTTP 的请求直接搞定，要实时更新的时候，马上就能起作用；另一方面为了提高解析速度，本地也有缓存，缓存是在客户端 SDK 维护的，过期时间、更新时间，都可以自己控制。HTTPDNS 的缓存设计策略也是咱们做应用架构中常用的缓存设计模式，也即分为客户端、缓存、数据源三层，分别对应 SDK 客户端、本地缓存、HTTPDNS 服务器。只要是缓存模式，就存在缓存的过期、更新、不一致的问题，解决思路也是很像的。例如 DNS 缓存在内存中，也可以持久化到存储上，从而 APP 重启之后，能够尽快从存储中加载上次累积的经常访问的网站的解析结果，就不需要每次都全部解析一遍，再变成缓存。这有点像Redis是基于内存的缓存，但是同样提供持久化的能力，使得重启或者主备切换的时候，数据不会完全丢失。SDK 中的缓存会严格按照缓存过期时间，如果缓存没有命中，或者已经过期，而且客户端不允许使用过期的记录，则会发起一次解析，保障记录是更新的。解析可以同步进行，也就是直接调用 HTTPDNS 的接口，返回最新的记录，更新缓存；也可以异步进行，添加一个解析任务到后台，由后台任务调用HTTPDNS 的接口。HTTPDNS调度设计在客户端，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HTTPDNS服务端可以根据这些信息，选择最佳的服务节点返回。如果有多个节点，还会考虑错误率、请求时间、服务器压力、网络状况等，进行综合选择，而非仅仅考虑地理位置。当有一个节点宕机或者性能下降的时候，可以尽快进行切换。要做到这一点，需要客户端使用 HTTPDNS 返回的 IP 访问业务应用。客户端的 SDK 会收集网络请求数据，如错误率、请求时间等网络请求质量数据，并发送到统计后台，进行分析、聚合，以此查看不同的 IP 的服务质量。在服务端，应用可以通过调用 HTTPDNS 的管理接口，配置不同服务质量的优先级、权重。HTTPDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址。HTTPDNS 通过智能调度之后返回的结果，也会缓存在客户端。为了不让缓存使得调度失真，客户端可以根据不同的移动网络运营商 WIFI 的 SSID 来分维度缓存。不同的运营商或者 WIFI 解析出来的结果会不同。小结传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://tianny.cc/tags/DNS/"}]},{"title":"DNS原理","slug":"Network/DNS原理","date":"2020-10-31T06:47:04.000Z","updated":"2020-10-31T06:48:15.551Z","comments":true,"path":"2020/10/31/network/dns-yuan-li/","link":"","permalink":"https://tianny.cc/2020/10/31/network/dns-yuan-li/","excerpt":"","text":"聊聊 DNS 的工作方式。DNS 服务器DNS 服务器，一定要设置成高可用、高并发和分布式的。于是便有了树状结构，如下图所示：主要有三个概念：根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址权威 DNS 服务器 ：返回相应主机的 IP 地址DNS 解析流程总结为四个字：递归查询。DNS 负载均衡先看一个简单的，内部负载均衡。例如，一个应用要访问数据库，在这个应用里面应该配置这个数据库的 IP 地址，还是应该配置这个数据库的域名呢？显然应该配置域名，因为一旦这个数据库，因为某种原因，换到了另外一台机器上，而如果有多个应用都配置了这台数据库的话，一换 IP 地址，就需要将这些应用全部修改一遍。但是如果配置了域名，则只要在 DNS 服务器里，将域名映射为新的 IP 地址，这个工作就完成了，大大简化了运维。在这个基础上，我们可以再进一步。例如，某个应用要访问另外一个应用，如果配置另外一个应用的 IP 地址，那么这个访问就是一对一的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。但是，访问它的应用，如何在多个之间进行负载均衡？只要配置成为域名就可以了。在域名解析的时候，我们只要配置策略，这次返回第一个 IP，下次返回第二个 IP，就可以实现负载均衡了。除了上面提到的，DNS 还可以做全局负载均衡。通常我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就是全局负载均衡的概念。下面以 DNS 访问数据中心中对象存储上的静态资源为例，看看整个过程：假设全国有多个数据中心，托管在多个运营商，每个数据中心有三个可用区（Available Zone）。对象存储通过跨可用区部署，实现高可用性。在每个数据中心中，都至少部署两个内部负载均衡器，内部负载均衡器后面对接多个对象存储的前置服务器（Proxy-server）。当一个客户端要访问 object.yourcompany.com 的时候，需要将域名转换为IP地址进行访问，所以它要请求本地 DNS 解析器。本地 DNS 解析器先查看看本地的缓存是否有这个记录。如果有则直接使用，因为上面的过程太复杂了，如果每次都要递归解析，就太麻烦了。如果本地无缓存，则需要请求本地的 DNS 服务器。本地的 DNS 服务器一般部署在你的数据中心或者你所在的运营商的网络中，本地 DNS 服务器也需要看本地是否有缓存，如果有则返回，因为它也不想把上面的递归过程再走一遍。至 7. 如果本地没有，本地 DNS才 需要递归地从根 DNS 服务器，查到 .com 的顶级域名服务器，最终查到 yourcompany.com 的权威 DNS 服务器，给本地DNS 服务器，权威 DNS 服务器按说会返回真实要访问的 IP 地址。对于不需要做全局负载均衡的简单应用来讲，yourcompany.com 的权威 DNS服务器可以直接将 object.yourcompany.com 这个域名解析为一个或者多个 IP 地址，然后客户端可以通过多个 IP 地址，进行简单的轮询，实现简单的负载均衡。但是对于复杂的应用，尤其是跨地域跨运营商的大型应用，则需要更加复杂的全局负载均衡机制，因而需要专门的设备或者服务器来做这件事情，这就是全局负载均衡器（GSLB，Global Server Load Balance）。在 yourcompany.com 的DNS服务器中，一般是通过配置 CNAME 的方式，给 object.yourcompany.com 起一个别名，例如 object.vip.yourcomany.com，然后告诉本地 DNS 服务器，让它请求 GSLB 解析这个域名，GSLB 就可以在解析这个域名的过程中，通过自己的策略实现负载均衡。图中画了两层的 GSLB，是因为分运营商和地域。我们希望不同运营商的客户，可以访问相同运营商机房中的资源，这样不跨运营商访问，有利于提高吞吐量，减少时延。第一层 GSLB，通过查看请求它的本地 DNS 服务器所在的运营商，就知道用户所在的运营商。假设是移动，通过 CNAME 的方式，通过另一个别名 object.yd.yourcompany.com，告诉本地 DNS 服务器去请求第二层的 GSLB。第二层 GSLB，通过查看请求它的本地 DNS 服务器所在的地址，就知道用户所在的地理位置，然后将距离用户位置比较近的 Region 里面，六个内部负载均衡（SLB，Server Load Balancer）的地址，返回给本地 DNS 服务器。本地 DNS 服务器将结果返回给本地 DNS 解析器。本地 DNS 解析器将结果缓存后，返回给客户端。客户端开始访问属于相同运营商的距离较近的 Region 1 中的对象存储，当然客户端得到了六个 IP 地址，它可以通过负载均衡的方式，随机或者轮询选择一个可用区进行访问。对象存储一般会有三个备份，从而可以实现对存储读写的负载均衡。小结DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能；在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://tianny.cc/tags/DNS/"}]},{"title":"帅天说理财-从小狗钱钱说起","slug":"Finace/帅天说理财-从小狗钱钱说起","date":"2020-10-24T07:24:29.000Z","updated":"2020-10-24T07:24:58.891Z","comments":true,"path":"2020/10/24/finace/shuai-tian-shuo-li-cai-cong-xiao-gou-qian-qian-shuo-qi/","link":"","permalink":"https://tianny.cc/2020/10/24/finace/shuai-tian-shuo-li-cai-cong-xiao-gou-qian-qian-shuo-qi/","excerpt":"","text":"理财，人生的守望明灯。贫穷的不是金钱，而是你的思维限制一直以为理财就只是和钱有关，初步接触，才明白理的不仅仅是钱，而是人生的一个规划与梳理，还一度认为，理财是有钱之后的事情，现在看来完全是一种错误的想法。再次意识到了，思维的重要性，为何贫穷的人很难富起来，当你为支付生活开销、生病费用、还贷款而苦恼的时候，富人们的思维和视野放的比较长远，在某些问题上他们都能够找到更好的解决办法，善于深远和分解的方式去思考问题，而让自己的收益增加，损失降到最少。看了一本《小狗钱钱》，适合对理财毫无概念的朋友读一读，早些认识到理财知识，你的人生将会有翻天覆地的改变，那么不管你几岁，从现在开始就不晚。学会培养属于你的鹅从前，有一个年轻的农夫，他每天的愿望就是在鹅笼里捡一个鹅蛋当早饭。有一天，他竟然在鹅笼里发现了一个金蛋。当然，一开始他不相信这是真的。他想也许有人在捉弄他。为了谨慎起见，他把金蛋拿去瓤金匠看，可是金匠向他保证说，这只蛋完完全全是纯金铸成的。于是，农夫就卖了这只金蛋，然后举行了一个盛大的庆祝会。第二天清晨，他起了一个大早，赶到鹅笼一看，那里果真又放着一个金蛋。这样的情况延续了好几天。可是农夫是一个贪婪的人，他对自己的鹅非常不满意，因为鹅没法向他解释是怎么下出金蛋的，否则也许他自己可以制造金蛋了，他还气呼呼地想，这只懒惰的鹅每天至少应该下两只金蛋，现在这样的速度太慢了。他怒火越来越大，最后，他终于怒不可遏的把鹅揪出鹅笼，劈成两半。从那以后，他再也得不到金蛋了。这个故事不仅仅说明了农夫这一类人的贪婪和愚蠢，更重要的是一个理财观念，是要培养你的鹅，无论何时都不要杀死你的鹅，鹅就代表你存的钱，利息就相当于金蛋，书中吉娅是运用每次的收入50%放进他的鹅里面，而你可以根据自己的实际情况来规划自己鹅的比例。那么，听完了故事，你是不是开始计划养一只属于你的鹅了，并且开始培养它，让它成为你理财和规划人生开始的第一步。钱不是万能的，没有钱是万万不能的我也不认为钱是人生命中最重要的东西。可是，假如我们缺钱的话，钱就会变得格外重要。金钱本身是没有存在好坏之分，关键是在于拥有和使用他的人。你要学会如何去运用金钱让自己的人生过得越来越敞亮，而不是被金钱所控制，可以从养一只鹅开始，现在、立刻、马上开始吧。金钱是有一些秘密和规律，要想了解这些秘密和规律，前提条件是，你要自己必须有这个愿望。必须有这个愿望，就是对自己有自信，你拥有了自信，自然就有了挣钱的信心和力量，列出十个想要变得富有的理由，然后从中筛选出最重要的三个，每天都要拿出来翻一遍，你就会在生活中密切关注那些能够促使你愿望成功的事情，让你在实现愿望的道路上事半功倍。学会发挥自己的长处，多关注自己拥有的我们来看一下关于达瑞的故事。“有一次达瑞对别人讲自己的故事，而我正好听见了。故事是这样开始的。在达瑞8岁的时候，有一天，他想去看电影但是没有钱。他面临一个基本的问题，是问爸爸妈妈要钱还是自己挣钱。最后他选择了后者。他自己调制了一种汽水，把它放在街边，向过路的行人出售。可那时正是寒冷的冬天，没有人来买，只有两个人例外——他的爸爸和妈妈。“他偶然得到了一个机会，可以与一位非常成功的商人谈话。当他对商人讲述了自己的‘破产史’后，商人给了他两个重要的建议：第一，为别人解决一个难题，那么你就能赚到许多钱；第二，把精力集中在你知道的、能做的和拥有的东西上。“这两个建议很关键。因为对于一个8岁的男孩而言，他不会做的事情有很多。于是他一边沿着大街小巷漫步，一边不停地思考人们会有什么难题，他又该如何利用这个机会为他们解决难题。通过这种思维，达瑞为自己找了很多份可以让自己赚钱的工作，帮别人送报纸，帮别人扔垃圾，看房子，给植物浇水等等，9岁用父亲的电脑写广告，忙不过来的时候还雇佣别人来做，12岁时候被出版社注意，写了一本《孩子赚钱的250个方法》，因此达瑞在12岁的时候就成为了一个畅销书作家，以后的故事当然是理所应当的越来越有名气、越来越富有。机会固然重要，但认清楚自己所擅长和能做的事情，也是你通往成功道路上一个重要的组成部分，那么自己不擅长的事情就可以交给别人来做，团队合作一定会比个人的战斗力要强太多，各司其职，同时也会为自己节省一部分时间和精力，再投入另一份价值的事情中去，周而复始你必定会在财务和人生上越来越富有和自由。两个选择：做或者不做不是试试看，而是去行动！如果你只是带着试试看的心态，那么你最后只会以失败而告终，你会一事无成。尝试纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择——做或者不做。很多时候我们总是会说可能、差不多吧、我试试等，这些不确定性的词语，这样很不利于你做成功这件事，因为你给自己留了后路，从一开始你就没想过要成功，只是抱着运气的心态，最终必定会失败，所以选择做一件事情后，要自信的坚定地去做，去完成它。利用喜欢的事情去赚钱他向我解释道：“吉娅，大多数人都是这么想的，我曾经也这么想。可是请你告诉我，你为什么不能因为做了一件自己喜欢的事情而挣到钱呢？”看到这一段我被震撼到了，有些人会认为某方面兴趣只是自己的一个爱好，所以不会想到会用兴趣去赚钱，这种想法是受限制的，不如在此刻问自己：为什么不？从另一本书上看到说，如果你能把你喜欢的事情发展成自己终身职业，那么你的幸福感就会比别人高很多，现在想想道理很明显的，而很多人都会忽略自己知道的、能做的和拥有的，而去追寻那些自己并不喜欢的，最终让自己很累，却也很难达到自己理想的结果。那么我们在用自己的喜欢的事情赚钱之前，你最好想清楚你喜欢做什么，然后再去考虑如何用它来挣钱。比如书中吉娅比较喜欢狗狗，最后就利用这个帮助被人遛狗、训练狗赚到了一大笔佣金，又喜欢又能增加自己收入的事情，何乐而不为呢。还有一点，不要把希望都寄托在一份工作上，因为它的持续性不会像你想象的那么长，你要学会为自己寻找可以替代的工作，从而让自己的收入和可选择性得到提升。这样还有一个好处就是，在你失去这一份工作的时候，不会对你的本质生活造成比较大的影响。记录让你更加了解自己书中讲到的愿望清单和成功日记我觉得非常有用。中国智者老子说道：天下难事必做于易，天下大事必做于细（千里之行始于足下）。所以必须找出十个想变得富有的理由。愿望清单可以让你更加清晰的了解自己想要的，也是一种动力，并且你每天翻看它，也能够与生活中的每件事情引起共鸣，这样也有助于你更好的达成自己的梦想清单。而成功日记，记录你每天的成功的事情，最少5件每天，等你想要做某件事情而怕自己做不到的时候，拿出来翻看，看到自己已经做成了那么多成功的事情，也会给自己信心的一个提升，从而促使自己更加有勇气和自信的去做这件事情。请别忘了去思考如果你现在还很年轻，那么恭喜你可以这么早的接触到这些能够让你更好的管理自己人生的理财知识，理就是梳理自己的人生，规划自己的人生。金钱的本质与幸福感无关，而在于你怎么去使用它，一个不开心的人拥有再多的金钱他依然会有烦恼，是因为他的本质没有改变。就像书中写到，小偷以为有了大量的金钱就能够改变自己的生活和本质，可事实并不是这样的，除非他的内心和思维得到变化才行。过去不再回来，而从现在开始学着去理清自己的人生，无论你的收入多少，去给自己培养一只鹅，让他为你下金鸡蛋，持续的坚持下去，相信你会变成富有的人，而这种富有不仅仅是物质，还有你的精神世界。几个实践方法一、愿望清单请想出10个你想变富有的原因？从中圈出3个自己觉得最重要的事情。每天将这张写着自己愿望的单子从头到尾看一遍。 那么你就会密切关注一切可以帮你实现这些愿望的机遇了。二．梦想相册建议你拿一本相册作为你的梦想相册。搜集一些与自己的愿望有关的照片，把他们贴在相册里。我们要通过图片来思考。有时候我们不需要完全明白为什么这种方式有效，关键是它确实有效。三、成功日记。每天记录自己当天成功的事情，最少5件，然后坚持不断地每天做下去，你可以选择在每天早起留出10分钟时间来做这件事情。四、给债务人的建议毁掉信用卡。在许可的范围内按最低的分期付款数目标准支付。消费贷款：所有的消费贷款都是不明智的，聪明的做法是只把以前积攒起来的财富用于支出。将扣除生活费后剩下的钱一半存起来，剩下的一半用于支付消费贷款。在需要消费之前，问自己这真的有必要吗？五、一个定律当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会在做了。","categories":[{"name":"Finace","slug":"Finace","permalink":"https://tianny.cc/categories/Finace/"}],"tags":[{"name":"Finace","slug":"Finace","permalink":"https://tianny.cc/tags/Finace/"}]},{"title":"帅天说理财-富爸爸与穷爸爸","slug":"Finace/帅天说理财-富爸爸与穷爸爸","date":"2020-10-24T07:22:26.000Z","updated":"2020-10-27T03:28:40.991Z","comments":true,"path":"2020/10/24/finace/shuai-tian-shuo-li-cai-fu-ba-ba-yu-qiong-ba-ba/","link":"","permalink":"https://tianny.cc/2020/10/24/finace/shuai-tian-shuo-li-cai-fu-ba-ba-yu-qiong-ba-ba/","excerpt":"","text":"先跟大家介绍下自己的情况，帅天是计算机软件出生，对投资理财方面的知识也是门外汉，和广大的普通理财小白一样，正在学习的路上。如果你也想学习投资理财相关的知识，请关注帅天，愿大家早日达到财富自由。《富爸爸、穷爸爸》是帅天投资理财路上的第二本书。此书相比帅天读的第一本理财入门书《小狗钱钱》从另个角度阐述了理财的价值观。全书的核心的思想用一句话表达就是，购买资产降低负债。有人会问什么是资产？什么是负债？股票、基金、债券、能够产生收入的房地产等都是资产，而车子、奢侈品、名牌都是负债。资产可以带来额外收入，所以要购买资产，而不是购买负债。同时用资产产生的收入也就是所谓的钱生钱来支付负债，比如购买奢侈品或者名牌包包。任何人做任何工作，只要把这个概念理清后铭记于心，在经济条件方面都不会过得太差。如何增加资产？三个增加资产的典型方法：打工、创业、投资。对大部分人来说，打工是普遍的道路，也是必须的道路，就算是创业者一开始也免不了打工，只不过是为自己打工而已。一开始提升打工的能力是增加资产最有效的方法，即所谓的原始积累，提升打工的能力换句话说就是提升专业能力、人际关系、职业素养等等。在打工的过程中拿出小部分精力去学习投资知识并付诸实践，比如购买一些常见的理财产品，保险、基金等等。在 25-30 岁的阶段，帅天觉得一般人需要把主要的精力放在提升打工的能力上，以达到原始资金的积累，简单的来说就是不仅能靠自己养活自己，还需要在满足日常开销的基础上，过的比较滋润。第二就是创业。引用网络上广为流传的一句话，打工？不可能的，一辈子都不可能打工的。我们需要专注自己的事业。打工只是工具人，真正的利润都流入了老板的口袋。什么是自己的事业？不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那儿工作，那它就不是我的事业而是我的职业了。股票债券能够产生收入的房地产版税，如音乐、手稿、专利其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西创业的机遇是千载难逢的，同时也是充满风险的，创业既是资产也是负债，如果失败普通人可能承受不起。所以尝试着从上面列出的一些选项开始入手，从广义上来说都算是创业的一种形式。我们需要关注自己的事业，保持低支出，降低负债，为坚实的资产打造基础。投资，财富自由的终极状态。此时投资的收益不仅仅超过日常开支，还能远远超过打工的收益。帅天觉得要想到达这个状态，肯定需要大量投资理财方面的知识作为基础，同时提高财商，并且学会如何驾驭风险。再聊聊负债。减少负债不代表没有负债，像我个人最近买的 MacbookPro，但一定是我承担起的负债，占我收入比重不多的负债。最重要还是要理清什么是资产，什么是负债，进行合理的分配，不要买了房子就以为是资产，也不要借钱就以为是负债，当然借钱投资失败就是一种负债。对于普通人来说，其实并不需要多么精湛的投资技巧，或冒多大的风险创业，只要理清生活中这些概念，想清楚自己到底在做什么，在职场道路上稳定发展，增加资产和减少负债都能过上不错的小资生活。作为一名同样目前还是一名兢兢业业的打工者，帅天给有几个建议给大家：不断学习，掌握新技能，涉猎各种职业，学习其他不同领域知识和经验快速学习的力量销售和营销技能，对一个人的成功是至关重要的时间和学习，是在你没钱的时候，唯一可以投资的事。头脑是最重要的资产最后，《富爸爸穷爸爸》一书中提到致富的核心技能有会计、投资、营销、法律，会计学可以教会我们解读数字的能力以及评估一项生意的优势和劣势，投资让我们掌握钱生钱的科学和策略，市场让我们了解供给与需求的科学以及市场条件，而法律则让我们再减税优惠和在诉讼中获得保护。如果喜欢这篇文章，请点个关注，你的关注是我最大的动力。愿诸君早日实现财富自由！","categories":[{"name":"Finace","slug":"Finace","permalink":"https://tianny.cc/categories/Finace/"}],"tags":[{"name":"Finace","slug":"Finace","permalink":"https://tianny.cc/tags/Finace/"}]},{"title":"HTTPS加密原理","slug":"Network/HTTPS加密原理","date":"2020-10-24T07:13:34.000Z","updated":"2020-10-24T07:14:05.475Z","comments":true,"path":"2020/10/24/network/https-jia-mi-yuan-li/","link":"","permalink":"https://tianny.cc/2020/10/24/network/https-jia-mi-yuan-li/","excerpt":"","text":"HTTPS（SSL/TLS）的加密机制是每个开发者都应该了解和掌握的，虽然框架或库中可能已经封装好，无需我们操心，但是理解 HTTPS 的工作机制，在我们遇到问题时，可以显得游刃有余。在开始介绍 HTTPS 之前，需要了解一些密码学相关的概念。因为 HTTPS 的加密机制与之息息相关。对称加密什么是对称加密？在对称加密算法中，加密和解密使用的密钥是相同的。也就是说，加密和解密使用的是同一个密钥。因此，对称加密算法要保证安全性的话，密钥要做好保密。只能让使用的人知道，不能对外公开。但怎么来约定这个密钥呢？如果这个密钥在互联网上传输，也是很有可能让黑客截获的。黑客一旦截获这个秘钥，它可以佯作不知，静静地等着你们两个交互。这时候你们之间互通的任何消息，它都能截获并且查看，就等你把银行卡账号和密码发出来。所以只能通过线下传输。比如，你和外卖网站偷偷约定时间地点，它给你一个纸条，上面写着你们两个的密钥，然后说以后就用这个密钥在互联网上定外卖了。当然你们接头的时候，也会先约定一个口号，什么”天王盖地虎”之类的，口号对上了，才能把纸条给它。但是，“天王盖地虎”同样也是对称加密密钥，同样存在如何把”天王盖地虎”约定成口号的问题。这样就陷入了死循环了。非对称加密在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。非对称加密的私钥放在外卖网站这里，不会在互联网上传输，这样就能保证这个秘钥的私密性。但是，对应私钥的公钥，是可以在互联网上随意传播的，只要外卖网站把这个公钥给你，你们就可以愉快地互通了。比如说你用公钥加密，说“我要定外卖”，黑客在中间就算截获了这个报文，因为它没有私钥也是解不开的，所以这个报文可以顺利到达外卖网站，外卖网站用私钥把这个报文解出来，然后回复，“那给我银行卡和支付密码吧”。先别太乐观，这里还是有问题的。回复的这句话，是外卖网站拿私钥加密的，互联网上人人都可以把它打开，当然包括黑客。因为外卖网站的公钥在互联网上随意传播的，每个人都可以拿到。同样，黑客也可以模拟用户发送“我要定外卖”这个过程的，因为它也有外卖网站的公钥。为了解决这个问题，看来一对公钥私钥是不够的，客户端也需要有自己的公钥和私钥，并且客户端要把自己的公钥，给外卖网站。这样，客户端给外卖网站发送的时候，用外卖网站的公钥加密。而外卖网站给客户端发送消息的时候, 使用客户端的公钥。这样就算有黑客企图模拟客户端获取一些信息，或者半路截获回复信息，但是由于它没有私钥，这些信息它还是打不开。数字证书如何将不对称加密的公钥给对方呢？一种是放在一个公网的地址上，让对方下载；另一种就是在建立连接的时候，传给对方。这两种方法有相同的问题，那就是，作为一个普通网民，你怎么鉴别别人给你的公钥是对的。会不会有人冒充外卖网站，发给你一个它的公钥。接下来，你和它所有的互通，看起来都是没有任何问题的。毕竟每个人都可以创建自己的公钥和私钥。公说公有理婆说婆有理，这个时候就需要权威部门的介入了，就像每个人都可以打印自己的简历，说自己是谁，但是有公安局盖章的，就只有户口本，这个才能证明你是你。这个由权威部门颁发的称为证书（Certificate）。证书里面有什么呢？当然应该有公钥，这是最重要的；还有证书的所有者，就像户口本上有你的姓名和身份证号，说明这个户口本是你的；另外还有证书的发布机构和证书的有效期，这个有点像身份证上的机构是哪个区公安局，有效期到多少年。这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？就像有假身份证、假户口本一样。生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为 CA（ Certificate Authority）。将这个请求发给权威机构，权威机构会给这个证书卡一个章，我们称为签名算法。问题又来了，那怎么签名才能保证是真的权威机构签名的呢？当然只有用只掌握在权威机构手里的东西签名了才行，这就是 CA 的私钥。签名算法大概是这样工作的：一般是对信息做一个 Hash 计算,得到一个 Hash 值，这个过程是不可逆的，也就是说无法通过 Hash 值得出原来的信息内容。在把信息发送出去时，把这个 Hash 值加密后，作为一个签名和信息一起发出去。CA 用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。证书的内容：这里面有个 Issuer，也即证书是谁颁发的；Subject，就是证书颁发给谁；Validity 是证书期限；Public- key 是公钥内容；Signature Algorithm 是签名算法。这下好了，你不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构 CA，你只要得到这个发布机构 CA 的公钥，去解密外卖网站证书的签名，如果解密成功了，Hash 也对的上，就说明这个外卖网站的公钥没有啥问题。有没有发现，又有新问题了。要想验证证书，需要 CA 的公钥，问题是，你怎么确定 CA 的公钥就是对的呢? 所以，CA 的公钥也需要更牛的 CA 给它签名，然后形成 CA 的证书。要想知道某个 CA 的证书是否可靠, 要看 CA 的上级证书的公钥，能不能解开这个 CA 的签名。就像你不相信区公安局，可以打电话问市公安局，让市公安局确认区公安局的合法性。这样层层上去，直到全球皆知的几个著名大 CA，称为 root CA，做最后的背书。通过这种层层授信背书的方式，从而保证了非对称加密模式的正常运转。以上介绍了几个关键知识点，只有理解了上面的内容，才能继续往下哦。HTTPS 工作机制我们可以知道，非对称加密在性能上不如对称加密，那是否能将两者结合起来呢？例如，公钥私钥主要用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。如下图所示：当你登录一个外卖网站的时候，由于是 HTTPS，客户端会发送 Client Hello 消息到服务器，以明文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息。另外，还会有一个随机数，在协商对称密钥的时候使用。这就类似在说：“您好，我想定外卖，但你要保密我吃的是什么。这是我的加密套路，再给你个随机数，你留着。”然后，外卖网站返回 Server Hello 消息,，告诉客户端，服务器选择使用的协议版本、加密套件、压缩算法等，还有一个随机数，用于后续的密钥协商。这就类似在说：“您好，保密没问题，你的加密套路还挺多，咱们就按套路 2 来吧，我这里也有个随机数，你也留着。”然后，外卖网站会给你一个服务器端的证书，然后说：“Server Hello Done，我这里就这些信息了。”你当然不相信这个证书，于是你从自己信任的 CA 仓库中,拿 CA 的证书里面的公钥去解密外卖网站的证书。如果能够成功，则说明外卖网站是可信的。这个过程中，你可能会不断往上追溯CA、CA的CA、CA的CA的CA，反正直到一个授信的 CA，就可以了。证书验证完毕之后，觉得这个外卖网站可信，于是客户端计算产生随机数字Pre-master，发送 Client Key Exchange，用证书中的公钥加密，再发送给服务器，服务器可以通过私钥解密出来。到目前为止，无论是客户端还是服务器，都有了三个随机数，分别是：自己的、对端的以及刚生成的 Pre-Master 随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。有了对称密钥，客户端就可以说：“Change Cipher Spec，咱们以后都采用协商的通信密钥和加密算法进行加密通信了。”然后发送一个 Encrypted Handshake Message，将已经商定好的参数等，采用协商密钥进行加密，发送给服务器用于数据与握手验证。同样，服务器也可以发送 Change Cipher Spec，说：“没问题,咱们以后都采用协商的通信密钥和加密算法进行加密通信了”，并且也发送 Encrypted Handshake Message 的消息试试。当双方握手结束之后，就可以通过对称密钥进行加密传输了。这个过程除了加密解密之外，其他的过程和 HTTP 是一样的，过程也非常复杂。上面的过程只包含了 HTTPS 的单向认证，也即客户端验证服务端的证书，是大部分的场景，也可以在更加严格安全要求的情况下，启用双向认证，双方互相验证证书。至此，我们已自下而上地打通了 HTTPS 加密的整个脉络以及核心知识点，不知你是否真正搞懂了 HTTPS 呢？","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"Socket编程模式","slug":"Network/Socket编程模式","date":"2020-10-24T07:11:19.000Z","updated":"2020-10-24T07:12:26.744Z","comments":true,"path":"2020/10/24/network/socket-bian-cheng-mo-shi/","link":"","permalink":"https://tianny.cc/2020/10/24/network/socket-bian-cheng-mo-shi/","excerpt":"","text":"Socket 编程模式的初步了解，皮毛阶段，仅作为记录参考，方便日后在深入研究。将项目外包给其他公司（多进程方式）这就相当于你是一个代理，在那里监听来的请求。一旦建立了一个连接，就会有一个已连接 Socket，这时候你可以创建一个子进程，然后将基于已连接Socket的交互交给这个新的子进程来做。就像来了一个新的项目，但是项目不一定是你自己做，可以再注册一家子公司，招点人，然后把项目转包给这家子公司做，以后对接就交给这家子公司了，你又可以去接新的项目了。这里有一个问题是，如何创建子公司，并如何将项目移交给子公司呢？在 Linux 下，创建子进程使用 fork 函数。通过名字可以看出，这是在父进程的基础上完全拷贝一个子进程。在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程。显然，复制的时候在调用 fork，复制完毕之后，父进程和子进程都会记录当前刚刚执行完 fork。这两个进程刚复制完的时候，几乎一模一样，只是根据 fork 的返回值来区分到底是父进程，还是子进程。如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。进程复制过程如下：因为复制了文件描述符列表，而文件描述符都是指向整个内核统一的打开文件列表的，因而父进程刚才因为 accept 创建的已连接 Socket 也是一个文件描述符，同样也会被子进程获得。接下来，子进程就可以通过这个已连接 Socket 和客户端进行互通了，当通信完毕之后，就可以退出进程，那父进程如何知道子进程干完了项目，要退出呢？还记得 fork 返回的时候，如果是整数就是父进程吗？这个整数就是子进程的 ID，父进程可以通过这个 ID 查看子进程是否完成项目，是否需要退出。将项目转包给独立的项目组（多线程方式）上面这种方式你应该也能发现问题，如果每次接一个项目，都申请一个新公司，然后干完了，就注销掉这个公司，实在是太麻烦了。毕竟一个新公司要有新公司的资产，有新的办公家具，每次都买了再卖，不划算。于是你应该想到了，我们可以使用线程。相比于进程来讲，这样要轻量级的多。如果创建进程相当于成立新公司，购买新办公家具，而创建线程，就相当于在同一个公司成立项目组。一个项目做完了，那这个项目组就可以解散，组成另外的项目组，办公家具可以共用。在 Linux 下，通过 pthread_create 创建一个线程，也是调用 do_fork。不同的是，虽然新的线程在 task 列表会新创建一项，但是很多资源，例如文件描述符列表、进程空间，还是共享的，只不过多了一个引用而已。新的线程也可以通过已连接 Socket 处理请求，从而达到并发处理的目的。上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程。一台机器无法创建很多进程或者线程。有个 C10K，它的意思是一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，那么操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器，成本也太高了。其实 C10K 问题就是，你接项目接的太多了，如果每个项目都成立单独的项目组，就要招聘 10 万人，你肯定养不起，那怎么办呢？方式三：一个项目组支撑多个项目（IO多路复用，一个线程维护多个Socket）当然，一个项目组可以看多个项目了。这个时候，每个项目组都应该有个项目进度墙，将自己组看的项目列在那里，然后每天通过项目墙看每个项目的进度，一旦某个项目有了进展，就派人去盯一下。由于 Socket 是文件描述符，因而某个线程盯的所有的 Socket，都放在一个文件描述符集合 fd_set 中，这就是项目进度墙，然后调用 select 函数来监听文件描述符集合是否有变化。一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的位都设为 1，表示 Socket 可读或者可写，从而可以进行读写操作，然后再调用 select，接着盯着下一轮的变化。方式四：一个项目组支撑多个项目（IO多路复用，从“派人盯着”到“有事通知”）上面 select 函数还是有问题的，因为每次 Socket 所在的文件描述符集合中有Socket 发生变化的时候，都需要通过轮询的方式，也就是需要将全部项目都过一遍的方式来查看进度，这大大影响了一个项目组能够支撑的最大的项目数量。如果改成事件通知的方式，情况就会好很多，项目组不需要通过轮询挨个盯着这些项目，而是当项目进度发生变化的时候，主动通知项目组，然后项目组再根据项目进展情况做相应的操作。能完成这件事情的函数叫 epoll，它在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数的方式，当某个文件描述符发送变化的时候，就会主动通知。如图所示，假设进程打开了 Socket m, n, x 等多个文件描述符，现在需要通过epoll 来监听是否这些 Socket 都有事件发生。其中 epoll_create 创建一个epoll 对象，也是一个文件，也对应一个文件描述符，同样也对应着打开文件列表中的一项。在这项里面有一个红黑树，在红黑树里，要保存这个 epoll 要监听的所有 Socket。当 epoll_ctl 添加一个 Socket的时候，其实是加入这个红黑树，同时红黑树里面的节点指向一个结构，将这个结构挂在被监听的 Socket 的事件列表中。当一个 Socket 来了一个事件的时候，可以从这个列表中得到 epoll 对象，并调用 call back 通知它。这种通知方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数。因而，epoll 被称为解决 C10K 问题的利器。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"},{"name":"Socket","slug":"Socket","permalink":"https://tianny.cc/tags/Socket/"}]},{"title":"基于TCP协议的Socket程序函数调用过程","slug":"Network/基于TCP协议的Socket程序函数调用过程","date":"2020-10-24T07:09:11.000Z","updated":"2020-10-24T07:13:21.516Z","comments":true,"path":"2020/10/24/network/ji-yu-tcp-xie-yi-de-socket-cheng-xu-han-shu-diao-yong-guo-cheng/","link":"","permalink":"https://tianny.cc/2020/10/24/network/ji-yu-tcp-xie-yi-de-socket-cheng-xu-han-shu-diao-yong-guo-cheng/","excerpt":"","text":"前面讲完了 TCP 和 UDP 协议，还没有上手过，这一节咱们讲讲基于 TCP 和 UDP 协议的 Socket 编程。在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而UDP 是基于数据报的，因而设置为 SOCK_DGRAM。TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。为什么需要端口呢？要知道，你写的是一个应用程序，当一个网络包来的时候，内核要通过 TCP 头里面的这个端口，来找到你这个应用程序，把包给你。为什么要 IP 地址呢？有时候，一台机器会有多个网卡，也就会有多个 IP 地址，你可以选择监听所有的网卡，也可以选择监听一个网卡，这样，只有发给这个网卡的包，才会给你。当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。这是一个经常考的知识点，就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听Socket，一个叫作已连接Socket。连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。下面一张图就是基于 TCP 协议的 Socket 程序函数调用过程。说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。在内核中，Socket 是一个文件，那对应就有文件描述符。每一个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符。文件描述符是一个整数，是这个数组的下标。这个数组中的内容是一个指针，指向内核中所有打开的文件的列表。既然是一个文件，就会有一个 inode，只不过 Socket 对应的 inode不像真正的文件系统一样，保存在硬盘上的，而是在内存中的。在这个 inode 中，指向了 Socket 在内核中的 Socket 结构。在这个结构里面，主要的是两个队列，一个是发送队列，一个是接收队列。在这两个队列里面保存的是一个缓存 sk_buff。这个缓存里面能够看到完整的包的结构。看到这个，是不是能和前面讲过的收发包的场景联系起来了？整个数据结构如图下：注：如果对进程与文件描述符这段描述不理解的同学，请参考下面一张图，便一目了然：","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"},{"name":"Socket","slug":"Socket","permalink":"https://tianny.cc/tags/Socket/"}]},{"title":"TCP面试系列慢开始与拥塞避免","slug":"Network/TCP面试系列慢开始与拥塞避免","date":"2020-10-24T07:08:38.000Z","updated":"2020-10-24T07:08:58.470Z","comments":true,"path":"2020/10/24/network/tcp-mian-shi-xi-lie-man-kai-shi-yu-yong-sai-bi-mian/","link":"","permalink":"https://tianny.cc/2020/10/24/network/tcp-mian-shi-xi-lie-man-kai-shi-yu-yong-sai-bi-mian/","excerpt":"","text":"TCP 面试系列第七弹，TCP 慢开始与拥塞避免。在讨论几种拥塞控制方法前，为了方便大家理解，我们假定：数据是单方向传送，而另一个方向只传送确认接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定拥塞窗口 cwnd (congestion window) 由发送方维持的一个状态变量。发送方让自己的发送窗口等于拥塞窗口。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方控制拥塞窗口的原则：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。下面从慢开始算法讨论，cwnd 是如何变化的。慢开始算法的核心思想：在事先不清楚网络的负荷情况下，由小到大逐渐增大拥塞窗口数值。在刚开始发送报文段时，先把拥塞窗口 cwnd 设置为最大报文段 MSS 的数值。之后在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个 MSS 的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd，从而使分组注入到网络的速率更加合理。如下图所示，每经过一个传输轮次（transmission round），拥塞窗口 cwnd 就加倍。经过上面的分析后，现在我们思考下，为什么叫慢开始，这个慢是指什么慢？慢开始的“慢”并不是指 cwnd 的增长速率慢，而是指在 TCP 开始发送报文段时先设置 cwnd = 1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大 cwnd。这当然比按照大的 cwnd 一下子把许多报文段突然注入到网络中要“慢得多”。慢开始有没有什么缺陷？或者没有考虑完善的情况？我们已经知道，拥塞窗口 cwnd 每经过一个传输轮次，拥塞窗口 cwnd 就加倍。如果拥塞窗口增长速率过大，也会带了网络拥塞。为了解决这个问题，还需要设置一个慢开始门限 ssthresh。慢开始门限 ssthresh 规则如下：当cwnd &lt; ssthresh时，使用上述的慢开始算法。当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。那么什么是拥塞避免算法？拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加1，而不是加倍。这样，拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。具体例子，如下图所示：慢开始和拥塞避免算法的实现举例记住，无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。根据上面的解释，分析一下图示曲线的走势情况：TCP 连接进行初始化时，把拥塞窗口 cwnd 置为 1。当执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1。以后发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1，然后开始下一轮的传输（请注意，图示的横坐标是传输轮次）。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。假定拥塞窗口的数值增长到 24 时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的 ssthresh 值变为 12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。当 cwnd = ssthresh = 12 时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个 MSS 的大小。对于上面的描述，我们可以概括为乘法减小和加法增大。“乘法减小”：指不论在慢开始阶段还是拥塞避免阶段，只要出现超时（即很可能出现了网络拥塞），就把慢开始门限值 ssthresh 减半，即设置为当前的拥塞窗口的一半（与此同时，执行慢开始算法）”加法增大”：是指执行拥塞避免算法后，使拥塞窗口缓慢增大。上面两种算法合起来就是我们常称的 AIMD 算法。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"TCP面试系列拥塞控制","slug":"Network/TCP面试系列拥塞控制","date":"2020-10-24T07:07:54.000Z","updated":"2020-10-24T07:08:25.022Z","comments":true,"path":"2020/10/24/network/tcp-mian-shi-xi-lie-yong-sai-kong-zhi/","link":"","permalink":"https://tianny.cc/2020/10/24/network/tcp-mian-shi-xi-lie-yong-sai-kong-zhi/","excerpt":"","text":"TCP 面试系列第六弹，TCP 拥塞控制的一般性原理。拥塞的定义。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞常常趋于恶化。举个例子，如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。为了针对上述拥塞带来的网络恶化情况，引入拥塞控制方法。如下图所示：横坐标是提供的负载（offered load），代表单位时间内输入给网络的分组数目纵坐标是吞吐量（throughput），代表单位时间内从网络输出的分组数目根据上图简要分析。理想网络情况下：在吞吐量饱和之前，网络吞吐量应等于提供的负载，故吞吐量曲线是 45° 的斜线。当提供的负载超过某一限度时，由于网络资源受限，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明提供的负载中有一部分损失掉了（例如，输入到网络的某些分组被某个结点丢弃了）。虽然如此，在这种理想的拥塞控制作用下，网络的吞吐量仍然维持在其所能达到的最大值实际网络情况下：随着提供的负载的增大，网络吞吐量的增长速率逐渐减小。也就是说，在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了。当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了轻度拥塞的状态当提供的负载达到某一数值时，网络的吞吐量反而随提供的负载的增大而下降，这时网络就进入了拥塞状态当提供的负载继续增大到某一数值时，网络的吞吐量就下降到零，网络已无法工作，进入到死锁状态。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"TCP面试系列滑动窗口","slug":"Network/TCP面试系列滑动窗口","date":"2020-10-24T07:07:20.000Z","updated":"2020-10-24T07:07:44.022Z","comments":true,"path":"2020/10/24/network/tcp-mian-shi-xi-lie-hua-dong-chuang-kou/","link":"","permalink":"https://tianny.cc/2020/10/24/network/tcp-mian-shi-xi-lie-hua-dong-chuang-kou/","excerpt":"","text":"TCP 面试系列第五弹，TCP 可靠传输实现之滑动窗口。现在我们假定 A 收到了 B 发来的确认报文段，其中窗口是 20（字节），而确认号是 31（这表明 B 期望收到的下一个序号是 31，且到序号 30 为止的数据已经收到了）。根据这两个数据，A 便构造出自己的发送窗口，如下图所示：]为了方便大家的理解，对照着上图，对一些概念进行阐述。（注意图中的后沿与前沿）发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。从图上很清晰地看出，发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间关于发送窗口后沿的可能变化：不动（没有收到新的确认）前移（收到了新的确认）关于发送窗口前沿的可能变化：向前移动。正常发送新的数据不动。原因可能是没有收到新的确认，对方的通知窗口大小也没变；收到了新的确认，但对方通知的窗口缩小了，刚刚好不动了解了滑动窗口的基本知识后，下面我们考虑更加滑动窗口一些常见的复杂情况。上图简要前置假设说明：A 发送了序号为 31～41 的数据。发送窗口内靠后面有 11 个字节（灰色小方框表示）表示已发送但未收到确认。发送窗口内靠前面的 9 个字节（42～50）是允许发送但尚未发送的。现在分析接收窗口 B：B 的接收窗口大小是 20。接收窗口内的序号（31～50）是允许接收的。在接收窗口外面，到 30 号为止的数据是已经发送过确认，并且已经交付主机了。因此在 B 可以不再保留这些数据。注意，重点来了，现在假设数据没有按序到达，即序号为 31 的数据没有收到（滞留在网络中的某处），也就是说 B 收到了序号为 32 和 33 的数据，却没有收到 31 的数据。这种情况下，B 发送的确认报文段中的确认号 ACK 仍然是 31（即期望收到的序号），而不是 32 或者 33。因为 B 只能对按序收到的数据中的最高序号给出确认。滑动窗口还有很多复杂的情况，帅天就不一一列举了。但是对于发送窗口、接收窗口和发送前沿和后沿是需要重点掌握的。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"TCP面试系列连续ARQ协议","slug":"Network/TCP面试系列连续ARQ协议","date":"2020-10-24T07:06:42.000Z","updated":"2020-10-24T07:07:08.188Z","comments":true,"path":"2020/10/24/network/tcp-mian-shi-xi-lie-lian-xu-arq-xie-yi/","link":"","permalink":"https://tianny.cc/2020/10/24/network/tcp-mian-shi-xi-lie-lian-xu-arq-xie-yi/","excerpt":"","text":"TCP 面试系列第四弹，可靠性传输之连续 ARQ 协议。先来看一张图示：上图（a），表示发送方维持的发送窗口。它的意义是：位于发送窗口内的 5 个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。图（b），有一个时间坐标（但以后往往省略这样的时间坐标）。按照习惯，“向前“是指向着时间增大的方向，而”向后“则是向着时间减少的方向。分组发送是按照分组序号从小到大发送。连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。图（b）表示发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组的位置。如果原来已经发送了前 5 个分组，那么现在就可以发送窗口内的第 6 个分组了。接收方一般都是采用累积确认的方式。也就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认。这就表示：到这个分组为止的所有分组都已正确收到了。累积确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。例如，如果发送方发送了前 5 个分组，而第 3 个分组丢失了。此时接收方只能对前两个分组发出确认，因为接收方只能对按需到达的最后一个分组发送确认。发送方无法知道后面三个分组的下落，只好把后面的三个分组都再重传一次。这就叫做Go-back-N（回退N），表示需要再退回来重传已发送过的 N 个分组。可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"TCP面试系列停止等待协议","slug":"Network/TCP面试系列停止等待协议","date":"2020-10-24T07:05:40.000Z","updated":"2020-10-24T07:06:05.595Z","comments":true,"path":"2020/10/24/network/tcp-mian-shi-xi-lie-ting-zhi-deng-dai-xie-yi/","link":"","permalink":"https://tianny.cc/2020/10/24/network/tcp-mian-shi-xi-lie-ting-zhi-deng-dai-xie-yi/","excerpt":"","text":"TCP 面试系列第三弹，可靠性传输之停止等待协议。我们知道，理想的传输条件有以下两个特点：传输信道不产生差错。不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。然而实际的网络都不具备以上两个理想条件。但我们可以使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。这样一来，本来是不可靠的传输信道就能够实现可靠传输了。下面从最简单的停止等待协议讲起。停止等待协议因为全双工通信的双方既是发送方也是接收方，下面为了讨论问题的方便，我们仅考虑 A 发送数据而 B 接收数据并发送确认。因此 A 叫做发送方，而 B 叫做接收方。这里是讨论可靠传输的原理，因此把传送的数据单元都称为分组，而并不考虑数据是在哪一个层次上传送的。“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。如上图（a）所示，表示无差错情况下：A 发送分组 M1，发完就暂停发送，等待 B 的确认。B 收到了M1就向 A 发送确认。A 在收到了对 M1的确认后，就再发送下一个分组 M2。同样，在收到 B 对 M2 的确认后，再发送 M3。如上图 （b）所示，是传输过程中出现了差错的情况下的超时重传机制。出现差错分为两种：M1在传输的过程中丢失了B 接收 M1 时检测出了差错，直接丢弃 M1上面两种情况下，B 都不会发送任何消息给 A。为了解决上述场景遇到的问题，可靠传输协议是这样设计的：A 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做超时重传。要实现超时重传，就要在每发送完一个分组设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。下面再考虑两种更负载的情况，确认丢失和确认迟到。确认丢失。如上图中的（a）所示，假设 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内没有收到确认。原因有很多，可能是 A 自己发送的分组出错、丢失，或者是 B 发送的确认丢失了。 因此 A 在超时计时器到期后就要重传 M1。现在应注意 B 的动作。假定 B 又收到了重传的分组 M1。这时应采取两个行动：丢弃这个重复的分组 M1，不向上层交付向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1就表示 A 没有收到对 M1 的确认确认迟到。如上图（b）所示，假设传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。A 会收到重复的确认。 对重复的确认的处理很简单：收下后就丢弃。 B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"TCP面试系列四次挥手","slug":"Network/TCP面试系列四次挥手","date":"2020-10-24T07:04:59.000Z","updated":"2020-10-24T07:05:21.386Z","comments":true,"path":"2020/10/24/network/tcp-mian-shi-xi-lie-si-ci-hui-shou/","link":"","permalink":"https://tianny.cc/2020/10/24/network/tcp-mian-shi-xi-lie-si-ci-hui-shou/","excerpt":"","text":"TCP 面试系列第二弹，四次挥手。如下图所示（左边是 Client， 右边是 Server）：最初 A 和 B 都处于 ESTABLISHED 状态。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = p，它等于前面已传送过的数据的最后一个字节的序号加 1。这时 A 进入 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认。B 收到连接释放报文段后即发出确认，确认号是 ack = p + 1，而这个报文段自己的序号是 seq=v，等于 B 前面已传送过的数据的最后一个字节的序号加 1。此时 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，从 A 到 B 这个方向的连接释放了，此时处于半关闭 (half-close) 状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一些时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2（终止等待 2）状态，等待 B 发出的连接释放报文段若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。现假定 B 的序号为 q（在半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack =p + 1。这时 B 就进入 LAST-ACK（最后确认）状态，等待 A 的确认A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置1，确认号 ack = q + 1，而自己的序号是 seq = p + 1。然后进入到TIME-WAIT（时间等待）状态。现在 TCP 连接还没有释放掉。必须经过时间等待计时器 (TIME-WAIT timer) 设置的时间 2MSL 后，A才 进入到 CLOSED 状态。上面就是 TCP 四次挥手的整个过程。为了加深大家的理解，帅天这里再提出个问题：为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间 ？一句话总结就是，为了保证 A 发送的最后一个 ACK 报文段能够到达 B，让 B 成功处于 CLOSED状态。假设 A 发送给 B 的最后一段 ACK 确认报文可能丢失，导致 B 没有收到 A 发送的最后一段 ACK 报文，于是 B 会超时重传 FIN + ACK 报文段，而 A 就能在2MSL 时间内收到这个重传的 FIN + ACK 报文段，再次重传最后一段 ACK 报文。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，如果发送的 ACK 报文段丢失了，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入 CLOSED 状态。下面一章帅天将为大家带来 TCP 面试系列第三弹之停止等待协议，敬请关注。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"TCP面试系列三次握手","slug":"Network/TCP面试系列三次握手","date":"2020-10-24T07:04:28.000Z","updated":"2020-10-24T07:04:47.308Z","comments":true,"path":"2020/10/24/network/tcp-mian-shi-xi-lie-san-ci-wo-shou/","link":"","permalink":"https://tianny.cc/2020/10/24/network/tcp-mian-shi-xi-lie-san-ci-wo-shou/","excerpt":"","text":"因为这是 TCP 面试系列的第一篇文章，为了让大家奠定好基础，帅天先简单聊聊 TCP 本身的结构。TCP 包头格式我们先来看 TCP 头的格式。从下面这个图可以看出，它比 UDP 复杂得多。可以看到，除了源端口和目的端口，还多了包的序号、确认序号以及状态位和窗口大小等字段。先不用过于深究，这些字段的作用在 TCP 面试系列的文章中都会解释到。要想掌握 TCP 协议，帅天给大家总结了一份口诀：顺序问题 ，稳重不乱；丢包问题，承诺靠谱；连接维护，有始有终；流量控制，把握分寸；拥塞控制，知进知退。三次握手接下来，上今天主菜，TCP 三次握手。先看一张，Server 端和 Client 端双方的状态变化时序图（左边是 Client A，右边是 Server B）：假定主机 A 运行的是 TCP 客户程序，而 B 运行 TCP 服务器程序。最初两端的 TCP 进程都处于 CLOSED（关闭）状态。A 向 B 发出连接请求报文段，这时报文段首部中的同步位 SYN = 1，同时选择一个初始序号 seq = x。这时，A 进入 SYN-SENT（同步已发送）状态。B 收到连接请求报文段后，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。A 收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。这就是 TCP 三次握手的过程，只要弄清楚 SYN 和 ACK 状态位的变化以及发送序号和接收序号的关系，便能掌握了。很简单对不对？为什么需要三次握手，而不是两次握手为了检验大家掌握了没有，请回答下面的问题：为什么需要三次握手，而不是两次握手 ？一句话总结就是，为了解决网络中存在延迟的重复分组导致服务端资源浪费问题。我们假设 Client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 Server。本来这是一个早已失效的报文段。但 Server 收到此失效的连接请求报文段后，就误认为是 Client 再次发出的一个新的连接请求。于是就向 Client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 Server 发出确认，新的连接就建立了。由于现在 Client 并没有发出建立连接的请求，因此不会理睬 Server 的确认，也不会向 Server 发送数据。但 Server 却以为新的运输连接已经建立，并一直等待 Client 发来数据。这样，Server 的很多资源就白白浪费掉了。小结下面一章帅天将为大家带来 TCP 面试系列第二弹之四次挥手，敬请关注。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"UDP协议","slug":"Network/UDP协议","date":"2020-10-24T07:03:45.000Z","updated":"2020-10-24T07:04:06.757Z","comments":true,"path":"2020/10/24/network/udp-xie-yi/","link":"","permalink":"https://tianny.cc/2020/10/24/network/udp-xie-yi/","excerpt":"","text":"为什么叫最简单的 UDP 协议，因为相比 TCP 协议，UDP 协议的工作原理简直无脑了太多。介绍UDP 全称 User Datagram Protocol，即用户数据报协议。UDP 与 TCP 对比UDP 和 TCP 经常被拿来比较两者之前的区别。TCP 是面向连接的，UDP是面向无连接的，大部分在面试的时候都会这么答。那么请问，什么是建立连接？所谓建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。例如，TCP 是提供可靠交付。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。但是 UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。再如，TCP 是面向字节流的。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而 UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收。TCP 是可以有拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP 就不会，应用让我发，我就发，其他我烦不了。为什么 UDP 这么无脑呢？来看看 UDP 包头是啥样的。当我们看到 UDP 包头的时候，发现的确有端口号，有源端口号和目标端口号。同时 UDP 除了端口号，再没有其他的了。就是这么简单。使用场景所以 UDP 有以下几大使用场景：第一，需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。第二，不需要一对一沟通，建立连接，而是可以广播的应用，比如 DHCP 协议就是基于 UDP 协议的。第三，需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。比如现在很火的网红直播带货。UDP 的介绍就到这里，下面一章会重点介绍 TCP 协议。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"路由协议","slug":"Network/路由协议","date":"2020-10-24T07:03:07.000Z","updated":"2020-10-24T07:03:31.045Z","comments":true,"path":"2020/10/24/network/lu-you-xie-yi/","link":"","permalink":"https://tianny.cc/2020/10/24/network/lu-you-xie-yi/","excerpt":"","text":"这篇文章简单的聊聊路由协议，注意这里是简单，路由协议太复杂，了解一下即可。我们在大学里面学习计算机网络与数据结构的时候,知道求最短路径常用的有两种方法，一种是 Bellman-Ford 算法，一种是 Dijkstra 算法。在计算机网络中基本也是用这两种方法计算的。距离矢量路由距离矢量路由算法，基于 Bellman-Ford 算法。有以下几个特征：好消息传的快，坏消息传的慢。如果有个路由器加入了这个网络，它的邻居就能很快发现它,然后将消息广播出去。要不了多久,整个网络就都知道了。但是一旦一个路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候,感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了。比如某个人走丢了，问了一圈儿亲戚朋友才确定没看到你，才确定人丢了，这时候才报警，太慢了。每次发送的时候,要发送整个全局路由表。网络大了，谁也受不了。它适用于小型网络（小于 15 跳）。链路状态路由链路状态路由（link state routing），基于 Dijkstra 算法，典型代表 OSPF 协议。这种算法的基本思路是，当一个路由器启动的时候，首先是发现邻居，向邻居say hello，邻居都回复。并计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而,每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径。不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，省了路由器带宽和 CPU 利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。距离矢量路由基于距离矢量路由算法的 BGP。BGP 协议使用的算法是路径矢量路由协议（path-vector protocol）。它是距离矢量路由协议的升级版。一般用于运营商之间的大型网络。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"网关","slug":"Network/网关","date":"2020-10-24T07:02:32.000Z","updated":"2020-10-24T07:02:56.276Z","comments":true,"path":"2020/10/24/network/wang-guan/","link":"","permalink":"https://tianny.cc/2020/10/24/network/wang-guan/","excerpt":"","text":"古有关圣爷过五关斩六将，今有小小网络包过网关闯世界。今天帅天给大家剖析一下，从局域网发出的网络包是如何跋山涉水到达外面的世界的。如何到达网关在任何一台机器上，当要访问另一个 IP 地址的时候，都会先判断，这个目标 IP地址，和当前机器的 IP 地址，是否在同一个网段。怎么判断同一个网段呢？需要 CIDR 和子网掩码。（关于 CIDR 和 子网掩码的知识请看帅天之前写的文章）如果是同一个网段，那就不需要通过网关，直接在局域网内部通信，将源地址和目标地址放入 IP 头中，然后通过 ARP 获得 MAC 地址，将源 MAC 和目的 MAC 放入 MAC 头中，发出去就可以了。如果不是同一网段，比如访问淘宝，这就需要发往默认网关 Gateway。Gateway 的地址一定是和源 IP 地址是一个网段的。一般都是第一个，例如192.168.1.0/24 这个网段，Gateway 往往会是 192.168.1.1/24。如何发往默认网关呢？因为网关和源 IP 肯定是同一个网段的，将源地址和目标 IP 地址放入 IP 头中，通过 ARP 获得网关的 MAC 地址，将源 MAC 和网关的 MAC 放入 MAC头 中，发送出去。这和局域网内部通信方式一样。网关所在的端口，例如 192.168.1.1/24 将网络包收进来，然后接下来怎么做，就完全看网关的了。网关如何转发网关转发 IP 包的过程中，可能会对网络包中的 IP 头 和 MAC 头进行修改。具体是如何操作的呢？请看下面两个例子。第一个例子，IP 头始终保持不变。在整个过程中，IP 头里面的地址都是不变的。IP 地址在三个局域网都可见，在三个局域网之间的网段都不会冲突。在三个网段之间传输包，IP 头不改变。如下图所示：服务器 A 要访问服务器 B。首先，服务器 A 会思考，192.168.4.101和我不是一个网段的，因而需要先发给网关。那网关是谁呢？已经静态配置好了，网关是 192.168.1.1。网关的 MAC 地址是多少呢？发送 ARP 获取网关的 MAC 地址，然后发送包。包的内容是这样的：源 MAC：服务器 A 的 MAC目标 MAC：192.168.1.1 这个网口的 MAC源 IP：192.168.1.101目标 IP：192.168.4.101包到达 192.168.1.1这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。在路由器 A 中配置了静态路由之后，要想访问 192.168.4.0/24，要从192.168.56.1 这个口出去，下一跳为 192.168.56.2。于是，路由器 A 思考的时候，匹配上了这条路由，要从 192.168.56.1 这个口发出去，发给 192.168.56.2，那 192.168.56.2 的 MAC 地址是多少呢？路由器 A 发送 ARP 获取 192.168.56.2 的 MAC 地址，然后发送包。包的内容是这样的：源 MAC：192.168.56.1的 MAC 地址目标 MAC：192.168.56.2的 MAC 地址源 IP：192.168.1.101目标 IP：192.168.4.101包到达 192.168.56.2 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。在路由器 B 中配置了静态路由，要想访问 192.168.4.0/24，要从 192.168.4.1 这个口出去，没有下一跳了。因为我右手这个网卡，就是这个网段的，我是最后一跳了。于是，路由器 B 思考的时候，匹配上了这条路由，要从 192.168.4.1 这个口发出去，发给 192.168.4.101。那 192.168.4.101 的 MAC 地址是多少呢？路由器 B 发送 ARP 获取 192.168.4.101 的 MAC 地址，然后发送包。包的内容是这样的：源 MAC：192.168.4.1 的 MAC 地址目标 MAC：192.168.4.101 的 MAC 地址源 IP：192.168.1.101目标 IP：192.168.4.101包到达服务器 B，MAC 地址匹配，将包收进来。通过这个过程可以看出，每到一个新的局域网，MAC 都是要变的，但是 IP 地址都不变。在 IP 头里面，不会保存任何网关的 IP 地址。第二个例子，IP 头会变。看下图，服务器 A 想访问服务器 B，但是细心的同学可能已经发现和上面的例子不同之处在于，服务器 A 的地址和 服务器 B 的 地址是相同的（不同局域网内）。怎么解决这个问题呢？既然局域网之间没有商量过，各管各的 IP 分配，那到国际上，就需要使用另外的地址。打个比方，就像出国，仅仅使用国内的身份证是不行的，必须得使用护照。首先，目标服务器 B 在国际上要有一个国际的身份，我们给它一个192.168.56.2。在网关 B 上，我们记下来，国际身份 192.168.56.2 对应国内身份 192.168.1.101。凡是要访问 192.168.56.2，都转成 192.168.1.101。于是，源服务器 A 要访问目标服务器 B，要指定的目标地址为 192.168.56.2。这是它的国际身份。服务器 A 想，192.168.56.2 和我不是一个网段的，因而需要发给网关，网关是谁？已经静态配置好了，网关是 192.168.1.1，网关的MAC 地址是多少？发送 ARP 获取网关的 MAC 地址，然后发送包。包的内容是这样的：源 MAC：服务器 A 的 MAC目标 MAC：192.168.1.1 这个网口的 MAC源 IP：192.168.1.101目标 IP：192.168.56.2包到达 192.168.1.1 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。在路由器A中配置了静态路由：要想访问 192.168.56.2/24，要从192.168.56.1 这个口出去，没有下一跳了，因为我右手这个网卡，就是这个网段的，我是最后一跳了。于是，路由器 A 思考的时候，匹配上了这条路由，要从 192.168.56.1 这个口发出去，发给 192.168.56.2。那 192.168.56.2 的 MAC 地址是多少呢？路由器 A 发送 ARP 获取 192.168.56.2 的 MAC 地址。当网络包发送到中间的局域网的时候，服务器 A 也需要有个国际身份，因而在国际上，源 IP 地址也不能用 192.168.1.101，需要改成 192.168.56.1。发送包的内容是这样的：源 MAC：192.168.56.1 的 MAC 地址目标 MAC：192.168.56.2 的 MAC 地址源 IP：192.168.56.1目标 IP：192.168.56.2包到达 192.168.56.2 这个网口，发现 MAC 一致，将包收进来，开始思考往哪里转发。路由器 B 是一个 NAT 网关，它上面配置了，要访问国际身份 192.168.56.2 对应国内身份 192.168.1.101，于是改为访问 192.168.1.101。在路由器 B 中配置了静态路由：要想访问 192.168.1.0/24，要从 192.168.1.1 这个口出去，没有下一跳了，因为我右手这个网卡，就是这个网段的，我是最后一跳了。于是，路由器 B 思考的时候，匹配上了这条路由，要从 192.168.1.1 这个口发出去，发给 192.168.1.101。那 192.168.1.101 的 MAC 地址是多少呢？路由器 B 发送 ARP 获取192.168.1.101 的 MAC 地址，然后发送包。内容是这样的：源 MAC：192.168.1.1 的 MAC 地址目标 MAC：192.168.1.101 的 MAC 地址源 IP：192.168.56.1目标 IP：192.168.1.101包到达服务器 B，MAC 地址匹配，将包收进来。从服务器 B 接收的包可以看出，源 IP 为服务器 A 的国际身份，因而发送返回包的时候，也发给这个国际身份，由路由器 A 做 NAT，转换为国内身份。从这个过程可以看出， IP 地址也会变。这个就是Network Address Translation，简称NAT。小结本节描述了网络包经由网关转发的过程，重点阐述了 NAT 场景下 IP 包头部的变化，对网络包经由网关的动作做了详细的拆解，给大家一个深刻感性的认知，方便记忆与理解。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"Ping与Traceroute","slug":"Network/Ping与Traceroute","date":"2020-10-24T07:01:55.000Z","updated":"2020-10-24T07:02:22.307Z","comments":true,"path":"2020/10/24/network/ping-yu-traceroute/","link":"","permalink":"https://tianny.cc/2020/10/24/network/ping-yu-traceroute/","excerpt":"","text":"周末了，又到了跟大家聊聊网络知识的时候了。这次帅天跟大家聊聊网络出错排查过程中常使用的命令和工具。想象一下以下场景，上网上的好好的，突然告诉你链接断开，大家第一反应是啥？帅天首先要夸奖那些能够使用 Ping 或者 Traceroute 的小伙伴，毕竟能把自己的专业知识运用到实际生活中，但是如果只知道如何使用，而不知道这两个工具的工作原理，那么帅天只能给 9 分了（此处@热火名宿韦德）。下面帅天就来给大家聊聊 Ping 与 Traceroute 的实现原理，ICMP 协议。ICMP 协议ICMP 全称 Internet Control Message Protocol，就是互联网控制报文协议。ICMP 报文是封装在 IP 包里面的，因为传输指令的时候，肯定需要源地址和目标地址。ICMP 报文有很多的类型，主要分为两类，查询报文类型和差错报文类型。查询报文类型简单来说就是查询方主动发送侦查协议，等待对方的应答。具体例子，见下面 ping 的使用差错报文类型会使用 ICMP 的规则，故意制造一些能够产生错误的场景，从而达到网络诊断的目的。具体例子，见下面 traceroute 的使用。Ping 的使用ping 的发送和接收过程，如下图所示：假定主机 A 的 IP 地址是 192.168.1.1，主机 B 的 IP 地址是 192.168.1.2，它们都在同一个子网。那当你在主机A上运行 “ping 192.168.1.2” 后，会发生什么呢?ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为 8；另外一个是顺序号，主要用于区分连续ping的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为目的地址，本机 IP 地址作为源地址，加上一些其他控制信息，构建一个 IP 数据包。接下来，需要加入 MAC 头。如果在本节 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。主机 B 会构建一个 ICMP 应答包，应答数据包的类型字段为 0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机 A。在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。这个过程后面几节会详细描述，这里暂时不多说。如果在自己的可控范围之内，当遇到网络不通的问题的时候，除了直接 ping 目标的 IP 地址之外，还应该有一个清晰的网络拓扑图。并且从理论上来讲，应该要清楚地知道一个网络包从源地址到目标地址都需要经过哪些设备，然后逐个 ping 中间的这些设备或者机器。如果可能的话，在这些关键点，通过tcpdump -i eth0 icmp，查看包有没有到达某个点，回复的包到达了哪个点，可以更加容易推断出错的位置。经常会遇到一个问题，如果不在我们的控制范围内，很多中间设备都是禁止 ping 的，但是 ping 不通不代表网络不通。这个时候就要使用 telnet，通过其他协议来测试网络是否通，这个就不在本篇的讲述范围了。说了这么多，我们可以看出 ping 这个程序是使用了 ICMP 里面的 ECHO REQUEST 和 ECHO REPLY 类型的。Traceroute 使用前面我们提到，差错报文类型会使用 ICMP 规则故意制造一些能够产生错误的场景。常见的错误场景有以下几个：终点不可达：网络不可达、主机不可达、协议不可达、端口不可达、需要进行分片但设置了不分片位源站抑制时间超时路由重定向Traceroute 故意制造上面常见错误中的一些场景，以达到诊断网络的目的。Traceroute 故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的IP地址，它会发送一个 UDP 的数据包。将 TTL 设置成1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了，于是，返回一个ICMP包，也就是网络差错包，类型是时间超时。接下来将将 TTL 设置为 2，第一关过了第二关又“牺牲了”，依次类推，直到到达目的主机。这样，Traceroute 就拿到了所有的路由器 IP。当然，有的路由器压根不会回这个 ICMP。这也是 Traceroute一个公网的地址，看不到中间路由的原因。那又是怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000 ）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时。小结Ping 与 Traceroute 是大家平时最常用的命令，这篇文章较为详细的解释了它们的工作原理，并引出了 ICMP 协议。有些公司在面试的时候可能会问的比较深，希望这篇文章能帮到到家。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"交换机与VLAN","slug":"Network/交换机与VLAN","date":"2020-10-24T07:01:13.000Z","updated":"2020-10-24T07:01:41.651Z","comments":true,"path":"2020/10/24/network/jiao-huan-ji-yu-vlan/","link":"","permalink":"https://tianny.cc/2020/10/24/network/jiao-huan-ji-yu-vlan/","excerpt":"","text":"最近有几个学生粉丝后台私信我，让我说说交换机与 VLAN。我在阅读这几个粉丝私信中发现一个有趣的现象，那就是吐槽大学计算机网络课程的晦涩枯燥，而不是去深层次解释协议出现的原因或者用来去解决什么问题。帅天今天就和大家聊聊交换机与 VLAN 到底是为何而来，是为了解决什么问题而出现的。在说这个之前，大家首先可以想想前一章提到的 Hub 集线器，仔细的思考一下 Hub 有什么巨大的缺点？Hub 的问题使用 Hub 这种组网的方法，一旦机器数目增多，问题就出现了。因为 Hub 是广播的，不管某个接口是否需要，所有的 Bit 都会被发送出去，然后让主机来判断是不是需要。这种方式路上的车少就没问题，车一多，产生冲突的概率就提高了。而且把不需要的包转发过去，纯属浪费。看来 Hub 这种不管三七二十一都转发的设备是不行了，需要点儿智能的。因为每个口都只连接一台电脑,，这台电脑又不怎么换 IP 和 MAC 地址，只要记住这台电脑的 MAC 地址，如果目标 MAC 地址不是这台电脑的，这个口就不用转发了。交换机工作原理二层交换机的出现就是为了解决这个问题。我们结合下图看一下二层交换机的工作原理：如上图所示，两台交换机连接着三个局域网，每个局域网上都有多台机器。如果机器 1 只知道机器 4 的 IP 地址，当它想要访问机器 4，把包发出去的时候，它必须要知道机器 4 的 MAC 地址。机器 1 发起广播，机器 2 收到这个广播，但是这不是找它的，所以没它什么事。交换机 A 一开始是不知道任何拓扑信息的，在它收到这个广播后，采取的策略是，除了广播包来的方向外，它还要转发给其他所有的网口。于是机器 3 也收到广播信息了，但是这和它也没什么关系。交换机 B 也是能够收到广播信息的，但是这时候它也是不知道任何拓扑信息的，因而也是进行广播的策略，将包转发到局域网三。这个时候，机器 4 和机器 5 都收到了广播信息。机器 4 主动响应说，这是找我的，这是我的 MAC 地址。于是一个 ARP 请求就成功完成了。在上面的过程中，交换机 A 和交换机 B 都是能够学习到这样的信息：机器 1 是在左边这个网口的。当了解到这些拓扑信息之后，交换机会维持一个转发表，用来记录。当机器 2 要访问机器 1 的时候，机器 2 并不知道机器 1 的 MAC 地址，所以机器 2 会发起一个 ARP 请求。这个广播消息会到达机器 1，也同时会到达交换机 A。根据之前记录的转发表信息，这个时候交换机 A 已经知道机器 1 是不可能在右边的网口的，所以这个广播信息就不会广播到局域网二和局域网三。当机器 3 要访问机器 1 的时候，也需要发起一个广播的 ARP 请求。这个时候交换机 A 和交换机 B 都能够收到这个广播请求。交换机 A 当然知道机器 1 是在左边这个网口的，所以会把广播消息转发到局域网一。同时，交换机 B 收到这个广播消息之后，由于它知道机器 1 是不在右边这个网口的，所以不会将消息广播到局域网三。当交换机作为一个关卡一样，过了一段时间之后。就有了整个网络的一个结构了。这个时候,基本上不用广播了。全部可以准确转发。当然，每个机器的 IP 地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为转发表，是有一个过期时间的。交换机环路问题随着办公室越来越大，交换机数目肯定越来越多。当整个拓扑结构复杂了，这么多网线，绕过来绕过去，不可避免地会出现一些意料不到的情况。其中常见的问题就是环路问题。看下面一张图，当两个交换机将两个局域网同时连接起来的时候。你可能会觉得，这样反而有了高可用性。但是却不幸地出现了环路。出现了环路会有什么结果呢？我们再想象一下机器 1 访问机器 2 的过程。一开始，机器 1 并不知道机器 2 的 MAC 地址，所以它需要发起一个 ARP 的广播。广播到达机器 2，机器 2 会把 MAC 地址返回来，看起来没有这两个交换机什么事情。但是问题来了，这两个交换机还是都能够收到广播包的。交换机 A 一开始是不知道机器 2 在哪个局域网的，所以它会把广播消息放到局域网二，在局域网二广播的时候，交换机 B 右边这个网口也是能够收到广播消息的。交换机 B 会将这个广播息信息发送到局域网一。局域网一的这个广播消息，又会到达交换机 A 左边的这个接口。交换机 A 这个时候还是不知道机器 2 在哪个局域网，于是将广播包又转发到局域网二。左转左转左转，好像是个圈哦。每台机器都会发广播包，交换机转发也会复制广播包，当广播包越来越多的时候，按照上一节讲过一个共享道路的算法，也就是路会越来越堵，最后谁也别想走。所以，必须有一个方法解决环路的问题，怎么破除环路呢？在计算机网络中，有一种协议叫 STP ，它就是为解决交换机环路问题而设计的。我们知道，在数据结构中，有一个方法叫作最小生成树。有环的我们常称为图。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作STP，全称Spanning Tree Protocol。可以简单理解为，通过比较权重大小从多个交换机中选举出五岳盟主的方式。为了给大家一个感性的认知，可以看下图，通过 STP 算法，网络拓扑最终形成了类似的树结构。STP 选举过程比较复杂，不是专门从事网络工程师的童鞋理解只需了解即可。交换机的安全问题和广播问题一般几千人的公司，部门很多，人也很多，机器多了，交换机也多了，就算交换机比 Hub 智能一些，但是还是难免有广播的问题。同时，公司有一些部门是需要保密的部门，比如财务部。由于在同一个广播域里面，很多包都会在一个局域网里面飘啊飘，碰到了一个会抓包的程序员，就能抓到这些包，如果没有加密，就能看到这些敏感信息了。为了解决这问题，我们可以使用虚拟隔离技术，也就是常说的 VALN，或者叫虚拟局域网。使用 VLAN，一个交换机上会连属于多个局域网的机器，那交换机怎么区分哪个机器属于哪个局域网呢？如上图所示，我们只需要在原来的二层的头上加一个 TAG，里面有一个十二位的 VLAN ID。如果我们买的交换机是支持 VLAN 的，当这个交换机把二层的头取下来的时候，就能够识别这个 VLAN ID。这样只有相同 VLAN 的包，才会互相转发，不同 VLAN 的包，是看不到的。这样广播问题和安全问题就都能够解决了。有人会问交换机之间怎么连接呢？将两个交换机连接起来的口应该设置成什么VLAN 呢？对于支持 VLAN 的交换机，有一种口叫作 Trunk。它可以转发属于任何 VLAN 的口。交换机之间可以通过这种口相互连接。总结这一章先从 Hub 转发任何数据包带来的效率极低情况出发，引出了交换机。交换机有一张转发表用来提高寻址的效率。接着指出交换机存在的环路问题，并提出了 STP 生成树协议的解决方案。最后为了解决交换机的安全问题，介绍了 VLAN 虚拟局域网技术。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"MAC协议","slug":"Network/MAC协议","date":"2020-10-24T07:00:28.000Z","updated":"2020-10-24T07:00:55.291Z","comments":true,"path":"2020/10/24/network/mac-xie-yi/","link":"","permalink":"https://tianny.cc/2020/10/24/network/mac-xie-yi/","excerpt":"","text":"上一章我们聊到了网络地址、子网掩码、和广播地址如何计算的问题，这一章节我们来进行一次深潜，聊聊 MAC 层的那些事。Hub 集线器相信不少读者在大学时代都联机打过游戏，最简单的方法是直接将一根网线连接两台电脑，便形成了一个小型局域网。光两个人玩 CS 不过瘾，宿舍里的其他小伙伴都想加入，此时该怎么办？别急，有办法，大家众筹买个 Hub 集线器就可以了，这样组网也就成功了。有人可能会问 Hub 是什么？Hub 叫集线器，是我们上学时那个年代的东西。 集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。但是光这样还不够，这仅仅是第一层物理层联通的方案。Hub 采取的是广播的模式，如果每一台电脑发出的包，宿舍的每个电脑都能收到，那就麻烦了。所以这就需要解决几个问题：这个包是发给谁的？谁应该接收？大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？如果发送的时候出现了错误，怎么办？MAC 层上面的问题就是数据链路层，即 MAC 层要解决的问题。MAC 的全称是 Medium Access Control，即媒体访问控制。控制的就是在往媒体上发数据的时候，谁先发、谁后发的问题。也就是上面的第二个问题。这个问题中的规则学名就叫做多路访问。多路访问的控制规则有很多，比如：方式一：分多个车道。每个车一个车道，你走你的，我走我的。这在计算机网络里叫作信道划分；方式二：今天单号出行，明天双号出行，轮着来。这在计算机网络里叫作轮流协议；方式三：不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作随机接入协议。著名的以太网，用的就是这个方式。ARP 协议接下来要解决第一个问题，这里要用到一个物理地址，叫链路层地址。因为第二层主要解决媒体接入控制的问题，所以它常被称为 MAC 地址。这里又引入另一个问题，一个广播的网络里面接入了 N 台机器，怎么知道每个 MAC 地址是谁呢？这就是 ARP 协议。也就是已知 IP 地址，求 MAC 地址的协议。下面看两张图，详细解释了 ARP 协议的工作原理：在一个局域网里面，当知道了IP地址，不知道MAC怎么办呢？靠“吼”。广而告之，发送一个广播包，谁是这个 IP 谁来回答。具体询问和回答的报文就像下面这样：为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。CRC 冗余校验码对于第三个问题，让我们回归到二层的数据包格式。对于以太网，看下图：除了最开始的目标的 MAC 地址和源的 MAC 地址。还有最后一个 CRC 字段，也就是循环冗余检测。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误。第三个问题也就迎刃而解。总结这一章我们从学生时代的宿舍联机游戏引入了 MAC 层，介绍了什么是 MAC 层，并顺带提出了 MAC 层所结局的三个核心问题，并依次对三个抛出的问题进行了解答。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"子网计算","slug":"Network/子网计算","date":"2020-10-24T06:59:45.000Z","updated":"2020-10-24T07:00:14.497Z","comments":true,"path":"2020/10/24/network/zi-wang-ji-suan/","link":"","permalink":"https://tianny.cc/2020/10/24/network/zi-wang-ji-suan/","excerpt":"","text":"在讲这篇知识点之前，大家先回顾下 IP 地址分类的知识。随着技术的发展，组网的方式也越来越丰富，因此传统 A、B、C 类的 IP 分类方法已经过时了。为了满足人们的需求，引入了 CIDR 记法。什么是 CIDR 记法呢？CIDR 将 32 位的 IP 地址一分为二，前面是网络号，后面是主机号。我们以 192.168.1.53/27 为例，斜杠后面有个数字 27。这种地址表示形式，就是 CIDR。后面 27 的意思是，32 位中，前 27 位是网络号，后 5 位是主机号。子网掩码子网掩码：将网络号全部置 1.我们知道 192.168.x.x，按照传统的 IP 分类的话属于 C 类网络。C 类网络默认掩码只有 24 位。但是 /27 显然多出了 3 位，多出的 3 位从哪里来？就需要从主机位借位。转换为二进制，如下图所示：网络地址网络地址：IP 地址 &amp; 子网掩码广播地址广播地址：将网络地址右边的表示主机位的部分全部置 1So，就是这么简单，新技能 Get。下一节我们将沿着从物理层到数据链路层这条线，体验新的网络之旅。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"子网划分","slug":"Network/子网划分","date":"2020-10-24T06:58:06.000Z","updated":"2020-10-24T06:59:14.066Z","comments":true,"path":"2020/10/24/network/zi-wang-hua-fen/","link":"","permalink":"https://tianny.cc/2020/10/24/network/zi-wang-hua-fen/","excerpt":"","text":"前面一章我们提到随着互联网的飞速发展，网络终端数呈爆炸式增长。最初的 IP 地址分类方式已经不再适用。为了解决日益增长的 IP 地址数需求，子网划分呼之欲出。背景最初的两级 IP 地址划分存在许多问题。最典型问题是，两级 IP 地址不够灵活。设想，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到因特网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位的网络，而不必事先到因特网管理机构去申请新的网络号。原来的两级 IP 地址是无法做到这一点的。为解决上述问题，从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级 IP 地址变成为三级 IP 地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法就叫作划分子网。划分原理万变不离其宗：划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。三个特点：对外仍然表现为一个网络。一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网(subnet)。划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成。两级 IP 地址在本单位内部就变为三级 IP 地址：网络号、子网号和主机号。 划分子网的方法是从网络的主机号借用若干位作为子网号 subnet-id，当然主机号也就相应减少了同样的位数。凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。这里用一张图给读者以直观的展示，摘自《计算机网络》。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"IP分类","slug":"Network/IP分类","date":"2020-10-24T06:55:04.000Z","updated":"2020-10-24T06:57:14.626Z","comments":true,"path":"2020/10/24/network/ip-fen-lei/","link":"","permalink":"https://tianny.cc/2020/10/24/network/ip-fen-lei/","excerpt":"","text":"聊到 IP 地址分类，相信大部分读者会脱口而出，IP 地址分为 A、B、C、D 类。没错，但是这个答案并不完美。要想知道全部的答案，得从 IP 地址的编码方法说起。编码方法IP 地址的编码方法共经过三个历史阶段:分类的 IP子网的划分超网分类的 IP先说第一种分类的 IP。即将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成。其中第一个字段是网络号（net-id），它标志主机或路由器所连接的网络。一个网络号在整个因特网内必须是唯一的。第二个字段是主机号（host-id），它标志该主机（或路由器）。一个主机号在它前面的网络号所指明的网络范围内必须是唯一的。根据 IP 地址的范围，由此便划分出 A、B、C、D 这四类地址。如下图：注意，这里要指出，由于近年来已经广泛使用无分类 IP 地址进行路由选择，A类、B类和C类地址的区分已成为历史[RFC 1812]。所以这里不用过于记忆，只需了解 IP 分类的最初标准。（手动狗头保命）","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"网络分层","slug":"Network/网络分层","date":"2020-10-24T06:37:31.000Z","updated":"2020-10-24T06:54:05.600Z","comments":true,"path":"2020/10/24/network/wang-luo-fen-ceng/","link":"","permalink":"https://tianny.cc/2020/10/24/network/wang-luo-fen-ceng/","excerpt":"","text":"《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。人类没法儿沟通，达不成“协议”，通天塔的计划就失败了。但是千年以后，人类凭借智慧创造出了网络协议，连接着全世界所有的人，打造这互联网世界的通天塔，将世界连在了一起。如果让我们简单说说计算机网络，相信很多准备过面试的人都会非常了解，但是一旦想要深究『网络到底是如何分层的？』，作者相信大多数人都没有办法回答这个问题，这篇文章就会讨论网络是如何分层的。设计思想闻道有先后，术业有专攻。每个人都有自己擅长的和不擅长的，便衍生出不同的岗位，分工明确，各尽其责。类比到计算机世界也是如此。计算机程序是复杂的，复杂的程序都需要分层，这是程序设计的基本要求。比如电商程序会分数据库层、缓存层、Controller 层和接入层，每一层专注做本层的事情。分层解耦、分而治之是贯穿程序设计的一条基本准则，计算机网络协议更为复杂，网络协议设计之初便按分层思想而设计。网络分层之后，网络每一层协议负责的工作都是不一样的，也就对应了有不同设备来处理。体系结构不以规矩不成方圆，为了制定统一标准， 国际标准化组织（ISO）于 1984 年提出了一种标准参考模型 OSI。它被公认为是计算机通信和 Internet 网络通信 的一种基本结构模型。然而 OSI 七层模型是一个概念模型，并没有说明如何具体实现，是理论标准。在实践过程中，实际上广泛采用 TCP/IP 四层协议结构。读者此时可能会产生疑问，一边是 OSI 体系结构，一边是 TCP/IP 体系结构，两者到底是什么关系？其实没啥必然关系。 OSI 协议可以理解为官方权威人士提出的一套权威标准，但是实现起来超级困难，属于典型的光说不练假把式。 TCP/IP 协议类似民间高手设计的一套易于实现的通信协议，且难度要比实现 OSI 小很多，所以各大厂商纷纷采用。时至今日，TCP/IP 协议完全统治了江山，整个因特网就是建立在 TCP/IP 协议栈基础之上的。而 OSI 协议栈里的一堆协议已经没人再提了，不过你不能说它一无是处，毕竟七个分层模型还是很有科学性的（一本正经的说）。下面看一张 OSI 体系结构与 TCP/IP 体系结构的对比图，方便大家理解。分层处理根据之前描述的 TCP/IP 协议栈的分层结构，每层协议栈各司其职，从网络包中取出自己需要的头部处理完后交给自己的上一层或者下一层。这里用一张图描述，参考自《趣谈网络协议》。总结本节内容从网络分层设计的初衷出发，进而引出了两大广为知名的网络体系结构，OSI 七层模型和 TCP/IP 四层协议结构。接着简单阐述了两个模型之间的区别与联系。最后，用一张图清晰的给读者展示出网络包流经每层时是如何被处理的。","categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"}]},{"title":"Java入门-反射","slug":"Java/基础/反射","date":"2020-04-23T02:06:48.000Z","updated":"2020-04-23T09:27:32.858Z","comments":true,"path":"2020/04/23/java/ji-chu/fan-she/","link":"","permalink":"https://tianny.cc/2020/04/23/java/ji-chu/fan-she/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-泛型通配符","slug":"Java/基础/泛型通配符","date":"2020-04-20T23:47:42.000Z","updated":"2020-04-22T06:59:42.642Z","comments":true,"path":"2020/04/21/java/ji-chu/fan-xing-tong-pei-fu/","link":"","permalink":"https://tianny.cc/2020/04/21/java/ji-chu/fan-xing-tong-pei-fu/","excerpt":"","text":"在前面说过，泛型是不变的，为了实现泛型的协变与逆变，我们可以使用泛型通配符。通配符12345public void test(List&lt;Object&gt; c) &#123; for (int i = 0; i &lt; c.size(); i++) &#123; System.out.prinln(c.get(i)); &#125;&#125;这个方法声明没有任何问题，但是调用该方法实际传入的参数值，可能会出错。考虑如下代码：12List&lt;String&gt; strList = new ArrayList&lt;&gt;();test(strList); // 编译出错，因为泛型是不变的， List&lt;String&gt; 并不是 List&lt;Object&gt; 的子类。为了表示各种泛型 List 的父类，可以使用类型通配符。List&lt;?&gt; 表示元素类型未知的 List。这个 ？ 号被称为通配符，它可以匹配任何类型。将上面的代码，改为如下形式：12345public void test(List&lt;?&gt; c) &#123; for (int i = 0; i &lt; c.size(); i++) &#123; System.out.prinln(c.get(i)); &#125;&#125;现在传入任何类型的 List，程序可以正常打印集合 c 中的元素。这种方法同时带来了另一个问题，即集合中元素的类型会被当成 Object 类型对待。泛型通配符的上界12345678910111213class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Jonathan extends Apple &#123;&#125;class Orange extends Fruit &#123;&#125;public class GenericsAndCovariance &#123; public static void main(String[] args) &#123; List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;(); flist.add(new Apple()); // 编译错误 flist.add(new Fruit()); // 编译错误 flist.add(new Object()); // 编译错误 &#125;&#125;现在 flist 的类型是 &lt;? extends Fruit&gt;，extends 指出了泛型的上界为 Fruit。下边界是任意 Fruit 的子类，理论上来说可以是无限多。使用通配符可以将 ArrayList&lt;Apple&gt; 向上转型了，也就实现了协变。这样的转换也有一定的副作用。那就是容器的部分功能可能失效。我们不能向一个协变泛型的结构中加入任何元素（除了 null）。观察上面代码，再也不能往容器里任何东西。因为泛型的类型擦除原因，类型检查移到了编译期，但协变过程又丢掉了具体的类型（可以是 Fruit 类的任何子类，无法确定到底是哪个子类），导致编译器无法确定真实的类型信息，所以拒绝了插入操作。另一方面，我们知道，不论它是什么类型，它总是 Fruit 的子类型，当我们在读取数据时，能确保得到的数据是一个 Fruit 类型的实例：1Fruit get = flist.get(0);总结：如果一个容器是只读的，才能协变。不然很容易就能把一些特殊的容器协变到更一般的容器，再往里面添加进不应该储存的类型。协变结构可读，不可写。泛型通配符的下界使用通配符 ? super T，其中 T 是一个基类型，或者说父类，我们可以向逆变结构中添加任何 T 及 T 的子类。逆变结构可写，不可读。123456789101112class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Jonathan extends Apple &#123;&#125;class Orange extends Fruit &#123;&#125;public class SuperTypeWildcards &#123; static void writeTo(List&lt;? super Apple&gt; apples) &#123; apples.add(new Apple()); apples.add(new Jonathan()); apples.add(new Fruit()); // 编译错误 &#125;&#125;List&lt;? super Apple&gt; 指定了泛型的下界是 Apple。上边界是模糊的，任意 Apple 的父类都可以，存在无限的可能性，无法确定具体的类型（可以是 Apple 的任何父类，无法确定到底是哪个父类）。所以只能添加 Apple 及其子类。只能取出 Object 实例：因为我们不知道超类究竟是什么，编译器唯一能保证的只是它是个 Object，因为 Object 是任何 Java 类型的超类。存取原则如果你想从一个数据类型里获取数据，使用&lt;? extends T&gt; 通配符。如果你想把对象写入一个数据结构里，使用&lt;? super T&gt; 通配符。如果你既想存，又想取，那就别用通配符。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-协变与逆变","slug":"Java/基础/协变与逆变","date":"2020-04-20T06:59:53.000Z","updated":"2020-04-22T06:48:06.056Z","comments":true,"path":"2020/04/20/java/ji-chu/xie-bian-yu-ni-bian/","link":"","permalink":"https://tianny.cc/2020/04/20/java/ji-chu/xie-bian-yu-ni-bian/","excerpt":"","text":"在介绍泛型的通配符之前，首先需要了解下协变与逆变的相关知识。定义逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果 𝐴、𝐵 表示类型，𝑓(⋅) 表示类型转换，≤ 表示继承关系（比如 𝐴≤𝐵 表示 𝐴 是由 𝐵 派生出来的子类）𝑓(⋅) 是逆变（contravariant）的，当 𝐴≤𝐵 时有 𝑓(𝐵)≤𝑓(𝐴) 成立；𝑓(⋅) 是协变（covariant）的，当 𝐴≤𝐵 时有 𝑓(𝐴)≤𝑓(𝐵) 成立；𝑓(⋅) 是不变（invariant）的，当 𝐴≤𝐵 时上述两个式子均不成立，即 𝑓(𝐴) 与 𝑓(𝐵) 相互之间没有继承关系。数组是协变的1234Number[] numbers = new Number[3];numbers[0] = new Integer(10);numbers[1] = new Double(3.14);numbers[2] = new Long(99L);包装类 Integer、Double、Long 是 Number 的子类，numbers 数组中的元素的类型可以是任何 Number 的子类。我们称 Java 数组是协变的 (Covariant)。不仅如此，下面的代码也是合法的：123Integer[] IntArray = &#123;1,2,3,4&#125;;Number[] NumberArray = IntArray;Number n = NumberArray[0]; //从一个协变结构中读取元素根据协变的定义，因为数组是协变的，所以 Integer[] 是 Number[] 的子类。可以将子类型的数组赋予基类型的数组引用。即父类的引用可以指向子类对象。但是这会导致一个有趣的问题：1234Integer[] IntArray = &#123;1,2,3,4&#125;;Number[] NumberArray = IntArray;NumberArray[0] = 9;NumberArray[0] = 3.14; //尝试污染一个Integer数组 runtime error在编译时，上面的代码不会报错，但是运行时最后一行代码会抛出 ArrayStoreException。很明显，即使通过一个 Number[] 引用，也不能将一个浮点数放入一个事实上的 Integer[] 数组。因为在运行时知道这个数组的真实类型为存放 Integer 类型的数组。泛型是不变的要理解泛型是不变的，需要在此之前说明泛型的擦除机制。因为 JDK1.5 中才引入泛型机制，为了兼容旧的字节码，Java 规范在编译时对泛型进行了类型擦除。也就是说我们使用的所有泛型仅仅存在于编译期间，当通过编译器检查后，泛型信息都会被删除。在运行时，JVM 处理的都是没有携带泛型信息的类型。1234567public class ErasedTypeEquivalence &#123; public static void main(String[] args) &#123; Class c1 = new ArrayList&lt;String&gt;().getClass(); Class c2 = new ArrayList&lt;Integer&gt;().getClass(); System.out.println(c1 == c2); &#125;&#125;上面的执行结果为 true。尽管 ArrayList&lt;String&gt; 和 ArrayList&lt;Integer&gt; 看上去是不同的类型，但在运行时实际上是相同的类型。这两种类型都被擦除成它们的原生类型，即 ArrayList。再看下面一段代码：1234567891011class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;public class NonCovariantGenerics &#123; List&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;(); // 编译错误&#125;public class CovariantArrays &#123; public static void main(String[] args) &#123; Fruit[] fruit = new Apple[10]; // 编译正确&#125;与数组不同，泛型没有内建的协变类型。虽然 Apple 是 Fruit 的子类，但 ArrayList&lt;Apple&gt; 并不是 List&lt;Fruit&gt; 的子类，NonCovariantGenerics 直接在编译时报错了。泛型虽然是不变的，但有时需要实现协变和逆变，这时就要用到泛型通配符了。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-泛型","slug":"Java/基础/泛型","date":"2020-04-17T09:17:43.000Z","updated":"2020-04-20T08:40:56.757Z","comments":true,"path":"2020/04/17/java/ji-chu/fan-xing/","link":"","permalink":"https://tianny.cc/2020/04/17/java/ji-chu/fan-xing/","excerpt":"","text":"背景在没有泛型前，一旦把一个对象丢进集合中，集合就会忘记对象的类型，把所有的对象都当成 Object 类型处理。当程序从集合中取出对象后，就需要进行强制类型转换，这种转换很容易引起 ClassCastException 异常。定义程序在创建集合时指定集合元素的类型。增加了泛型支持后的集合，可以记住集合中元素的类型，并可以在编译时检查集合中元素的类型，如果试图向集合中添加不满足类型要求的对象，编译器就会报错。示例两个示例，简单介绍泛型的基本使用。集合使用泛型1234567891011121314151617181920import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class DiamondTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; books = new ArrayList&lt;&gt;(); books.add(\"learn\"); books.add(\"java\"); books.forEach(book -&gt; System.out.println(book.length())); Map&lt;String, List&lt;String&gt;&gt; schoolsInfo = new HashMap&lt;&gt;(); List&lt;String&gt; schools = new ArrayList&lt;&gt;(); schools.add(\"i\"); schools.add(\"love\"); schoolsInfo.put(\"java\", schools); schoolsInfo.forEach((key, value) -&gt; System.out.println(key + \"---&gt;\" + value)); &#125;&#125;类、接口使用泛型12345678910111213141516171819public class Apple&lt;T&gt; &#123; private T info; public Apple() &#123;&#125; public Apple(T info) &#123; this.info = info; &#125; public void setInfo(T info) &#123; this.info = info; &#125; public T getinfo() &#123; return this.info; &#125; public static void main(String[] args) &#123; Apple&lt;String&gt; a1 = new Apple&lt;&gt;(\"Apple\"); System.out.println(a1.getinfo()); Apple&lt;Double&gt; a2 = new Apple&lt;&gt;(5.67); System.out.println(a2.getinfo()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-集合","slug":"Java/基础/集合","date":"2020-04-02T12:43:17.000Z","updated":"2020-04-02T23:13:10.401Z","comments":true,"path":"2020/04/02/java/ji-chu/ji-he/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/ji-he/","excerpt":"","text":"List 集合List 集合中元素有序、可重复，集合中每个元素都有其对应的索引顺序。List 判断两个对象相等，只要通过 equals 方法比较返回 true 即可。看个例子：12345678910111213141516171819202122public class A &#123; public boolean equals(Object obj) &#123; return true; &#125;&#125;import java.util.ArrayList;import java.util.List;public class ListTest2 &#123; public static void main(String[] args) &#123; List books = new ArrayList(); books.add(new String(\"a\")); books.add(new String(\"b\")); books.add(new String(\"c\")); System.out.println(books); books.remove(new A()); System.out.println(books); books.remove(new A()); System.out.println(books); &#125;&#125;当试图删除一个 A 对象时，List 会调用 A 对象的 equals 方法依次与集合元素进行比较。如果 equals 方法以某个集合元素作为参数时返回 true，List 将会删除该元素。这里 A 重写了 equals 方法，总是返回 true，所以每次都会从 List 集合中删除一个元素。ArrayList 类ArrayList 类是基于数组实现的 List 类，完全支持前面介绍的 List 接口的全部功能。ArrayList 封装了一个动态的、允许再分配的 Object[] 数组。Set 集合HashSet 类元素没有顺序，集合元素的值可以是 nullHashSet 不是同步的，假设有多个线程同时修改了 HashSet 集合时，必须通过代码来保证其同步HashSet 判断元素相等的标准是两个对象通过 equals() 比较相等，同时两个对象的 hashCode()返回值也相等。hashCode 和 equals 符合这样一个约定:equals 返回 true， hashCode 必须相等。很多 Java 类库中的代码都是按照这种约定使用这两个方法的，比如 HashSet。当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来获得该对象的 hashCode 值，然后根据该 hashCode 值决定该对象在 HashSet 中的存储位置。HashSet 中每个能存储元素的槽位称为桶(bucket)。如果多个元素的 hashCode 值相同，但它们通过 equals 方法比较返回 false，就需要在一个桶里放多个元素，这会导致性能下降。所以，建议在需要把某个类的对象保存到 HashSet 集合时，重写该类的 equals 和 hashCode 方法，尽量保证两个对象通过 equals 方法比较返回 true 时，他们的 hashCode 方法返回值也相等。当把可变对象添加到 HashSet 中后，需要特别小心，尽量不要去修改可变对象中参与计算 hashCode() 、equals() 方法的实例变量，否则会导致 HashSet 无法正确访问这些集合元素。看个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class R &#123; int count; public R(int count) &#123; this.count = count; &#125; public String toString() &#123; return \"R[count:\" + count + \"]\"; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) &#123; return true; &#125; if (obj != null &amp;&amp; obj.getClass() == R.class) &#123; R r = (R)obj; return this.count == r.count; &#125; return false; &#125; public int hashCode() &#123; return this.count; &#125;&#125;import java.util.HashSet;import java.util.Iterator;public class HashSetTest2 &#123; public static void main(String[] args) &#123; HashSet hs = new HashSet(); hs.add(new R(5)); hs.add(new R(-3)); hs.add(new R(9)); hs.add(new R(-2)); System.out.println(hs); Iterator it = hs.iterator(); R first = (R)it.next(); first.count = -3; System.out.println(hs); hs.remove(new R(-3)); System.out.println(hs); System.out.println(\"hs 是否包含 count 为 -3 的 R 对象\" + hs.contains(new R(-3))); System.out.println(\"hs 是否包含 count 为 -2 的 R 对象\" + hs.contains(new R(-2))); &#125;&#125;/*[R[count:-2], R[count:-3], R[count:5], R[count:9]][R[count:-3], R[count:-3], R[count:5], R[count:9]][R[count:-3], R[count:5], R[count:9]]hs 是否包含 count 为 -3 的 R 对象falsehs 是否包含 count 为 -2 的 R 对象false*/LinkedHashSet 类LinkedHashSet 是 HashSet 的子类，同样根据 hashCode 值来决定元素的存储位置。但是使用链表维护元素的次序，使得当遍历 LinkedHashSet 集合里的元素时，LinkedHashSet 会按元素的添加顺序访问集合里的元素。LinkedHashSet 需要维护元素的插入顺序，因此性能略低于 HashSet，但在迭代访问 Set 里的全部元素时会有很好的性能，因为它以链表维护内部的顺序。TreeSet 类TreeSet 是 SortedSet 接口的实现类，顾名思义这是一种排序的 Set 集合。TreeSet 底层使用 TreeMap 实现，采用红黑树的数据结构来存储集合元素。TreeSet 支持两种排序方法：自然排序和定制排序。默认情况下，使用自然排序。自然排序Java 提供了 Comparable 接口，接口定义了一个 compareTo(Object obj) 方法。实现该接口的类必须实现该抽象方法。compareTo(Object obj) 比较规则如下：obj1.compareTo(obj2) 返回值为 0，表明相等obj1.compareTo(obj2) 返回值大于 0，表明 obj1 &gt; obj2obj1.compareTo(obj2) 返回值小于 0，表明 obj1 &lt; obj2TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素大小关系，再将集合元素按升序排序，这就是自然排序。所以自然排序中的元素对象都必须实现了 Comparable 接口。如果两个对象通过 compareTo(Object obj) 比较相等， 即返回值为0，TreeSet 认为它们相等，那么新对象将无法添加到 TreeSet 集合中。如果希望 TreeSet 能正常工作，TreeSet 只能添加同一种类型的对象。定制排序如果需要实现定制排序，需要在创建 TreeSet 集合对象时，提供一个 Comparator 对象与该 TreeSet 集合关联。Comparator 是一个函数式接口，可以使用 Lambda 表达式代替。通过定制排序方式时，依然不可以向 TreeSet 中添加不同类型的对象，否则引发 ClassCastException 异常。此时集合判断两个元素相等的标准是：通过 Comparator 比较两个元素返回了 0， 这样 TreeSet 也不会把第二个元素添加到集合中。123456789101112131415import java.util.TreeSet;public class TreeSettest4 &#123; public static void main(String[] args) &#123; TreeSet ts = new TreeSet((o1, o2) -&gt; &#123; M m1 = (M) o1; M m2 = (M) o2; return m1.age &gt; m2.age ? -1 : m1.age &lt; m2.age ? 1: 0; &#125;); ts.add(new M(5)); ts.add(new M(-3)); ts.add(new M(9)); System.out.println(ts); &#125;&#125;上面使用目标类型为 Comparator 的 Lambda 表达式，它负责 ts 集合的排序。所有 M 类无需实现 Comparable 接口，而是由 TreeSet 关联的 Lambda 表达式负责元素的排序。在实现 compareTo 方法时，强烈推荐与 equals 结果一致，否则可能会出现一些奇怪的错误。因为有些类是根据 equals 来判断重复性，有些是利用自然排序 x.compareTo(y) == 0 来判断。compareTo 是判断元素在排序中的位置是否相等，equals 是判断元素是否相等，既然一个决定排序位置，一个决定相等，所以我们非常有必要确保当排序位置相同时，其equals也应该相等。EnumSet 类EnumSet 是专为枚举类设计的集合类，EnumSet 中的所有元素都必须是指定枚举类型的枚举类，该枚举类型在创建 EnumSet 时显式或隐式的的指定。EnumSet 的集合元素是有序的，以枚举值在 Enum 类内的定义顺序来决定集合元素的顺序。EnumSet 集合不允许插入 null 元素。EnumSet 内部以位向量的形式存储，这种存储形式紧凑高效，占用内存很小，运行效率很高。尤其是在进行批量操作时，比如调用 containsAll 和 retainAll 方法时。Map 集合定义：Map 用于保存具有映射关系的数据，key 和 value 之间存在单向的一对一关系，key 不允许重复。Set 与 Map 之间关系非常密切，如果把 key-value 对中的 value 当成 key 的附庸，key 在哪里，value 就在哪里。这样就可以像对待 Set 一样对待 Map 了。实际上，Map 提供了一个 Entry 内部类来封装 key-value 对，而计算 Entry 存储时则只考虑 Entry 封装的 key。从源码来看，Java 是先实现了 Map，然后通过包装一个所有 value 都为 null 的 Map 就实现了 Set 集合。HashMap 实现类HashMap 中用作 key 的对象必须实现 hashCode() 方法和 equals() 方法。HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法比较返回 true，两个 key 的 hashCode 值也相等。HashMap 判断两个 value 相等的标准是：两个对象通过 equals() 方法返回 true 即可。与 HashSet 类似，当使用自定义类作为 HashMap 的 key 时，如果重写该类的 equals() 方法 和 hashCode() 方法，则应该保证两个方法的判断标准一致，即当两个 key 通过 equals() 方法比较返回 true 时，两个 key 的 hashCode() 方法返回值也应该相同。与 HashSet 类似，尽量不要使用可变对象作为 HashMap 的 key，如果使用了，则尽量不要在程序中修改作为 key 的可变对象。LinkedHashMap 实现类LinkedHashMap 也使用双向链表来维护 key-value 对的次序（其实只需要考虑 key 的次序），该链表负责维护 Map 的迭代顺序，迭代顺序与 key-value 对的插入顺序保持一致。1234567891011import java.util.LinkedHashMap;public class LinkedHashMapTest &#123; public static void main(String[] args) &#123; LinkedHashMap scores = new LinkedHashMap(); scores.put(\"Chinses\", 80); scores.put(\"English\", 82); scores.put(\"Math\", 76); scores.forEach((key ,value) -&gt; System.out.println(key + \"---&gt;\" + value)); &#125;&#125;TreeMap 实现类TreeMap 是一个红黑树数据结构，每个 key-value 对即作为红黑树的一个节点。TreeMap 存储 key-value 对节点时，需要根据 key 对节点进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。两种排序方式：自然排序：TreeMap 的所有 key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的对象，否则会抛出 ClassCastException 异常定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。采用定制排序时不要求 Map 的 key 实现 Comparable 接口TreeMap 判断两个 key 相等的标准是：两个 key 通过 compareTo 方法返回 0。类似于 TreeSet，如果使用自定义类作为 TreeMap 的 key，为了让 TreeMap 良好的工作，则重写该类的 equals() 方法和 compareTo() 方法时应该保持一致的结果：两个 key 通过 equals 方法比较返回 true 时，它们通过 compareTo 方法比较应该返回 0。在实现 compareTo 方法时，强烈推荐与 equals 结果一致，否则可能会出现一些奇怪的错误。因为有些类是根据 equals 来判断重复性，有些是利用自然排序 x.compareTo(y) == 0 来判断。compareTo 是判断元素在排序中的位置是否相等，equals 是判断元素是否相等，既然一个决定排序位置，一个决定相等，所以我们非常有必要确保当排序位置相同时，其equals也应该相等。官方文档的说明：Virtually all Java core classes that implement Comparable have natural orderings that are consistent with equals.EnumMap 实现类EnumMap 的 key 必须是单个枚举类的枚举值。EnumMap 具有以下特征：EnumMap 在内部以数组形式保存EnumMap 根据 key 的自然顺序（即枚举值在枚举类中的定义顺序）来维护 key-value 对的顺序EnumMap 不能使用 null 作为 key 值创建 EnumMap 时必须指定一个枚举类，从而将该 EnumMap 和指定枚举类相关联。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-异常","slug":"Java/基础/异常","date":"2020-04-02T03:18:57.000Z","updated":"2020-07-31T02:23:11.498Z","comments":true,"path":"2020/04/02/java/ji-chu/yi-chang/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/yi-chang/","excerpt":"","text":"异常层次Error：Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。ExceptionRuntimeException：由程序错误导致的异常其他异常：程序本身没有问题，但由类似 IO 错误导致的异常Checked 异常 &amp; Runtime 异常Checked 异常：不是 RuntimeException 类及其子类的异常实例Runtime 异常：所有 RuntimeException 类及其子类的异常实例Java 认为 Checked 异常都是可以被处理修复的异常，所以程序必须显示处理 Checked 异常，如果程序没有处理 Checked 异常，编译时会出错。Checked 异常体现了 Java 的设计理念，没有完善错误处理的代码根本不会被执行。对 Checked 异常处理方式：当前方法明确知道如何处理该异常，应该使用 try-catch 处理该异常当前方法不知道如何处理该异常，应在定义该方法时声明抛出该异常对 Runtime 异常的处理方式：Runtime 异常无需显式声明抛出，如果程序需要捕获 Runtime 异常，也可以使用 try-catch 块throws 声明抛出异常如果当前方法不知道如何处理这种类型的异常，该异常应该由上一级调用者处理，如果上一级调用者也不知道如何处理，再抛出直至交由 JVM 处理。throws 声明抛出只能在方法声明中使用，可以声明抛出多个异常类。一旦使用 throws 语句声明抛出该异常，程序就无需使用 try-catch 来捕获异常了。示例：下面程序声明不处理 IOException 异常，而是将该异常交由 JVM 处理12345678import java.io.FileInputStream;import java.io.IOException;public class ThrowsTest &#123; public void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream(\"a.txt\"); &#125;&#125;如果某段代码中调用了一个带 throws 声明的方法，该方法声明抛出了 Checked 异常，则表明该方法希望它的调用者来处理该异常。那么调用者在调用该方法时，要么将其放入 try 块中并显示捕获该异常，要么放在另一个带 throws 声明抛出的方法中。示例代码如下：123456789101112131415161718192021import java.io.FileInputStream;import java.io.IOException;public class ThrowsTest2 &#123; public static void test() throws IOException &#123; /* 因为 FileInputStream 的构造器声明抛出 IOException 异常 所以调用 test() 方法 的代码要么处于 try-catch 块中 要么处于另一个带 throws 声明抛出的方法中 */ FileInputStream fis = new FileInputStream(\"a.txt\"); &#125; public static void main(String[] args) throws Exception &#123; /* 因为 test() 方法声明抛出 IOException 异常 所以调用该方法的代码要么处于 try-catch 块中 要么处于另一个带 throws 声明抛出的方法中 */ test(); &#125;&#125;主动抛出异常 throw如果 throw 语句抛出的异常是 Checked 异常，则该 throw 语句要么处于 try 块里，显式捕获该异常，要么放在一个带 throws 声明抛出的方法中；如果 throw 语句抛出的是 Runtime 异常，则无需放在 try 块里，也无需放在带 throws 声明抛出的方法中，既可以显式的用 try-catch 来捕获并处理异常，也可以完全不理会该异常，把该异常交给该方法调用者处理。123456789101112131415161718192021222324252627282930import java.io.IOException;public class ThrowTest3 &#123; public static void throwChecked(int a) throws Exception &#123; if (a &gt; 0) &#123; // 自行抛出 Exception 异常 // 该代码必须处于 try 块里，或处于带 throws 声明的方法中 throw new Exception(\"a的值大于0，不符合要求\"); &#125; &#125; public static void throwRuntime(int a) &#123; if (a &gt; 0) &#123; // 自行抛出 RuntimeException 异常 // 既可以捕获该异常，也可以完全不理会该异常，把异常交给方法调用者处理 throw new RuntimeException(\"a的值大于0，不符合要求\"); &#125; &#125; public static void main(String[] args) &#123; try &#123; // 调用声明抛出 Checked 异常的方法，要么显式在 try-catch 中捕获该异常，要么在 main 方法中再次声明抛出 throwChecked(3); &#125; catch (Exception e) &#123; System.out.print(e.getMessage()); &#125; // 调用声明抛出 Runtime 异常的方法既可以显式捕获该异常，也可以不理会该异常 throwRuntime(3); &#125;&#125;自定义异常类12345678public class AuctionException extends Exception &#123; // 无参构造器 public AuctionException() &#123;&#125; // 带一个字符串参数的构造器 public AuctionException(String msg) &#123; super(msg); &#125;&#125;异常链将原始信息隐藏起来，仅向上提供必要的异常提示信息的处理方式，可以保证底层异常不会扩散到表现层，避免向上暴露太多的细节，符合面向对象的封装原则。12345678910111213141516public calSal() throws SalException &#123; try &#123; // 实现结算工资的业务逻辑 ... &#125; catch (SQLException sqle) &#123; // 将原始异常记录下来，留给管理员 ... // 下面异常中的 message 就是给用户的提示 throw new SalException(\"访问数据库异常“); &#125; catch (Exception e) &#123; // 将原始异常记录下来，留给管理员 ... // 下面异常中的 message 就是给用户的提示 throw new SalException(\"系统出现未知异常“); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-匿名内部类","slug":"Java/基础/匿名内部类","date":"2020-04-02T02:45:15.000Z","updated":"2020-04-02T02:46:33.952Z","comments":true,"path":"2020/04/02/java/ji-chu/ni-ming-nei-bu-lei/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/ni-ming-nei-bu-lei/","excerpt":"","text":"匿名内部类适合创建只需要一次使用的类，创建匿名内部类时会立即创建一个该类的实例，这个类定义立即消失，匿名类不能重复使用。匿名类是用来创建接口或者抽象类的实例的。匿名内部类不能定义构造器。因为匿名内部类没有类名，所有无法定义构造器。但匿名内部类可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。定义匿名内部类格式如下：1234new 实现接口 | 抽象父类构造器(实参列表)&#123; 匿名内部类的类体部分&#125;最常用的创建匿名内部类的方式是需要创建某个接口类型的对象，如下1234public interface ProductA &#123; public double getPrice(); public String getName();&#125;123456789101112131415161718192021public class AnonymousTest &#123; public void test(ProductA p) &#123; System.out.println(\"Buy a\" + p.getName() + \"Cost \" + p.getPrice()); &#125; public static void main(String[] args) &#123; AnonymousTest ta = new AnonymousTest(); // 调用 test() 方法时，需要传入一个 Product 参数 // 此处传入其匿名实现类的实例 ta.test(new ProductA() &#123; @Override public double getPrice() &#123; return 567.8; &#125; @Override public String getName() &#123; return \"APG Card\"; &#125; &#125;); &#125;&#125;通过继承抽象父类来创建匿名内部类时，匿名内部类将拥有和父类相同形参列表的构造器。看下面一段代码1234567891011121314public abstract class Device &#123; private String name; public abstract double getPrice(); public Device() &#123;&#125;; public Device(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;123456789101112131415161718192021222324252627282930313233public class AnonymousInner &#123; public void test(Device d) &#123; System.out.println(\"Buy a\" + d.getName()+ \"Cost\" + d.getPrice()); &#125; public static void main(String[] args) &#123; AnonymousInner ai = new AnonymousInner(); // 调用有参数的构造器创建 Device 匿名实现类的对象 ai.test(new Device(\"电子显示器\") &#123; @Override public double getPrice() &#123; return 67.8; &#125; &#125;); // 调用无参数的构造器创建 Device 匿名实现类的对象 Device d = new Device() &#123; // 初始化块 &#123; System.out.println(\"匿名内部类的初始化块\"); &#125; // 实现抽象方法 @Override public double getPrice() &#123; return 56.2; &#125; // 重写父类的实例方法 public String getName() &#123; return \"keyboard\"; &#125; &#125;; ai.test(d); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-内部类","slug":"Java/基础/内部类","date":"2020-04-02T02:40:00.000Z","updated":"2020-04-02T02:45:06.182Z","comments":true,"path":"2020/04/02/java/ji-chu/nei-bu-lei/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/nei-bu-lei/","excerpt":"","text":"非静态内部类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Cow &#123; private double weight; public Cow() &#123; &#125; public Cow(double weight) &#123; this.weight = weight; &#125; // 定义一个非静态内部类 private class CowLeg &#123; private double length; private String color; public CowLeg() &#123;&#125; public CowLeg(double length, String color) &#123; this.length = length; this.color = color; &#125; public double getLength() &#123; return this.length; &#125; public void setLength(double length) &#123; this.length = length; &#125; public String getColor() &#123; return this.color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void info() &#123; System.out.println(\"当前牛腿的颜色是 \" + this.color + \", 长 \" + this.length); // 直接访问外部类的 private 修饰的成员变量 System.out.println(\"该牛腿所属的奶牛重: \" + weight); &#125; &#125; public void test() &#123; CowLeg cl = new CowLeg(1.12, \"黑白相间\"); cl.info(); &#125; public static void main(String[] args) &#123; Cow cow = new Cow(378.9); cow.test(); &#125;&#125;在非静态内部类里可以直接访问外部类的 private 成员，这是因为在非静态内部类对象里，保存了一个它所寄生的外部类对象的引用。如下图：如果外部类成员变量、内部类成员变量与内部类里方法的局部变量名同名直接访问局部变量this，访问内部类实例的变量外部类类名.this.varName 访问外部类实例变量外部类不能直接访问非静态内部类的成员，无论非静态内部类的成员是什么修饰符修饰的。只能显示创建非静态内部类对象来访问其实例成员。静态内部类如果用 static 修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此也叫做类内部类。即静态内部类是外部类的一个静态成员。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。外部类依然不能直接访问静态内部类的成员，但可以使用静态内部类的类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类对象作为调用者来访问静态内部类的实例成员。在外部类以外的地方访问内部类（包括静态和非静态两种），则内部类不能使用 private 修饰，private 修饰的内部类只能在外部类内部使用。对于使用其他访问修饰符的内部类，按照访问修饰符范围访问。在外部类之外使用非静态内部类由于非静态内部类的对象必须寄生在外部类的对象里，因此在创建非静态内部类对象之前，必须先创建其外部类对象。示例代码，如下：12345678public class Out &#123; // 使用默认访问控制符，同一个包中的其他类可以访问该内部类 class In &#123; public In(String msg) &#123; System.out.println(msg); &#125; &#125;&#125;123456789101112131415public class CreateInnerInstance &#123; public static void main(String[] args) &#123; Out.In in = new Out().new In(\"Test Msg\"); /* 上面代码可以改为如下三行代码 使用 OutterClass.InnerClass 的形式定义内部类变量 Out.In in; 创建外部类实例，非静态内部类实例将寄生在该实例中 Out out = new Out(); 通过外部类实例和new来调用内部类构造器创建非静态内部类实例 in = out.new In(\"Test Msg\"); */ &#125;&#125;下面定义了一个子类继承了 Out 类的非静态内部类 In 类123456public class SubClass extends Out.In&#123; // 显示定义 SubClass 的构造器 public SubClass(Out out)&#123; out.super(\"hello\"); &#125;&#125;上面的代码可能看起来很怪，其实很正常：非静态内部类 In 类的构造器必须使用外部类对象来调用，代码中 super 代表调用 In 类的构造器，而 out 则代表外部类对象。如果需要创建 SubClass 对象时，必须创建一个 Out 对象。因为 SubClass 是非静态内部类 In 的子类，非静态内部类 In 对象里必须有一个对 Out 对象的引用，其子类 SubClass 对象里也应该持有对 Out 对象的引用。当创建 SubClass 对象时传给该构造器的 Out 对象，就是 SubClass 对象里 Out 对应引用所指向的对象。结合上面两段代码，非静态内部类 In 对象和 SubClass 对象都必须持有指向 Outer 对象的引用，区别是创建两种对象时传入 Out 对象的方式不同：当创建非静态内部类 In 类的对象时，必须通过 Outer 对象来调用 new 关键字；当创建 SubClass 类的对象时，必须使用 Outer 对象作为调用者来调用 In 类的构造器在外部类之外使用静态内部类因为静态内部类是外部类类相关的，因此创建静态内部类对象时无需创建外部类对象。1234567891011public class CreateStaticInnerInstance &#123; public static void main(String[] args) &#123; StaticOut.StaticIn in = new StaticOut.StaticIn(); /* 上面的代码可改为如下两行代码 使用 OuterClass.InnerClass 的形式定义内部类变量 StaticOut.StaticIn in; 通过 new 调用内部类构造器创建静态内部类实例 in = new StaticOut.StaticIn(); */ &#125;&#125;因为调用静态内部类的构造器时不需要使用外部类对象，所以创建静态内部类的子类也比较简单。下面代码为静态静态内部类 StaticIn 定义了一个空的子类1public class StaticSubClass extends StaticOut.StaticIn &#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-抽象类","slug":"Java/基础/抽象类","date":"2020-04-02T02:31:52.000Z","updated":"2020-04-02T02:54:50.676Z","comments":true,"path":"2020/04/02/java/ji-chu/chou-xiang-lei/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/chou-xiang-lei/","excerpt":"","text":"设计思想抽象类是模板模式的设计模式体现。抽象类是从多个具体类中抽象出来的父类，具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类为其子类的模板，避免子类设计的随意性使用抽象类使用 abstract 修饰。抽象类可以和普通类一样可以包含成员变量、方法、构造器、初始化块、内部类。但抽象类不能被实例化，抽象类的构造器主要用来被子类调用。抽象类可以不包含抽象方法，但是含有抽象方法的类必须被定义为抽象类。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-接口","slug":"Java/基础/接口","date":"2020-04-02T02:27:19.000Z","updated":"2020-04-02T02:39:41.787Z","comments":true,"path":"2020/04/02/java/ji-chu/jie-kou/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/jie-kou/","excerpt":"","text":"设计思想接口体现的是规范和实现分离的设计哲学，让软件系统的各组件之间面向接口耦合，是一种松耦合的设计。接口定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，意味着接口通常是定义一组公共方法。定义接口的修饰符，只能是 public 或者 default。由于接口定义的是一种规范，所以接口里不能包含构造器和初始化块定义，只能包含静态常量、方法（只能是抽象方法，类方法和默认方法）以及内部类、内部接口、内部枚举。接口里的常量只能是静态常量，默认使用 public static final 修饰。接口里的内部类、内部接口、内部枚举，默认使用 public static 修饰。接口里的抽象方法不能有方法体，但类方法和默认方法必须有方法体。方法说明接口中定义抽象方法可以省略 abstract 关键字和修饰符，默认修饰符为 public。Java 8 新增允许在接口中定义默认方法，使用 default 修饰。默认情况下，系统使用 public 修饰默认方法。Java 8 新增允许在接口中定义私有方法。Java 8 新增允许在接口中定义静态方法。静态方法可以被实现的接口的类继承。使用一个类可以实现一个或多个接口。一个类实现一个或多个接口，这个类必须重写所实现的接口中的所有抽象方法。否则，该类必须被定义成抽象类，保留从父接口继承到的抽象方法。接口不能用来创建实例，但是可以用于声明引用类型的变量，该变量必须指向实现该接口的类的实例对象。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-Object 类","slug":"Java/基础/Object-类","date":"2020-04-02T02:04:19.000Z","updated":"2020-04-02T02:26:41.450Z","comments":true,"path":"2020/04/02/java/ji-chu/object-lei/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/object-lei/","excerpt":"","text":"Object 类是所有类的父类。下面介绍几个 Object 类中常用的方法。toStringtoString 用于输出对象的自我描述信息。Object 类提供的 toString 返回该对象实现类的 “类名 + @ + hashCode”。通常需要重写该方法。==对于基本数据类型的变量，只要两个变量的值相等（不需要数据类型完全相同），就返回 true。对于两个引用类型的变量，只有它们指向同一个对象时，== 判断才会返回 true。equals对于引用变量，只有指向同一个对象时才返回 true。当仅需要判断值相等时，一般需要重写 equals 方法。重写 equals 方法的示例：123456789101112public boolean equals(Object obj) &#123; if (this == obj) &#123; return true; &#125; if (obj !=null &amp;&amp; obj.getClass() == Person.class) &#123; Person personObj = (Person)obj; if (this.getIdStr().equals(personObj.getIdStr())) &#123; return true; &#125; &#125; return false;&#125;注意：如果equals 为 true，那么也需要重写 hashcode 方法，以保证 hashCode() 返回值相等，这是一种约定俗称的规范。即 equals 为 true 是 hashCode 相等的充分非必要条件。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"UML 图示","slug":"Java/基础/UML-图示","date":"2020-03-26T01:23:37.000Z","updated":"2020-03-26T02:00:28.304Z","comments":true,"path":"2020/03/26/java/ji-chu/uml-tu-shi/","link":"","permalink":"https://tianny.cc/2020/03/26/java/ji-chu/uml-tu-shi/","excerpt":"","text":"UML 是分析程序和理解程序间的调用关系时，不可多得的利器。这里简单介绍几种程序开发中经常使用的 UML 视图，并辅以真实的 Java 案例。类图UML 中的类图表示用于表示类、接口、实例之间的静态关系。类的层次关系展示类的层次关系，如下图接口与实现展示接口与实现类的关系，如下图聚合只要在一个类中持有另一个类的实例，无论是单个还是多个，这种持有关系就称之为聚合。展示聚合关系，如下图可见性类的属性和方法的可见性（访问控制），如下图类的关联类之间的关联关系，如下图：时序图类图表示的静态关系不随时间流逝而变化，而时序图恰好相反，随着时间流逝而发生变化的关系。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-多态","slug":"Java/基础/多态","date":"2020-03-17T04:49:40.000Z","updated":"2020-03-17T05:05:53.257Z","comments":true,"path":"2020/03/17/java/ji-chu/duo-tai/","link":"","permalink":"https://tianny.cc/2020/03/17/java/ji-chu/duo-tai/","excerpt":"","text":"Java 引用变量有两个类型。如果编译时类型和运行时类型不一致，就可能出现多态。编译时类型：由声明该变量时使用的类型决定运行时类型：由实际运行时赋给该变量的对象决定向上类型转换示例代码：123456789101112131415161718192021222324252627282930313233public class BaseClass &#123; public int book = 6; public void base() &#123; System.out.println(\"父类的普通方法\"); &#125; public void test() &#123; System.out.println(\"父类的test方法\"); &#125;&#125;public class SubClass extends BaseClass &#123; public String book = \"轻量级 Java EE\"; public void test() &#123; System.out.println(\"子类的test方法\"); &#125; public void sub() &#123; System.out.println(\"子类的sub方法\"); &#125; public static void main(String[] args) &#123; BaseClass ploymophicBc = new SubClass(); System.out.println(ploymophicBc.book); ploymophicBc.base(); ploymophicBc.test(); // 因为 ploymophicBc 的编译时类型是 BaseClass // BaseClass 类没有提供 sub 方法，所以下面代码编译时会出错 // ploymophicBc.sub(); &#125;&#125;上面的例子中，引用变量 ploymophicBc 比较特殊，它的编译时类型是 BaseClass，而运行时类型是 SubClass。ploymophicBc.sub() 这行代码会在编译时报错，因为 ploymophicBc 编译时类型为 BaseClass，而 BaseClass 中没有定义 sub 方法，因此编译时无法通过。但是注意，ploymophicBc.book 的值为 6， 而不是 ”轻量级 Java EE“。因为对象的实例变量不具备多态性，系统总是试图访问它编译时类型所定义的成员变量，而非运行时。小结子类其实是一种特殊的父类，因此 java 允许把父类的引用指向子类对象，这被称为向上转型（upcasting），向上转型由系统自动完成。可以调用哪些方法，取决于引用类型（编译时）。具体调用哪个方法，取决于引用指向的实例对象（运行时）。向下类型转换问题：引用变量在代码编译过程中，只能调用它编译时类型具备的方法，而不能调用它运行时类型具备的方法解决：强制转换成运行时类型方法：引用类型之间的转换只能在有继承关系的两个类型之间进行，否则编译出错。如果想把一个父类引用变量的编译时类型转换成子类类型，则这个引用变量的运行时类型得是子类类型，否则引发 ClassCastException 异常示例代码：12345678910//创建子类对象Dog dog = new Dog();// 向上类型转换(类型自动提升),不存在风险// 此时 animal 为 Dog 类型Animal animal = dog;// 风险演示：编译阶段不会报错，但是运行时会报错// 根据上面的语句，此时 animal 指向 Dog 类型对象，没有办法转化成 Cat 对象。Cat cat = (Cat)animal; // 1.强转成功，编译时按 Cat 类型 2. 但运行时 Dog 类型，类型不匹配，直接报错instanceof为了解决强制类型转换，可能引发的 ClassCastException 异常，引入 instanceof 运算符。instanceof 运算符的含义：用于判断左边的对象（运行时类型）是否是右边的类或者其子类、实现类的实例。如果是返回 true，否则返回 false。在之前的代码中，强制类型转换前使用 instanceof 判断：123if (anmial instanceof Cat) &#123; Cat cat = (Cat)animal;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-方法传参","slug":"Java/基础/方法传参","date":"2020-03-17T01:29:04.000Z","updated":"2020-03-17T01:57:44.625Z","comments":true,"path":"2020/03/17/java/ji-chu/fang-fa-chuan-can/","link":"","permalink":"https://tianny.cc/2020/03/17/java/ji-chu/fang-fa-chuan-can/","excerpt":"","text":"无论是基本类型的值传递，还是引用类型的参数传递，在 Java 中方法总是采用按值调用。对于引用类型，传递的是其对应的内存空间地址。基本类型的值传递123456789101112131415161718192021public class PrimitiveTransferTest &#123; public static void swap(int a, int b) &#123; int tmp = a; a = b; b = tmp; System.out.println(\"swap 方法里 a 的值为: \" + a + \" b的值为: \" + b); &#125; public static void main(String[] args) &#123; int a = 6; int b = 9; swap(a, b); System.out.println(\"交换结束后 a 的值为 \" + a + \" b的值为 \" + b); &#125;&#125;/**运行结果：swap 方法里 a 的值为: 9 b的值为: 6交换结束后 a 的值为 6 b的值为 9*/分析图：main 方法中定义了a、b 变量存储示意图，如下:main 方法中的变量作为参数值传入 swap() 方法存储示意图，如下:swap 方法中 a、b 交换后的存储示意图，如下:java 程序总是从 main() 方法开始执行，main() 方法定义了 a、b 两个局部变量，两个变量在 main 栈区中。在 main() 方法中调用 swap() 方法时，main() 方法此时还未结束，因此系统为 main 方法和 swap 方法分配了两块栈区，用于保存 main 方法和 swap 方法的局部变量。main 方法中的 a、b 变量作为参数传入 swap 方法，实际上是在 swap 方法栈区中重新产生了两个变量 a、b，并将 main 方法栈区中 a、b 变量的值分别赋给 swap 方法栈区中的 a、b 参数（这就是初始化）。此时系统内存中有两个 a 变量、两个 b 变量，只是存在于不同的方法栈区中而已。引用类型的参数传递123456789101112131415161718192021public class ReferenceTransferTest &#123; public static void swap(DataWrap dw) &#123; int tmp = dw.a; dw.a = dw.b; dw.b = tmp; System.out.println(\"swap 方法里， a 成员变量的的值为: \" + dw.a + \" b 成员变量的值为: \" + dw.b); &#125; public static void main(String[] args) &#123; DataWrap dw = new DataWrap(); dw.a = 6; dw.b = 9; swap(dw); System.out.println(\"交换结束后， a 成员变量的的值为: \" + dw.a + \" b 成员变量的值为: \" + dw.b); &#125;&#125;/**swap 方法里， a 成员变量的的值为: 9 b 成员变量的值为: 6交换结束后， a 成员变量的的值为: 9 b 成员变量的值为: 6*/你可能会疑问，dw 对象的成员变量 a、b的值也被替换了，这跟前面基本类型的传递完全不一样。这非常容易让人觉得，调用传入 swap 方法的就是 dw 对象本身，而不是它的复制品。其实传递的依然是 dw 的值。分析图：main 方法中创建 DataWrap 对象后的存储示意图，如下:main 方法中 dw 传入 swap() 方法后的存储示意图，如下:系统一样赋值了 dw 的副本，只是关键在于 dw 只是一个引用变量，它存储的值只是一段内存地址，将该内存地址传递给 swap 栈区，此时 swap 栈区的 dw 和 main 栈区的 dw 的值也就是内存地址相同，该段内存地址指向堆内存中的 DataWrap 对象。对 swap 栈区的 dw 操作，也就是对 DataWrap 对象操作。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-数组","slug":"Java/基础/数组","date":"2020-03-15T06:30:28.000Z","updated":"2020-03-15T06:38:29.053Z","comments":true,"path":"2020/03/15/java/ji-chu/shu-zu/","link":"","permalink":"https://tianny.cc/2020/03/15/java/ji-chu/shu-zu/","excerpt":"","text":"数组是用来存储固定大小的同类型元素。一旦数组初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度不可以改变。即使某个数组的元素被清空，但是它所占的空间依然保留。数组本身也是一种引用类型，既可以存储基本数据类型，也可以存储引用类型，只要存储的数组元素具有相同的类型即可。初始化动态初始化执行动态初始化时，系统会根据声明的数组类型自动为数组元素分配初始值。如果是引用类型，则数组元素的初始值为 null。1int[] scores = new int[5];静态初始化显式指定每个元素的初始值1int[] scores = &#123;1,2,3,4&#125;;遍历数组foreach 遍历数组12345int[] scores = &#123;1,2,3,4&#125;;for (int score : scores) &#123; System.out.println(score);&#125;数组的本质将数组看成两个部分，一个部分是数组引用，也就是在代码中定义的数组引用变量；另一部分是实际的数组对象，这部分是在堆内存中运行的，通常无法直接访问它，只能通过引用变量来访问。二维数组二维数组本质上还是一维数组，只是其数组元素也是引用，数组元素里保存的引用指向一维数组。1String [][] str1 = &#123;new String[3], new String[]&#123;\"hello\"&#125;&#125;;代码示意图如下：","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-控制结构","slug":"Java/基础/控制结构","date":"2020-03-15T06:13:21.000Z","updated":"2020-03-15T06:24:45.256Z","comments":true,"path":"2020/03/15/java/ji-chu/kong-zhi-jie-gou/","link":"","permalink":"https://tianny.cc/2020/03/15/java/ji-chu/kong-zhi-jie-gou/","excerpt":"","text":"if-else12345if (condition) &#123; statement;&#125; else &#123; statement;&#125;Switch12345678910111213switch (表达式) &#123; case value1: statement1; break; case value2: statement2; break; case valuen: statementn; break; default: 默认执行的代码;&#125;当 switch 后表达式的值和 case 语句后的值相同时，从该位置向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。case 后面的值可以是常量数值，也可以是一个常量表达式，但不能是变量或带有变量的表达式可以把功能相同的 case 语句合并起来default 块可以出现在任意位置，也可以省略while123while (condition) &#123; statement;&#125;do-while123do &#123; statement;&#125; while (condition);for123for (循环变量初始化; 循环条件; 循环变量变化) &#123; statement；&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-数据类型","slug":"Java/基础/数据类型","date":"2020-03-15T03:24:31.000Z","updated":"2020-03-15T06:09:24.281Z","comments":true,"path":"2020/03/15/java/ji-chu/shu-ju-lei-xing/","link":"","permalink":"https://tianny.cc/2020/03/15/java/ji-chu/shu-ju-lei-xing/","excerpt":"","text":"数据类型基本数据类型变量存储的是数据本身引用类型变量存储的是数据的空间地址类型转换自动类型转换把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，系统将会进行自动类型转换（隐式转换），否则需要强制转换。强制类型转换强制类型转换可能存在溢出导致数据精度丢失的情况。字符串Java 没有内置的字符串类型，而是提供了一个标准类库 String。特征：不可变字符串优点：编译器可以让字符串共享（只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的）","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"HDFS 读写流程","slug":"BigData/HDFS/HDFS-读写流程","date":"2019-09-09T08:17:55.000Z","updated":"2020-10-24T07:27:28.972Z","comments":true,"path":"2019/09/09/bigdata/hdfs/hdfs-du-xie-liu-cheng/","link":"","permalink":"https://tianny.cc/2019/09/09/bigdata/hdfs/hdfs-du-xie-liu-cheng/","excerpt":"","text":"HDFS 文件读取流程Client 端调用 DistributedFileSystem 对象的 open() 方法。由 DistributedFileSystem 通过 RPC 向 NameNode 请求返回文件的 Block 块所在的 DataNode 的地址。（我们知道 HDFS 默认策略对某个 Block 会保存三份副本到不同的 DataNode，那么 NameNode 应该返回哪个 DataNode？答案是根据 DataNode 到 Client 端的距离。假设请求的 Block 块刚好就落在 Client 端所在机器上，即 Client 端本身也是 DataNode，那么毫无疑问 DataNode 将会返回 Client 端所在机器地址。这也验证了 Hadoop 的一个设计特性，移动计算而不是移动数据，极大了减小了带宽。）Client 端调用 FSDataInputStream 对象的 read() 方法，通过 FSDataInputStream 向 DataNode 获取 Block 数据。之后数据流源源不断地从 DataNode 返回至 Client。当最后一个 Block 返回至 Client 端后， DFSInputStream 会关闭与 DataNode 连接。上述过程对 Client 端都是透明的，从 Client 来看，它只是在不停的读取数据流。如果 DFSInputStream 在读取的过程中发生了错误，将会尝试与存有该 Block 副本且距离最近的 DataNode 通信。同时，它会记录下出问题的 DataNode，在之后的数据请求过程中不再与之通信。并报告给 NameNode。DFSInputStream 具备检查数据校验和的功能。HDFS 文件写入流程Client 写入文件时，调用 DistributedFileSystem 对象的 create() 方法。DistributedFileSystem 通过 RPC 请求 NameNode 向其 NameSpace 写入文件元数据信息。NameNode 会做多种检查，如判断文件是否存在，是否有相应的写权限等等。如果检查通过，NameNode 会将文件元数据写入 NameSpace。DistributedFileSystem 将会返回 FSDataOutputStream 用于 Client 端直接向 DataNode 写入数据。DFSOutputStream 将 Client 要写入的数据分割成 Packets。Packets 会被保存到 Data Queue 队列中，并由 DataStreamer 消费处理。DataStreamer 请求 NameNode 分配 DataNode 列表，将 Packets 写入到 DataNode 中。假设放置副本的默认策略是 3，那么 NameNode 将返回 3 个 DataNode，并串联起来组成一条 Pipeline。 DataStreamer 将 Packets 写入到第一个 DataNode1，DataNode1 存储完后直接转发至 DataNode2，DataNode2 存储完后再直接转发至 DataNode3。（注意，这里直接是 DataNode1 直接将 Packet 转发至 DataNode2。）DFSOutputStream 为了防止出问题时数据的丢失，维持了一个等待 DataNode 成功写入的 ACK Queue。只有当 Packet 被成功写入 Pipeline 中的每个 DataNode 时，此 Packet 才会从 ACK Queue 中移除。在 Pipeline 写入的过程中，如果某个 DataNode 出现问题，Pipeline 首先将会被关闭，随后在 ACK Queue 中的 Packets 会被添加到 Data Queue 的最前面，用来防止位于问题节点下游的 DataNode 写入时的数据丢失。出问题的 DataNode 会被从 Pipeline 中移除。NameNode 会重新分配一个健康的 DataNode 构成新的 Pipeline。当 Client 端写完数据，调用 DFSOutputStream 对象的 close() 方法。该操作将会将所有剩余的 Packets 刷写到 DataNode Pipeline 并等待返回确认，之后向 NameNode 发送文件写入完成信号。","categories":[{"name":"BigData","slug":"BigData","permalink":"https://tianny.cc/categories/BigData/"}],"tags":[{"name":"HDFS","slug":"HDFS","permalink":"https://tianny.cc/tags/HDFS/"}]},{"title":"CM & CDH 基本介绍","slug":"BigData/CDH/CM-CDH-基本介绍","date":"2019-08-17T08:00:02.000Z","updated":"2020-10-24T07:27:13.059Z","comments":true,"path":"2019/08/17/bigdata/cdh/cm-cdh-ji-ben-jie-shao/","link":"","permalink":"https://tianny.cc/2019/08/17/bigdata/cdh/cm-cdh-ji-ben-jie-shao/","excerpt":"","text":"什么是 CDHHadoop 是开源项目，所以很多公司在这个基础上进行商业化，不收费的 Hadoop 主要有三个：Apache，最原始的版本，所有发行版均基于这个版本进行Cloudear，全称 Cloudera’s Distribution Including Apache Hadoop，简称 CDHHortonworks，全称 Hortonworks Data Platform，简称 HDP什么是 Cloudera ManagerCloudear Manager，简称 CM，用于管理 CDH 集群，其主要功能是对 CDH 集群进行监控，大大改善原生 Apache Hadoop 的安装、配置复杂度和需要使用第三方开源监控工具所带来的诸多问题，可进行节点安装、配置、诊断、集成并提供 web 界面。CM 架构基本组成：ServerAgent：安装在每个集群节点上，Server 下发的操作都由 Agent 来实现Management Service：监控报警等功能Database：存储各种服务配置信息和报警信息Cloudera Repoistory：用来分发 Parcels 包的远程仓库ClientsServer 和 Agent 通信方式：默认情况下，Agent 每隔 15s 向 Server 发送心跳。但是当状态发生变化时，为了减少用户等待时间，会加快心跳频率。CM 术语host 主机rack 机架cluster 集群service 服务，例如 HDFS、YARN 都是一个个服务role 角色，例如 HDFS 的 NameNode 和 DataNode 都可以称为 HDFS 的 角色role group 角色组，将角色划分为一组方便管理host template 主机模板parcel 包static service pool 静态服务池dynamic resource pool 动态资源池","categories":[{"name":"BigData","slug":"BigData","permalink":"https://tianny.cc/categories/BigData/"}],"tags":[{"name":"CDH","slug":"CDH","permalink":"https://tianny.cc/tags/CDH/"}],"author":"Tianny"}],"categories":[{"name":"Network","slug":"Network","permalink":"https://tianny.cc/categories/Network/"},{"name":"Finace","slug":"Finace","permalink":"https://tianny.cc/categories/Finace/"},{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"},{"name":"BigData","slug":"BigData","permalink":"https://tianny.cc/categories/BigData/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://tianny.cc/tags/DNS/"},{"name":"Finace","slug":"Finace","permalink":"https://tianny.cc/tags/Finace/"},{"name":"Network","slug":"Network","permalink":"https://tianny.cc/tags/Network/"},{"name":"Socket","slug":"Socket","permalink":"https://tianny.cc/tags/Socket/"},{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"},{"name":"HDFS","slug":"HDFS","permalink":"https://tianny.cc/tags/HDFS/"},{"name":"CDH","slug":"CDH","permalink":"https://tianny.cc/tags/CDH/"}]}
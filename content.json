{"meta":{"title":"Tianny's Blog","subtitle":"Tianny","description":"What is a real programmer?","author":"Tianny","url":"https://tianny.cc","root":"/"},"pages":[{"title":"about","date":"2018-10-05T08:33:28.000Z","updated":"2019-06-02T11:37:29.738Z","comments":true,"path":"about/index.html","permalink":"https://tianny.cc/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-01T16:47:23.000Z","updated":"2019-06-02T11:37:29.738Z","comments":true,"path":"categories/index.html","permalink":"https://tianny.cc/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-13T15:43:47.000Z","updated":"2019-06-02T11:37:29.739Z","comments":true,"path":"friends/index.html","permalink":"https://tianny.cc/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-12T15:24:17.000Z","updated":"2019-06-02T11:37:29.739Z","comments":true,"path":"tags/index.html","permalink":"https://tianny.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java入门-反射","slug":"Java/基础/反射","date":"2020-04-23T02:06:48.000Z","updated":"2020-04-23T09:27:32.858Z","comments":true,"path":"2020/04/23/java/ji-chu/fan-she/","link":"","permalink":"https://tianny.cc/2020/04/23/java/ji-chu/fan-she/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-泛型通配符","slug":"Java/基础/泛型通配符","date":"2020-04-20T23:47:42.000Z","updated":"2020-04-22T06:59:42.642Z","comments":true,"path":"2020/04/21/java/ji-chu/fan-xing-tong-pei-fu/","link":"","permalink":"https://tianny.cc/2020/04/21/java/ji-chu/fan-xing-tong-pei-fu/","excerpt":"","text":"在前面说过，泛型是不变的，为了实现泛型的协变与逆变，我们可以使用泛型通配符。通配符public void test(List&lt;Object> c) { for (int i = 0; i &lt; c.size(); i++) { System.out.prinln(c.get(i)); } }这个方法声明没有任何问题，但是调用该方法实际传入的参数值，可能会出错。考虑如下代码：List&lt;String> strList = new ArrayList&lt;>(); test(strList); // 编译出错，因为泛型是不变的， List&lt;String> 并不是 List&lt;Object> 的子类。为了表示各种泛型 List 的父类，可以使用类型通配符。List&lt;?&gt; 表示元素类型未知的 List。这个 ？ 号被称为通配符，它可以匹配任何类型。将上面的代码，改为如下形式：public void test(List&lt;?> c) { for (int i = 0; i &lt; c.size(); i++) { System.out.prinln(c.get(i)); } }现在传入任何类型的 List，程序可以正常打印集合 c 中的元素。这种方法同时带来了另一个问题，即集合中元素的类型会被当成 Object 类型对待。泛型通配符的上界class Fruit {} class Apple extends Fruit {} class Jonathan extends Apple {} class Orange extends Fruit {} public class GenericsAndCovariance { public static void main(String[] args) { List&lt;? extends Fruit> flist = new ArrayList&lt;Apple>(); flist.add(new Apple()); // 编译错误 flist.add(new Fruit()); // 编译错误 flist.add(new Object()); // 编译错误 } }现在 flist 的类型是 &lt;? extends Fruit&gt;，extends 指出了泛型的上界为 Fruit。下边界是任意 Fruit 的子类，理论上来说可以是无限多。使用通配符可以将 ArrayList&lt;Apple&gt; 向上转型了，也就实现了协变。这样的转换也有一定的副作用。那就是容器的部分功能可能失效。我们不能向一个协变泛型的结构中加入任何元素（除了 null）。观察上面代码，再也不能往容器里任何东西。因为泛型的类型擦除原因，类型检查移到了编译期，但协变过程又丢掉了具体的类型（可以是 Fruit 类的任何子类，无法确定到底是哪个子类），导致编译器无法确定真实的类型信息，所以拒绝了插入操作。另一方面，我们知道，不论它是什么类型，它总是 Fruit 的子类型，当我们在读取数据时，能确保得到的数据是一个 Fruit 类型的实例：Fruit get = flist.get(0);总结：如果一个容器是只读的，才能协变。不然很容易就能把一些特殊的容器协变到更一般的容器，再往里面添加进不应该储存的类型。协变结构可读，不可写。泛型通配符的下界使用通配符 ? super T，其中 T 是一个基类型，或者说父类，我们可以向逆变结构中添加任何 T 及 T 的子类。逆变结构可写，不可读。Fruit get = flist.get(0);总结：如果一个容器是只读的，才能协变。不然很容易就能把一些特殊的容器协变到更一般的容器，再往里面添加进不应该储存的类型。协变结构可读，不可写。泛型通配符的下界使用通配符 ? super T，其中 T 是一个基类型，或者说父类，我们可以向逆变结构中添加任何 T 及 T 的子类。逆变结构可写，不可读。class Fruit {} class Apple extends Fruit {} class Jonathan extends Apple {} class Orange extends Fruit {} public class SuperTypeWildcards { static void writeTo(List apples) { apples.add(new Apple()); apples.add(new Jonathan()); apples.add(new Fruit()); // 编译错误 } }List&lt;? super Apple&gt; 指定了泛型的下界是 Apple。上边界是模糊的，任意 Apple 的父类都可以，存在无限的可能性，无法确定具体的类型（可以是 Apple 的任何父类，无法确定到底是哪个父类）。所以只能添加 Apple 及其子类。只能取出 Object 实例：因为我们不知道超类究竟是什么，编译器唯一能保证的只是它是个 Object，因为 Object 是任何 Java 类型的超类。存取原则如果你想从一个数据类型里获取数据，使用&lt;? extends T&gt; 通配符。如果你想把对象写入一个数据结构里，使用&lt;? super T&gt; 通配符。如果你既想存，又想取，那就别用通配符。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-协变与逆变","slug":"Java/基础/协变与逆变","date":"2020-04-20T06:59:53.000Z","updated":"2020-04-22T06:48:06.056Z","comments":true,"path":"2020/04/20/java/ji-chu/xie-bian-yu-ni-bian/","link":"","permalink":"https://tianny.cc/2020/04/20/java/ji-chu/xie-bian-yu-ni-bian/","excerpt":"","text":"在介绍泛型的通配符之前，首先需要了解下协变与逆变的相关知识。定义逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果 𝐴、𝐵 表示类型，𝑓(⋅) 表示类型转换，≤ 表示继承关系（比如 𝐴≤𝐵 表示 𝐴 是由 𝐵 派生出来的子类）𝑓(⋅) 是逆变（contravariant）的，当 𝐴≤𝐵 时有 𝑓(𝐵)≤𝑓(𝐴) 成立；𝑓(⋅) 是协变（covariant）的，当 𝐴≤𝐵 时有 𝑓(𝐴)≤𝑓(𝐵) 成立；𝑓(⋅) 是不变（invariant）的，当 𝐴≤𝐵 时上述两个式子均不成立，即 𝑓(𝐴) 与 𝑓(𝐵) 相互之间没有继承关系。数组是协变的Number[] numbers = new Number[3]; numbers[0] = new Integer(10); numbers[1] = new Double(3.14); numbers[2] = new Long(99L);包装类 Integer、Double、Long 是 Number 的子类，numbers 数组中的元素的类型可以是任何 Number 的子类。我们称 Java 数组是协变的 (Covariant)。不仅如此，下面的代码也是合法的：Integer[] IntArray = {1,2,3,4}; Number[] NumberArray = IntArray; Number n = NumberArray[0]; //从一个协变结构中读取元素根据协变的定义，因为数组是协变的，所以 Integer[] 是 Number[] 的子类。可以将子类型的数组赋予基类型的数组引用。即父类的引用可以指向子类对象。但是这会导致一个有趣的问题：Integer[] IntArray = {1,2,3,4}; Number[] NumberArray = IntArray; NumberArray[0] = 9; NumberArray[0] = 3.14; //尝试污染一个Integer数组 runtime error在编译时，上面的代码不会报错，但是运行时最后一行代码会抛出 ArrayStoreException。很明显，即使通过一个 Number[] 引用，也不能将一个浮点数放入一个事实上的 Integer[] 数组。因为在运行时知道这个数组的真实类型为存放 Integer 类型的数组。泛型是不变的要理解泛型是不变的，需要在此之前说明泛型的擦除机制。因为 JDK1.5 中才引入泛型机制，为了兼容旧的字节码，Java 规范在编译时对泛型进行了类型擦除。也就是说我们使用的所有泛型仅仅存在于编译期间，当通过编译器检查后，泛型信息都会被删除。在运行时，JVM 处理的都是没有携带泛型信息的类型。public class ErasedTypeEquivalence { public static void main(String[] args) { Class c1 = new ArrayList&lt;String>().getClass(); Class c2 = new ArrayList&lt;Integer>().getClass(); System.out.println(c1 == c2); } }上面的执行结果为 true。尽管 ArrayList&lt;String&gt; 和 ArrayList&lt;Integer&gt; 看上去是不同的类型，但在运行时实际上是相同的类型。这两种类型都被擦除成它们的原生类型，即 ArrayList。再看下面一段代码：class Fruit {} class Apple extends Fruit {} public class NonCovariantGenerics { List&lt;Fruit> flist = new ArrayList&lt;Apple>(); // 编译错误 } public class CovariantArrays { public static void main(String[] args) { Fruit[] fruit = new Apple[10]; // 编译正确 }与数组不同，泛型没有内建的协变类型。虽然 Apple 是 Fruit 的子类，但 ArrayList&lt;Apple&gt; 并不是 List&lt;Fruit&gt; 的子类，NonCovariantGenerics 直接在编译时报错了。泛型虽然是不变的，但有时需要实现协变和逆变，这时就要用到泛型通配符了。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-泛型","slug":"Java/基础/泛型","date":"2020-04-17T09:17:43.000Z","updated":"2020-04-20T08:40:56.757Z","comments":true,"path":"2020/04/17/java/ji-chu/fan-xing/","link":"","permalink":"https://tianny.cc/2020/04/17/java/ji-chu/fan-xing/","excerpt":"","text":"背景在没有泛型前，一旦把一个对象丢进集合中，集合就会忘记对象的类型，把所有的对象都当成 Object 类型处理。当程序从集合中取出对象后，就需要进行强制类型转换，这种转换很容易引起 ClassCastException 异常。定义程序在创建集合时指定集合元素的类型。增加了泛型支持后的集合，可以记住集合中元素的类型，并可以在编译时检查集合中元素的类型，如果试图向集合中添加不满足类型要求的对象，编译器就会报错。示例两个示例，简单介绍泛型的基本使用。集合使用泛型import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class DiamondTest { public static void main(String[] args) { List&lt;String> books = new ArrayList&lt;>(); books.add(\"learn\"); books.add(\"java\"); books.forEach(book -> System.out.println(book.length())); Map&lt;String, List&lt;String>> schoolsInfo = new HashMap&lt;>(); List&lt;String> schools = new ArrayList&lt;>(); schools.add(\"i\"); schools.add(\"love\"); schoolsInfo.put(\"java\", schools); schoolsInfo.forEach((key, value) -> System.out.println(key + \"--->\" + value)); } }类、接口使用泛型public class Apple&lt;T> { private T info; public Apple() {} public Apple(T info) { this.info = info; } public void setInfo(T info) { this.info = info; } public T getinfo() { return this.info; } public static void main(String[] args) { Apple&lt;String> a1 = new Apple&lt;>(\"Apple\"); System.out.println(a1.getinfo()); Apple&lt;Double> a2 = new Apple&lt;>(5.67); System.out.println(a2.getinfo()); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-集合","slug":"Java/基础/集合","date":"2020-04-02T12:43:17.000Z","updated":"2020-04-02T23:13:10.401Z","comments":true,"path":"2020/04/02/java/ji-chu/ji-he/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/ji-he/","excerpt":"","text":"List 集合List 集合中元素有序、可重复，集合中每个元素都有其对应的索引顺序。List 判断两个对象相等，只要通过 equals 方法比较返回 true 即可。看个例子：public class A { public boolean equals(Object obj) { return true; } } import java.util.ArrayList; import java.util.List; public class ListTest2 { public static void main(String[] args) { List books = new ArrayList(); books.add(new String(\"a\")); books.add(new String(\"b\")); books.add(new String(\"c\")); System.out.println(books); books.remove(new A()); System.out.println(books); books.remove(new A()); System.out.println(books); } }当试图删除一个 A 对象时，List 会调用 A 对象的 equals 方法依次与集合元素进行比较。如果 equals 方法以某个集合元素作为参数时返回 true，List 将会删除该元素。这里 A 重写了 equals 方法，总是返回 true，所以每次都会从 List 集合中删除一个元素。ArrayList 类ArrayList 类是基于数组实现的 List 类，完全支持前面介绍的 List 接口的全部功能。ArrayList 封装了一个动态的、允许再分配的 Object[] 数组。Set 集合HashSet 类元素没有顺序，集合元素的值可以是 nullHashSet 不是同步的，假设有多个线程同时修改了 HashSet 集合时，必须通过代码来保证其同步HashSet 判断元素相等的标准是两个对象通过 equals() 比较相等，同时两个对象的 hashCode()返回值也相等。hashCode 和 equals 符合这样一个约定:equals 返回 true， hashCode 必须相等。很多 Java 类库中的代码都是按照这种约定使用这两个方法的，比如 HashSet。当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来获得该对象的 hashCode 值，然后根据该 hashCode 值决定该对象在 HashSet 中的存储位置。HashSet 中每个能存储元素的槽位称为桶(bucket)。如果多个元素的 hashCode 值相同，但它们通过 equals 方法比较返回 false，就需要在一个桶里放多个元素，这会导致性能下降。所以，建议在需要把某个类的对象保存到 HashSet 集合时，重写该类的 equals 和 hashCode 方法，尽量保证两个对象通过 equals 方法比较返回 true 时，他们的 hashCode 方法返回值也相等。当把可变对象添加到 HashSet 中后，需要特别小心，尽量不要去修改可变对象中参与计算 hashCode() 、equals() 方法的实例变量，否则会导致 HashSet 无法正确访问这些集合元素。看个例子：public class R { int count; public R(int count) { this.count = count; } public String toString() { return \"R[count:\" + count + \"]\"; } @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj != null &amp;&amp; obj.getClass() == R.class) { R r = (R)obj; return this.count == r.count; } return false; } public int hashCode() { return this.count; } } import java.util.HashSet; import java.util.Iterator; public class HashSetTest2 { public static void main(String[] args) { HashSet hs = new HashSet(); hs.add(new R(5)); hs.add(new R(-3)); hs.add(new R(9)); hs.add(new R(-2)); System.out.println(hs); Iterator it = hs.iterator(); R first = (R)it.next(); first.count = -3; System.out.println(hs); hs.remove(new R(-3)); System.out.println(hs); System.out.println(\"hs 是否包含 count 为 -3 的 R 对象\" + hs.contains(new R(-3))); System.out.println(\"hs 是否包含 count 为 -2 的 R 对象\" + hs.contains(new R(-2))); } } /* [R[count:-2], R[count:-3], R[count:5], R[count:9]] [R[count:-3], R[count:-3], R[count:5], R[count:9]] [R[count:-3], R[count:5], R[count:9]] hs 是否包含 count 为 -3 的 R 对象false hs 是否包含 count 为 -2 的 R 对象false */LinkedHashSet 类LinkedHashSet 是 HashSet 的子类，同样根据 hashCode 值来决定元素的存储位置。但是使用链表维护元素的次序，使得当遍历 LinkedHashSet 集合里的元素时，LinkedHashSet 会按元素的添加顺序访问集合里的元素。LinkedHashSet 需要维护元素的插入顺序，因此性能略低于 HashSet，但在迭代访问 Set 里的全部元素时会有很好的性能，因为它以链表维护内部的顺序。TreeSet 类TreeSet 是 SortedSet 接口的实现类，顾名思义这是一种排序的 Set 集合。TreeSet 底层使用 TreeMap 实现，采用红黑树的数据结构来存储集合元素。TreeSet 支持两种排序方法：自然排序和定制排序。默认情况下，使用自然排序。自然排序Java 提供了 Comparable 接口，接口定义了一个 compareTo(Object obj) 方法。实现该接口的类必须实现该抽象方法。compareTo(Object obj) 比较规则如下：obj1.compareTo(obj2) 返回值为 0，表明相等obj1.compareTo(obj2) 返回值大于 0，表明 obj1 &gt; obj2obj1.compareTo(obj2) 返回值小于 0，表明 obj1 &lt; obj2TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素大小关系，再将集合元素按升序排序，这就是自然排序。所以自然排序中的元素对象都必须实现了 Comparable 接口。如果两个对象通过 compareTo(Object obj) 比较相等， 即返回值为0，TreeSet 认为它们相等，那么新对象将无法添加到 TreeSet 集合中。如果希望 TreeSet 能正常工作，TreeSet 只能添加同一种类型的对象。定制排序如果需要实现定制排序，需要在创建 TreeSet 集合对象时，提供一个 Comparator 对象与该 TreeSet 集合关联。Comparator 是一个函数式接口，可以使用 Lambda 表达式代替。通过定制排序方式时，依然不可以向 TreeSet 中添加不同类型的对象，否则引发 ClassCastException 异常。此时集合判断两个元素相等的标准是：通过 Comparator 比较两个元素返回了 0， 这样 TreeSet 也不会把第二个元素添加到集合中。import java.util.TreeSet; public class TreeSettest4 { public static void main(String[] args) { TreeSet ts = new TreeSet((o1, o2) -> { M m1 = (M) o1; M m2 = (M) o2; return m1.age > m2.age ? -1 : m1.age &lt; m2.age ? 1: 0; }); ts.add(new M(5)); ts.add(new M(-3)); ts.add(new M(9)); System.out.println(ts); } }上面使用目标类型为 Comparator 的 Lambda 表达式，它负责 ts 集合的排序。所有 M 类无需实现 Comparable 接口，而是由 TreeSet 关联的 Lambda 表达式负责元素的排序。在实现 compareTo 方法时，强烈推荐与 equals 结果一致，否则可能会出现一些奇怪的错误。因为有些类是根据 equals 来判断重复性，有些是利用自然排序 x.compareTo(y) == 0 来判断。compareTo 是判断元素在排序中的位置是否相等，equals 是判断元素是否相等，既然一个决定排序位置，一个决定相等，所以我们非常有必要确保当排序位置相同时，其equals也应该相等。EnumSet 类EnumSet 是专为枚举类设计的集合类，EnumSet 中的所有元素都必须是指定枚举类型的枚举类，该枚举类型在创建 EnumSet 时显式或隐式的的指定。EnumSet 的集合元素是有序的，以枚举值在 Enum 类内的定义顺序来决定集合元素的顺序。EnumSet 集合不允许插入 null 元素。EnumSet 内部以位向量的形式存储，这种存储形式紧凑高效，占用内存很小，运行效率很高。尤其是在进行批量操作时，比如调用 containsAll 和 retainAll 方法时。Map 集合定义：Map 用于保存具有映射关系的数据，key 和 value 之间存在单向的一对一关系，key 不允许重复。Set 与 Map 之间关系非常密切，如果把 key-value 对中的 value 当成 key 的附庸，key 在哪里，value 就在哪里。这样就可以像对待 Set 一样对待 Map 了。实际上，Map 提供了一个 Entry 内部类来封装 key-value 对，而计算 Entry 存储时则只考虑 Entry 封装的 key。从源码来看，Java 是先实现了 Map，然后通过包装一个所有 value 都为 null 的 Map 就实现了 Set 集合。HashMap 实现类HashMap 中用作 key 的对象必须实现 hashCode() 方法和 equals() 方法。HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法比较返回 true，两个 key 的 hashCode 值也相等。HashMap 判断两个 value 相等的标准是：两个对象通过 equals() 方法返回 true 即可。与 HashSet 类似，当使用自定义类作为 HashMap 的 key 时，如果重写该类的 equals() 方法 和 hashCode() 方法，则应该保证两个方法的判断标准一致，即当两个 key 通过 equals() 方法比较返回 true 时，两个 key 的 hashCode() 方法返回值也应该相同。与 HashSet 类似，尽量不要使用可变对象作为 HashMap 的 key，如果使用了，则尽量不要在程序中修改作为 key 的可变对象。LinkedHashMap 实现类LinkedHashMap 也使用双向链表来维护 key-value 对的次序（其实只需要考虑 key 的次序），该链表负责维护 Map 的迭代顺序，迭代顺序与 key-value 对的插入顺序保持一致。import java.util.LinkedHashMap; public class LinkedHashMapTest { public static void main(String[] args) { LinkedHashMap scores = new LinkedHashMap(); scores.put(\"Chinses\", 80); scores.put(\"English\", 82); scores.put(\"Math\", 76); scores.forEach((key ,value) -> System.out.println(key + \"--->\" + value)); } }TreeMap 实现类TreeMap 是一个红黑树数据结构，每个 key-value 对即作为红黑树的一个节点。TreeMap 存储 key-value 对节点时，需要根据 key 对节点进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。两种排序方式：自然排序：TreeMap 的所有 key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的对象，否则会抛出 ClassCastException 异常定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。采用定制排序时不要求 Map 的 key 实现 Comparable 接口TreeMap 判断两个 key 相等的标准是：两个 key 通过 compareTo 方法返回 0。类似于 TreeSet，如果使用自定义类作为 TreeMap 的 key，为了让 TreeMap 良好的工作，则重写该类的 equals() 方法和 compareTo() 方法时应该保持一致的结果：两个 key 通过 equals 方法比较返回 true 时，它们通过 compareTo 方法比较应该返回 0。在实现 compareTo 方法时，强烈推荐与 equals 结果一致，否则可能会出现一些奇怪的错误。因为有些类是根据 equals 来判断重复性，有些是利用自然排序 x.compareTo(y) == 0 来判断。compareTo 是判断元素在排序中的位置是否相等，equals 是判断元素是否相等，既然一个决定排序位置，一个决定相等，所以我们非常有必要确保当排序位置相同时，其equals也应该相等。官方文档的说明：Virtually all Java core classes that implement Comparable have natural orderings that are consistent with equals.EnumMap 实现类EnumMap 的 key 必须是单个枚举类的枚举值。EnumMap 具有以下特征：EnumMap 在内部以数组形式保存EnumMap 根据 key 的自然顺序（即枚举值在枚举类中的定义顺序）来维护 key-value 对的顺序EnumMap 不能使用 null 作为 key 值创建 EnumMap 时必须指定一个枚举类，从而将该 EnumMap 和指定枚举类相关联。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-异常","slug":"Java/基础/异常","date":"2020-04-02T03:18:57.000Z","updated":"2020-04-17T07:27:27.588Z","comments":true,"path":"2020/04/02/java/ji-chu/yi-chang/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/yi-chang/","excerpt":"","text":"异常层次Error：Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。ExceptionRuntimeException：由程序错误导致的异常其他异常：程序本身没有问题，但由类似 IO 错误导致的异常Checked 异常 &amp; Runtime 异常Checked 异常：不是 RuntimeException 类及其子类的异常实例Runtime 异常：所有 RuntimeException 类及其子类的异常实例Java 认为 Checked 异常都是可以被处理修复的异常，所以程序必须显示处理 Checked 异常，如果程序没有处理 Checked 异常，编译时会出错。Checked 异常体现了 Java 的设计理念，没有完善错误处理的代码根本不会被执行。对 Checked 异常处理方式：当前方法明确知道如何处理该异常，应该使用 try-catch 处理该异常当前方法不知道如何处理该异常，应在定义该方法时声明抛出该异常对 Runtime 异常的处理方式：Runtime 异常无需显式声明抛出，如果程序需要捕获 Runtime 异常，也可以使用 try-catch 块throws 声明抛出异常如果当前方法不知道如何处理这种类型的异常，该异常应该由上一级调用者处理，如果上一级调用者也不知道如何处理，再抛出直至交由 JVM 处理。throws 声明抛出只能在方法声明中使用，可以声明抛出多个异常类。一旦使用 throws 语句声明抛出该异常，程序就无需使用 try-catch 来捕获异常了。示例：下面程序声明不处理 IOException 异常，而是将该异常交由 JVM 处理import java.io.FileInputStream; import java.io.IOException; public class ThrowsTest { public void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(\"a.txt\"); } }如果某段代码中调用了一个带 throws 声明的方法，该方法声明抛出了 Checked 异常，则表明该方法希望它的调用者来处理该异常。那么调用者在调用该方法时，要么将其放入 try 块中并显示捕获该异常，要么放在另一个带 throws 声明抛出的方法中。示例代码如下：import java.io.FileInputStream; import java.io.IOException; public class ThrowsTest2 { public static void test() throws IOException { /* 因为 FileInputStream 的构造器声明抛出 IOException 异常 所以调用 test() 方法 的代码要么处于 try-catch 块中 要么处于另一个带 throws 声明抛出的方法中 */ FileInputStream fis = new FileInputStream(\"a.txt\"); } public static void main(String[] args) throws Exception { /* 因为 test() 方法声明抛出 IOException 异常 所以调用该方法的代码要么处于 try-catch 块中 要么处于另一个带 throws 声明抛出的方法中 */ test(); } }主动抛出异常 throw如果 throw 语句抛出的异常是 Checked 异常，则该 throw 语句要么处于 try 块里，显式捕获该异常，要么放在一个带 throws 声明抛出的方法中；如果 throw 语句抛出的是 Runtime 异常，则无需放在 try 块里，也无需放在带 throws 声明抛出的方法中，既可以显式的用 try-catch 来捕获并处理异常，也可以完全不理会该异常，把该异常交给该方法调用者处理。import java.io.IOException; public class ThrowTest3 { public static void throwChecked(int a) throws Exception { if (a > 0) { // 自行抛出 Exception 异常 // 该代码必须处于 try 块里，或处于带 throws 声明的方法中 throw new Exception(\"a的值大于0，不符合要求\"); } } public static void throwRuntime(int a) { if (a > 0) { // 自行抛出 RuntimeException 异常 // 既可以捕获该异常，也可以完全不理会该异常，把异常交给方法调用者处理 throw new RuntimeException(\"a的值大于0，不符合要求\"); } } public static void main(String[] args) { try { // 调用声明抛出 Checked 异常的方法，要么显式在 try-catch 中捕获该异常，要么在 main 方法中再次声明抛出 throwChecked(3); } catch (Exception e) { System.out.print(e.getMessage()); } // 调用声明抛出 Runtime 异常的方法既可以显式捕获该异常，也可以不理会该异常 throwRuntime(3); } }自定义异常类public class AuctionException extends Exception { // 无参构造器 public AuctionException() {} // 带一个字符串参数的构造器 public AuctionException(String msg) { super(msg); } }异常链将原始信息隐藏起来，仅向上提供必要的异常提示信息的处理方式，可以保证底层异常不会扩散到表现层，避免向上暴露太多的细节，符合面向对象的封装原则。public calSal() throws SalException { try { // 实现结算工资的业务逻辑 ... } catch (SQLException sqle) { // 将原始异常记录下来，留给管理员 ... // 下面异常中的 message 就是给用户的提示 throw new SalException(\"访问数据库异常“); } catch (Exception e) { // 将原始异常记录下来，留给管理员 ... // 下面异常中的 message 就是给用户的提示 throw new SalException(\"系统出现未知异常“); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-匿名内部类","slug":"Java/基础/匿名内部类","date":"2020-04-02T02:45:15.000Z","updated":"2020-04-02T02:46:33.952Z","comments":true,"path":"2020/04/02/java/ji-chu/ni-ming-nei-bu-lei/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/ni-ming-nei-bu-lei/","excerpt":"","text":"匿名内部类适合创建只需要一次使用的类，创建匿名内部类时会立即创建一个该类的实例，这个类定义立即消失，匿名类不能重复使用。匿名类是用来创建接口或者抽象类的实例的。匿名内部类不能定义构造器。因为匿名内部类没有类名，所有无法定义构造器。但匿名内部类可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。定义匿名内部类格式如下：new 实现接口 | 抽象父类构造器(实参列表) { 匿名内部类的类体部分 }最常用的创建匿名内部类的方式是需要创建某个接口类型的对象，如下public interface ProductA { public double getPrice(); public String getName(); }public class AnonymousTest { public void test(ProductA p) { System.out.println(\"Buy a\" + p.getName() + \"Cost \" + p.getPrice()); } public static void main(String[] args) { AnonymousTest ta = new AnonymousTest(); // 调用 test() 方法时，需要传入一个 Product 参数 // 此处传入其匿名实现类的实例 ta.test(new ProductA() { @Override public double getPrice() { return 567.8; } @Override public String getName() { return \"APG Card\"; } }); } }通过继承抽象父类来创建匿名内部类时，匿名内部类将拥有和父类相同形参列表的构造器。看下面一段代码public abstract class Device { private String name; public abstract double getPrice(); public Device() {}; public Device(String name) { this.name = name; } public String getName() { return this.name; } public void setName(String name) { this.name = name; } }public class AnonymousInner { public void test(Device d) { System.out.println(\"Buy a\" + d.getName()+ \"Cost\" + d.getPrice()); } public static void main(String[] args) { AnonymousInner ai = new AnonymousInner(); // 调用有参数的构造器创建 Device 匿名实现类的对象 ai.test(new Device(\"电子显示器\") { @Override public double getPrice() { return 67.8; } }); // 调用无参数的构造器创建 Device 匿名实现类的对象 Device d = new Device() { // 初始化块 { System.out.println(\"匿名内部类的初始化块\"); } // 实现抽象方法 @Override public double getPrice() { return 56.2; } // 重写父类的实例方法 public String getName() { return \"keyboard\"; } }; ai.test(d); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-内部类","slug":"Java/基础/内部类","date":"2020-04-02T02:40:00.000Z","updated":"2020-04-02T02:45:06.182Z","comments":true,"path":"2020/04/02/java/ji-chu/nei-bu-lei/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/nei-bu-lei/","excerpt":"","text":"非静态内部类public class Cow { private double weight; public Cow() { } public Cow(double weight) { this.weight = weight; } // 定义一个非静态内部类 private class CowLeg { private double length; private String color; public CowLeg() {} public CowLeg(double length, String color) { this.length = length; this.color = color; } public double getLength() { return this.length; } public void setLength(double length) { this.length = length; } public String getColor() { return this.color; } public void setColor(String color) { this.color = color; } public void info() { System.out.println(\"当前牛腿的颜色是 \" + this.color + \", 长 \" + this.length); // 直接访问外部类的 private 修饰的成员变量 System.out.println(\"该牛腿所属的奶牛重: \" + weight); } } public void test() { CowLeg cl = new CowLeg(1.12, \"黑白相间\"); cl.info(); } public static void main(String[] args) { Cow cow = new Cow(378.9); cow.test(); } }在非静态内部类里可以直接访问外部类的 private 成员，这是因为在非静态内部类对象里，保存了一个它所寄生的外部类对象的引用。如下图：如果外部类成员变量、内部类成员变量与内部类里方法的局部变量名同名直接访问局部变量this，访问内部类实例的变量外部类类名.this.varName 访问外部类实例变量外部类不能直接访问非静态内部类的成员，无论非静态内部类的成员是什么修饰符修饰的。只能显示创建非静态内部类对象来访问其实例成员。静态内部类如果用 static 修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此也叫做类内部类。即静态内部类是外部类的一个静态成员。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。外部类依然不能直接访问静态内部类的成员，但可以使用静态内部类的类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类对象作为调用者来访问静态内部类的实例成员。在外部类以外的地方访问内部类（包括静态和非静态两种），则内部类不能使用 private 修饰，private 修饰的内部类只能在外部类内部使用。对于使用其他访问修饰符的内部类，按照访问修饰符范围访问。在外部类之外使用非静态内部类由于非静态内部类的对象必须寄生在外部类的对象里，因此在创建非静态内部类对象之前，必须先创建其外部类对象。示例代码，如下：public class Out { // 使用默认访问控制符，同一个包中的其他类可以访问该内部类 class In { public In(String msg) { System.out.println(msg); } } }public class CreateInnerInstance { public static void main(String[] args) { Out.In in = new Out().new In(\"Test Msg\"); /* 上面代码可以改为如下三行代码 使用 OutterClass.InnerClass 的形式定义内部类变量 Out.In in; 创建外部类实例，非静态内部类实例将寄生在该实例中 Out out = new Out(); 通过外部类实例和new来调用内部类构造器创建非静态内部类实例 in = out.new In(\"Test Msg\"); */ } }下面定义了一个子类继承了 Out 类的非静态内部类 In 类public class SubClass extends Out.In{ // 显示定义 SubClass 的构造器 public SubClass(Out out){ out.super(\"hello\"); } }上面的代码可能看起来很怪，其实很正常：非静态内部类 In 类的构造器必须使用外部类对象来调用，代码中 super 代表调用 In 类的构造器，而 out 则代表外部类对象。如果需要创建 SubClass 对象时，必须创建一个 Out 对象。因为 SubClass 是非静态内部类 In 的子类，非静态内部类 In 对象里必须有一个对 Out 对象的引用，其子类 SubClass 对象里也应该持有对 Out 对象的引用。当创建 SubClass 对象时传给该构造器的 Out 对象，就是 SubClass 对象里 Out 对应引用所指向的对象。结合上面两段代码，非静态内部类 In 对象和 SubClass 对象都必须持有指向 Outer 对象的引用，区别是创建两种对象时传入 Out 对象的方式不同：当创建非静态内部类 In 类的对象时，必须通过 Outer 对象来调用 new 关键字；当创建 SubClass 类的对象时，必须使用 Outer 对象作为调用者来调用 In 类的构造器在外部类之外使用静态内部类因为静态内部类是外部类类相关的，因此创建静态内部类对象时无需创建外部类对象。public class CreateStaticInnerInstance { public static void main(String[] args) { StaticOut.StaticIn in = new StaticOut.StaticIn(); /* 上面的代码可改为如下两行代码 使用 OuterClass.InnerClass 的形式定义内部类变量 StaticOut.StaticIn in; 通过 new 调用内部类构造器创建静态内部类实例 in = new StaticOut.StaticIn(); */ } }因为调用静态内部类的构造器时不需要使用外部类对象，所以创建静态内部类的子类也比较简单。下面代码为静态静态内部类 StaticIn 定义了一个空的子类public class StaticSubClass extends StaticOut.StaticIn {}","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-抽象类","slug":"Java/基础/抽象类","date":"2020-04-02T02:31:52.000Z","updated":"2020-04-02T02:54:50.676Z","comments":true,"path":"2020/04/02/java/ji-chu/chou-xiang-lei/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/chou-xiang-lei/","excerpt":"","text":"设计思想抽象类是模板模式的设计模式体现。抽象类是从多个具体类中抽象出来的父类，具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类为其子类的模板，避免子类设计的随意性使用抽象类使用 abstract 修饰。抽象类可以和普通类一样可以包含成员变量、方法、构造器、初始化块、内部类。但抽象类不能被实例化，抽象类的构造器主要用来被子类调用。抽象类可以不包含抽象方法，但是含有抽象方法的类必须被定义为抽象类。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-接口","slug":"Java/基础/接口","date":"2020-04-02T02:27:19.000Z","updated":"2020-04-02T02:39:41.787Z","comments":true,"path":"2020/04/02/java/ji-chu/jie-kou/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/jie-kou/","excerpt":"","text":"设计思想接口体现的是规范和实现分离的设计哲学，让软件系统的各组件之间面向接口耦合，是一种松耦合的设计。接口定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，意味着接口通常是定义一组公共方法。定义接口的修饰符，只能是 public 或者 default。由于接口定义的是一种规范，所以接口里不能包含构造器和初始化块定义，只能包含静态常量、方法（只能是抽象方法，类方法和默认方法）以及内部类、内部接口、内部枚举。接口里的常量只能是静态常量，默认使用 public static final 修饰。接口里的内部类、内部接口、内部枚举，默认使用 public static 修饰。接口里的抽象方法不能有方法体，但类方法和默认方法必须有方法体。方法说明接口中定义抽象方法可以省略 abstract 关键字和修饰符，默认修饰符为 public。Java 8 新增允许在接口中定义默认方法，使用 default 修饰。默认情况下，系统使用 public 修饰默认方法。Java 8 新增允许在接口中定义私有方法。Java 8 新增允许在接口中定义静态方法。静态方法可以被实现的接口的类继承。使用一个类可以实现一个或多个接口。一个类实现一个或多个接口，这个类必须重写所实现的接口中的所有抽象方法。否则，该类必须被定义成抽象类，保留从父接口继承到的抽象方法。接口不能用来创建实例，但是可以用于声明引用类型的变量，该变量必须指向实现该接口的类的实例对象。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-Object 类","slug":"Java/基础/Object-类","date":"2020-04-02T02:04:19.000Z","updated":"2020-04-02T02:26:41.450Z","comments":true,"path":"2020/04/02/java/ji-chu/object-lei/","link":"","permalink":"https://tianny.cc/2020/04/02/java/ji-chu/object-lei/","excerpt":"","text":"Object 类是所有类的父类。下面介绍几个 Object 类中常用的方法。toStringtoString 用于输出对象的自我描述信息。Object 类提供的 toString 返回该对象实现类的 “类名 + @ + hashCode”。通常需要重写该方法。==对于基本数据类型的变量，只要两个变量的值相等（不需要数据类型完全相同），就返回 true。对于两个引用类型的变量，只有它们指向同一个对象时，== 判断才会返回 true。equals对于引用变量，只有指向同一个对象时才返回 true。当仅需要判断值相等时，一般需要重写 equals 方法。重写 equals 方法的示例： public boolean equals(Object obj) { if (this == obj) { return true; } if (obj !=null &amp;&amp; obj.getClass() == Person.class) { Person personObj = (Person)obj; if (this.getIdStr().equals(personObj.getIdStr())) { return true; } } return false; }注意：如果equals 为 true，那么也需要重写 hashcode 方法，以保证 hashCode() 返回值相等，这是一种约定俗称的规范。即 equals 为 true 是 hashCode 相等的充分非必要条件。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"顺序 并行 并发","slug":"Java/多线程/顺序-并行-并发","date":"2020-03-29T05:53:00.000Z","updated":"2020-03-29T05:55:04.494Z","comments":true,"path":"2020/03/29/java/duo-xian-cheng/shun-xu-bing-xing-bing-fa/","link":"","permalink":"https://tianny.cc/2020/03/29/java/duo-xian-cheng/shun-xu-bing-xing-bing-fa/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://tianny.cc/tags/多线程/"}]},{"title":"UML 图示","slug":"Java/基础/UML-图示","date":"2020-03-26T01:23:37.000Z","updated":"2020-03-26T02:00:28.304Z","comments":true,"path":"2020/03/26/java/ji-chu/uml-tu-shi/","link":"","permalink":"https://tianny.cc/2020/03/26/java/ji-chu/uml-tu-shi/","excerpt":"","text":"UML 是分析程序和理解程序间的调用关系时，不可多得的利器。这里简单介绍几种程序开发中经常使用的 UML 视图，并辅以真实的 Java 案例。类图UML 中的类图表示用于表示类、接口、实例之间的静态关系。类的层次关系展示类的层次关系，如下图接口与实现展示接口与实现类的关系，如下图聚合只要在一个类中持有另一个类的实例，无论是单个还是多个，这种持有关系就称之为聚合。展示聚合关系，如下图可见性类的属性和方法的可见性（访问控制），如下图类的关联类之间的关联关系，如下图：时序图类图表示的静态关系不随时间流逝而变化，而时序图恰好相反，随着时间流逝而发生变化的关系。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-多态","slug":"Java/基础/多态","date":"2020-03-17T04:49:40.000Z","updated":"2020-03-17T05:05:53.257Z","comments":true,"path":"2020/03/17/java/ji-chu/duo-tai/","link":"","permalink":"https://tianny.cc/2020/03/17/java/ji-chu/duo-tai/","excerpt":"","text":"Java 引用变量有两个类型。如果编译时类型和运行时类型不一致，就可能出现多态。编译时类型：由声明该变量时使用的类型决定运行时类型：由实际运行时赋给该变量的对象决定向上类型转换示例代码：public class BaseClass { public int book = 6; public void base() { System.out.println(\"父类的普通方法\"); } public void test() { System.out.println(\"父类的test方法\"); } } public class SubClass extends BaseClass { public String book = \"轻量级 Java EE\"; public void test() { System.out.println(\"子类的test方法\"); } public void sub() { System.out.println(\"子类的sub方法\"); } public static void main(String[] args) { BaseClass ploymophicBc = new SubClass(); System.out.println(ploymophicBc.book); ploymophicBc.base(); ploymophicBc.test(); // 因为 ploymophicBc 的编译时类型是 BaseClass // BaseClass 类没有提供 sub 方法，所以下面代码编译时会出错 // ploymophicBc.sub(); } }上面的例子中，引用变量 ploymophicBc 比较特殊，它的编译时类型是 BaseClass，而运行时类型是 SubClass。ploymophicBc.sub() 这行代码会在编译时报错，因为 ploymophicBc 编译时类型为 BaseClass，而 BaseClass 中没有定义 sub 方法，因此编译时无法通过。但是注意，ploymophicBc.book 的值为 6， 而不是 ”轻量级 Java EE“。因为对象的实例变量不具备多态性，系统总是试图访问它编译时类型所定义的成员变量，而非运行时。小结子类其实是一种特殊的父类，因此 java 允许把父类的引用指向子类对象，这被称为向上转型（upcasting），向上转型由系统自动完成。可以调用哪些方法，取决于引用类型（编译时）。具体调用哪个方法，取决于引用指向的实例对象（运行时）。向下类型转换问题：引用变量在代码编译过程中，只能调用它编译时类型具备的方法，而不能调用它运行时类型具备的方法解决：强制转换成运行时类型方法：引用类型之间的转换只能在有继承关系的两个类型之间进行，否则编译出错。如果想把一个父类引用变量的编译时类型转换成子类类型，则这个引用变量的运行时类型得是子类类型，否则引发 ClassCastException 异常示例代码：//创建子类对象 Dog dog = new Dog(); // 向上类型转换(类型自动提升),不存在风险 // 此时 animal 为 Dog 类型 Animal animal = dog; // 风险演示：编译阶段不会报错，但是运行时会报错 // 根据上面的语句，此时 animal 指向 Dog 类型对象，没有办法转化成 Cat 对象。 Cat cat = (Cat)animal; // 1.强转成功，编译时按 Cat 类型 2. 但运行时 Dog 类型，类型不匹配，直接报错instanceof为了解决强制类型转换，可能引发的 ClassCastException 异常，引入 instanceof 运算符。instanceof 运算符的含义：用于判断左边的对象（运行时类型）是否是右边的类或者其子类、实现类的实例。如果是返回 true，否则返回 false。在之前的代码中，强制类型转换前使用 instanceof 判断：if (anmial instanceof Cat) { Cat cat = (Cat)animal; }","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-方法传参","slug":"Java/基础/方法传参","date":"2020-03-17T01:29:04.000Z","updated":"2020-03-17T01:57:44.625Z","comments":true,"path":"2020/03/17/java/ji-chu/fang-fa-chuan-can/","link":"","permalink":"https://tianny.cc/2020/03/17/java/ji-chu/fang-fa-chuan-can/","excerpt":"","text":"无论是基本类型的值传递，还是引用类型的参数传递，在 Java 中方法总是采用按值调用。对于引用类型，传递的是其对应的内存空间地址。基本类型的值传递public class PrimitiveTransferTest { public static void swap(int a, int b) { int tmp = a; a = b; b = tmp; System.out.println(\"swap 方法里 a 的值为: \" + a + \" b的值为: \" + b); } public static void main(String[] args) { int a = 6; int b = 9; swap(a, b); System.out.println(\"交换结束后 a 的值为 \" + a + \" b的值为 \" + b); } } /** 运行结果： swap 方法里 a 的值为: 9 b的值为: 6 交换结束后 a 的值为 6 b的值为 9 */分析图：main 方法中定义了a、b 变量存储示意图，如下:main 方法中的变量作为参数值传入 swap() 方法存储示意图，如下:swap 方法中 a、b 交换后的存储示意图，如下:java 程序总是从 main() 方法开始执行，main() 方法定义了 a、b 两个局部变量，两个变量在 main 栈区中。在 main() 方法中调用 swap() 方法时，main() 方法此时还未结束，因此系统为 main 方法和 swap 方法分配了两块栈区，用于保存 main 方法和 swap 方法的局部变量。main 方法中的 a、b 变量作为参数传入 swap 方法，实际上是在 swap 方法栈区中重新产生了两个变量 a、b，并将 main 方法栈区中 a、b 变量的值分别赋给 swap 方法栈区中的 a、b 参数（这就是初始化）。此时系统内存中有两个 a 变量、两个 b 变量，只是存在于不同的方法栈区中而已。引用类型的参数传递public class ReferenceTransferTest { public static void swap(DataWrap dw) { int tmp = dw.a; dw.a = dw.b; dw.b = tmp; System.out.println(\"swap 方法里， a 成员变量的的值为: \" + dw.a + \" b 成员变量的值为: \" + dw.b); } public static void main(String[] args) { DataWrap dw = new DataWrap(); dw.a = 6; dw.b = 9; swap(dw); System.out.println(\"交换结束后， a 成员变量的的值为: \" + dw.a + \" b 成员变量的值为: \" + dw.b); } } /** swap 方法里， a 成员变量的的值为: 9 b 成员变量的值为: 6 交换结束后， a 成员变量的的值为: 9 b 成员变量的值为: 6 */你可能会疑问，dw 对象的成员变量 a、b的值也被替换了，这跟前面基本类型的传递完全不一样。这非常容易让人觉得，调用传入 swap 方法的就是 dw 对象本身，而不是它的复制品。其实传递的依然是 dw 的值。分析图：main 方法中创建 DataWrap 对象后的存储示意图，如下:main 方法中 dw 传入 swap() 方法后的存储示意图，如下:系统一样赋值了 dw 的副本，只是关键在于 dw 只是一个引用变量，它存储的值只是一段内存地址，将该内存地址传递给 swap 栈区，此时 swap 栈区的 dw 和 main 栈区的 dw 的值也就是内存地址相同，该段内存地址指向堆内存中的 DataWrap 对象。对 swap 栈区的 dw 操作，也就是对 DataWrap 对象操作。","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-数组","slug":"Java/基础/数组","date":"2020-03-15T06:30:28.000Z","updated":"2020-03-15T06:38:29.053Z","comments":true,"path":"2020/03/15/java/ji-chu/shu-zu/","link":"","permalink":"https://tianny.cc/2020/03/15/java/ji-chu/shu-zu/","excerpt":"","text":"数组是用来存储固定大小的同类型元素。一旦数组初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度不可以改变。即使某个数组的元素被清空，但是它所占的空间依然保留。数组本身也是一种引用类型，既可以存储基本数据类型，也可以存储引用类型，只要存储的数组元素具有相同的类型即可。初始化动态初始化执行动态初始化时，系统会根据声明的数组类型自动为数组元素分配初始值。如果是引用类型，则数组元素的初始值为 null。int[] scores = new int[5];静态初始化显式指定每个元素的初始值int[] scores = {1,2,3,4};遍历数组foreach 遍历数组int[] scores = new int[5];静态初始化显式指定每个元素的初始值int[] scores = {1,2,3,4};遍历数组foreach 遍历数组int[] scores = {1,2,3,4}; for (int score : scores) { System.out.println(score); }数组的本质将数组看成两个部分，一个部分是数组引用，也就是在代码中定义的数组引用变量；另一部分是实际的数组对象，这部分是在堆内存中运行的，通常无法直接访问它，只能通过引用变量来访问。二维数组二维数组本质上还是一维数组，只是其数组元素也是引用，数组元素里保存的引用指向一维数组。String [][] str1 = {new String[3], new String[]{\"hello\"}};代码示意图如下：","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-控制结构","slug":"Java/基础/控制结构","date":"2020-03-15T06:13:21.000Z","updated":"2020-03-15T06:24:45.256Z","comments":true,"path":"2020/03/15/java/ji-chu/kong-zhi-jie-gou/","link":"","permalink":"https://tianny.cc/2020/03/15/java/ji-chu/kong-zhi-jie-gou/","excerpt":"","text":"if-elseif (condition) { statement; } else { statement; }Switchswitch (表达式) { case value1: statement1; break; case value2: statement2; break; case valuen: statementn; break; default: 默认执行的代码; }当 switch 后表达式的值和 case 语句后的值相同时，从该位置向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。case 后面的值可以是常量数值，也可以是一个常量表达式，但不能是变量或带有变量的表达式可以把功能相同的 case 语句合并起来default 块可以出现在任意位置，也可以省略whilewhile (condition) { statement; }do-whiledo { statement; } while (condition);forfor (循环变量初始化; 循环条件; 循环变量变化) { statement； }","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"Java入门-数据类型","slug":"Java/基础/数据类型","date":"2020-03-15T03:24:31.000Z","updated":"2020-03-15T06:09:24.281Z","comments":true,"path":"2020/03/15/java/ji-chu/shu-ju-lei-xing/","link":"","permalink":"https://tianny.cc/2020/03/15/java/ji-chu/shu-ju-lei-xing/","excerpt":"","text":"数据类型基本数据类型变量存储的是数据本身引用类型变量存储的是数据的空间地址类型转换自动类型转换把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，系统将会进行自动类型转换（隐式转换），否则需要强制转换。强制类型转换强制类型转换可能存在溢出导致数据精度丢失的情况。字符串Java 没有内置的字符串类型，而是提供了一个标准类库 String。特征：不可变字符串优点：编译器可以让字符串共享（只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的）","categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"}]},{"title":"HDFS 读写流程","slug":"大数据/HDFS/HDFS-读写流程","date":"2019-09-09T08:17:55.000Z","updated":"2020-03-14T10:56:30.466Z","comments":true,"path":"2019/09/09/da-shu-ju/hdfs/hdfs-du-xie-liu-cheng/","link":"","permalink":"https://tianny.cc/2019/09/09/da-shu-ju/hdfs/hdfs-du-xie-liu-cheng/","excerpt":"","text":"HDFS 文件读取流程Client 端调用 DistributedFileSystem 对象的 open() 方法。由 DistributedFileSystem 通过 RPC 向 NameNode 请求返回文件的 Block 块所在的 DataNode 的地址。（我们知道 HDFS 默认策略对某个 Block 会保存三份副本到不同的 DataNode，那么 NameNode 应该返回哪个 DataNode？答案是根据 DataNode 到 Client 端的距离。假设请求的 Block 块刚好就落在 Client 端所在机器上，即 Client 端本身也是 DataNode，那么毫无疑问 DataNode 将会返回 Client 端所在机器地址。这也验证了 Hadoop 的一个设计特性，移动计算而不是移动数据，极大了减小了带宽。）Client 端调用 FSDataInputStream 对象的 read() 方法，通过 FSDataInputStream 向 DataNode 获取 Block 数据。之后数据流源源不断地从 DataNode 返回至 Client。当最后一个 Block 返回至 Client 端后， DFSInputStream 会关闭与 DataNode 连接。上述过程对 Client 端都是透明的，从 Client 来看，它只是在不停的读取数据流。如果 DFSInputStream 在读取的过程中发生了错误，将会尝试与存有该 Block 副本且距离最近的 DataNode 通信。同时，它会记录下出问题的 DataNode，在之后的数据请求过程中不再与之通信。并报告给 NameNode。DFSInputStream 具备检查数据校验和的功能。HDFS 文件写入流程Client 写入文件时，调用 DistributedFileSystem 对象的 create() 方法。DistributedFileSystem 通过 RPC 请求 NameNode 向其 NameSpace 写入文件元数据信息。NameNode 会做多种检查，如判断文件是否存在，是否有相应的写权限等等。如果检查通过，NameNode 会将文件元数据写入 NameSpace。DistributedFileSystem 将会返回 FSDataOutputStream 用于 Client 端直接向 DataNode 写入数据。DFSOutputStream 将 Client 要写入的数据分割成 Packets。Packets 会被保存到 Data Queue 队列中，并由 DataStreamer 消费处理。DataStreamer 请求 NameNode 分配 DataNode 列表，将 Packets 写入到 DataNode 中。假设放置副本的默认策略是 3，那么 NameNode 将返回 3 个 DataNode，并串联起来组成一条 Pipeline。 DataStreamer 将 Packets 写入到第一个 DataNode1，DataNode1 存储完后直接转发至 DataNode2，DataNode2 存储完后再直接转发至 DataNode3。（注意，这里直接是 DataNode1 直接将 Packet 转发至 DataNode2。）DFSOutputStream 为了防止出问题时数据的丢失，维持了一个等待 DataNode 成功写入的 ACK Queue。只有当 Packet 被成功写入 Pipeline 中的每个 DataNode 时，此 Packet 才会从 ACK Queue 中移除。在 Pipeline 写入的过程中，如果某个 DataNode 出现问题，Pipeline 首先将会被关闭，随后在 ACK Queue 中的 Packets 会被添加到 Data Queue 的最前面，用来防止位于问题节点下游的 DataNode 写入时的数据丢失。出问题的 DataNode 会被从 Pipeline 中移除。NameNode 会重新分配一个健康的 DataNode 构成新的 Pipeline。当 Client 端写完数据，调用 DFSOutputStream 对象的 close() 方法。该操作将会将所有剩余的 Packets 刷写到 DataNode Pipeline 并等待返回确认，之后向 NameNode 发送文件写入完成信号。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://tianny.cc/categories/大数据/"}],"tags":[{"name":"HDFS","slug":"HDFS","permalink":"https://tianny.cc/tags/HDFS/"}]},{"title":"CM & CDH 基本介绍","slug":"大数据/CDH/CM-CDH-基本介绍","date":"2019-08-17T08:00:02.000Z","updated":"2020-03-14T10:51:21.841Z","comments":true,"path":"2019/08/17/da-shu-ju/cdh/cm-cdh-ji-ben-jie-shao/","link":"","permalink":"https://tianny.cc/2019/08/17/da-shu-ju/cdh/cm-cdh-ji-ben-jie-shao/","excerpt":"","text":"什么是 CDHHadoop 是开源项目，所以很多公司在这个基础上进行商业化，不收费的 Hadoop 主要有三个：Apache，最原始的版本，所有发行版均基于这个版本进行Cloudear，全称 Cloudera’s Distribution Including Apache Hadoop，简称 CDHHortonworks，全称 Hortonworks Data Platform，简称 HDP什么是 Cloudera ManagerCloudear Manager，简称 CM，用于管理 CDH 集群，其主要功能是对 CDH 集群进行监控，大大改善原生 Apache Hadoop 的安装、配置复杂度和需要使用第三方开源监控工具所带来的诸多问题，可进行节点安装、配置、诊断、集成并提供 web 界面。CM 架构基本组成：ServerAgent：安装在每个集群节点上，Server 下发的操作都由 Agent 来实现Management Service：监控报警等功能Database：存储各种服务配置信息和报警信息Cloudera Repoistory：用来分发 Parcels 包的远程仓库ClientsServer 和 Agent 通信方式：默认情况下，Agent 每隔 15s 向 Server 发送心跳。但是当状态发生变化时，为了减少用户等待时间，会加快心跳频率。CM 术语host 主机rack 机架cluster 集群service 服务，例如 HDFS、YARN 都是一个个服务role 角色，例如 HDFS 的 NameNode 和 DataNode 都可以称为 HDFS 的 角色role group 角色组，将角色划分为一组方便管理host template 主机模板parcel 包static service pool 静态服务池dynamic resource pool 动态资源池","categories":[{"name":"大数据","slug":"大数据","permalink":"https://tianny.cc/categories/大数据/"}],"tags":[{"name":"CDH","slug":"CDH","permalink":"https://tianny.cc/tags/CDH/"}],"author":"Tianny"}],"categories":[{"name":"Java","slug":"Java","permalink":"https://tianny.cc/categories/Java/"},{"name":"大数据","slug":"大数据","permalink":"https://tianny.cc/categories/大数据/"}],"tags":[{"name":"J2SE","slug":"J2SE","permalink":"https://tianny.cc/tags/J2SE/"},{"name":"多线程","slug":"多线程","permalink":"https://tianny.cc/tags/多线程/"},{"name":"HDFS","slug":"HDFS","permalink":"https://tianny.cc/tags/HDFS/"},{"name":"CDH","slug":"CDH","permalink":"https://tianny.cc/tags/CDH/"}]}